## Службы, предоставляемые верхним уровням

**Цель транспортного уровня — предоставить эффективную, надежную и экономичную службу передачи данных** своим пользователям (обычно это процессы прикладного уровня). **Для этого транспортный уровень применяет службы, предоставленные сетевым уровнем**.

Программа и/или оборудование, выполняющие работу транспортного уровня, называются **транспортной подсистемой**, или **транспортным объектом (transport entity)**. Эта подсистема может находиться в ядре операционной системы, в библиотечном модуле, загруженном сетевом приложении, в отдельном пользовательском процессе или даже в сетевой интерфейсной плате.

**На транспортном уровне, как и на сетевом, могут быть службы, ориентированные на установление соединения, и службы без установления соединения.** Транспортная служба с установлением соединения во многом похожа на аналогичную сетевую. В обоих случаях соединение проходит три этапа: установление, передача данных и разъединение. Адресация и управление потоком на этих уровнях также похожи. Более того, даже транспортные службы без установления соединения очень напоминают
аналогичные сетевые.

#### Если транспортные и сетевые службы так похожи, то зачем нужны два разных уровня?
Программное обеспечение транспортного уровня запускается целиком на пользовательских устройствах, а сетевой уровень — в основном на маршрутизаторах. 

Пользователи не контролируют сетевой уровень, поэтому не смогут решить проблему плохого обслуживания, используя более совершенные маршрутизаторы или совершенствуя обработку ошибок канального уровня (просто потому, что маршрутизаторы им не принадлежат). Единственная возможность — расположить над сетевым уровнем еще один уровень, который будет улучшать QoS.  **Наличие транспортного уровня делает транспортную службу более надежной, чем нижележащая сеть, которая не отличается стабильностью.**

**Благодаря транспортному уровню прикладные программисты могут писать код согласно стандартному набору примитивов и сохранять работоспособность программ в самых разных сетях. Им не приходится учитывать разнообразные сетевые интерфейсы и уровни надежности.** Если бы все сети работали идеально, имели одинаковые примитивы служб и никогда не менялись, то транспортный уровень, вероятно, был бы не нужен. Однако в реальности он выполняет ключевую функцию: изолирует верхние уровни от деталей технологии, устройства и несовершенства сети.

**Нижние уровни можно рассматривать как поставщика транспортных служб (transport service provider), а верхние уровни — как пользователя транспортных служб (transport service user).**

## Примитивы транспортных служб

Примитивы транспортных служб — это базовые операции или функции, предоставляемые транспортным уровнем или в рамках сетевых протоколов. Эти примитивы обеспечивают основные возможности для передачи данных между узлами сети и играют ключевую роль в управлении процессами передачи, контролем ошибок и обеспечением надежности.

#### Пример простых примитив транспортной службы:
![[Pasted image 20241231182132.png]]


#### Сегмент
Термина, для сообщений, отправляемых одной транспортной подсистемой другой транспортной подсистеме, нам придется использовать понятие **сегмент (segment)**.
В более старых протоколах применялось громоздкое название модуль данных транспортного протокола (Transport Protocol Data Unit, TPDU)

Сегменты, используемые транспортным уровнем, помещаются в пакеты, которыми обменивается сетевой уровень. Эти пакеты, в свою очередь, содержатся во фреймах, которые передает канальный уровень. Получив фрейм, процесс канального уровня обрабатывает его заголовок, и если адрес назначения совпадает с местом доставки, передает содержимое поля пользовательских данных наверх сетевой подсистеме. Сетевая подсистема похожим образом обрабатывает заголовок пакета и передает содержимое поля пользовательских данных пакета наверх транспортной подсистеме. 
![[Pasted image 20241231182308.png]]

#### Пример работы примитив
В результате запроса клиента CONNECT серверу отравляется сегмент, содержащий
CONNECTION REQUEST (запрос соединения). 

Когда он прибывает, транспортная подсистема проверяет, заблокирован ли сервер примитивом LISTEN (то есть готов ли он к обработке запросов). Затем она снимает блокировку сервера и отсылает обратно клиенту сегмент CONNECTION ACCEPTED (соединение принято). Получив этот сегмент, клиент разблокируется, после чего соединение считается установленным.

Теперь клиент и сервер могут обмениваться данными с помощью примитивов SEND и RECEIVE. В простейшем случае каждая из сторон использует блокирующий примитив RECEIVE для перехода в режим ожидания сегмента, который передается другой стороной с помощью SEND. Когда сегмент прибывает, получатель разблокируется. Затем он может обработать полученный сегмент и отправить ответ. 
Такая схема прекрасно работает, пока обе стороны помнят, чья очередь передавать, а чья — принимать данные.

Когда соединение больше не требуется, оно должно быть разорвано, чтобы освободить место в таблицах двух транспортных подсистем. **Разъединение бывает симметричным и асимметричным**. 
В асимметричном варианте одна из сторон может вызвать примитив DISCONNECT, в результате чего другая сторона получает управляющий сегмент DISCONNECTION REQUEST (запрос разъединения) и соединение разрывается. 
В симметричном варианте каждое направление закрывается отдельно, независимо от другого. Когда одна сторона выполняет операцию DISCONNECT, это означает, что у нее больше нет данных для передачи, но при этом она все еще готова принимать данные от своего партнера. В этой схеме соединение разрывается, когда обе стороны выполняют операцию DISCONNECT.

==На транспортном уровне даже простая однонаправленная пересылка данных сложнее, чем на сетевом. Каждый отправленный пакет будет в конце концов подтвержден.== Пакеты с управляющими сегментами также подтверждаются, явно или неявно.
	Эти подтверждения управляются транспортными подсистемами при помощи протокола сетевого уровня и не видны пользователям транспортного уровня. 


## Сокеты Беркли

Сокеты Беркли (Berkeley Sockets) — это интерфейс программирования, который предоставляет стандартные функции для сетевого взаимодействия

Модель сокетов во многом похожа на представленную выше, но обладает большей гибкостью и предоставляет больше возможностей.

#### Примитивы сокетов для TCP
![[Pasted image 20241231183839.png]]

#### Структура сокетов
1. Создание сокета

- **Примитив: SOCKET**

  - Создает новый сокет, но не назначает ему сетевые адреса.

2. Привязка адреса

- **Примитив: BIND**

  - Привязывает сетевой адрес к сокету.
  - Позволяет удаленным клиентам связываться с сервером.
  - Важно для процессов, которые используют постоянные адреса (например, известные адреса, используемые годами).

3. Ожидание соединений

- **Примитив: LISTEN**

  - Выделяет место для очереди входящих соединений.
  - Не является блокирующим вызовом (в отличие от других примитивов).

4. Принятие соединения

- **Примитив: ACCEPT**

  - Блокирует выполнение до получения запроса на соединение.
  - Создает новый сокет с теми же свойствами, что и исходный.
  - Возвращает файловый дескриптор для нового сокета.
  - Позволяет серверу разветвить процесс или поток для обработки нового соединения, продолжая ожидание новых соединений на первоначальном сокете.

5. Процесс клиента

- Создание сокета: 

  - Клиент также использует SOCKET для создания сокета.
  - BIND не требуется, так как адрес клиента не имеет значения для сервера.
  
- Установление соединения:

  - **Примитив: CONNECT**

    - Блокирует вызывающий процесс и инициирует активное соединение.
    - Когда сервер подтверждает соединение, клиент разблокируется, и соединение считается установленным.

6. Передача данных

- **Примитивы: SEND и RECEIVE**

  - Используются для передачи и получения данных по полнодуплексному соединению.
  - Также могут применяться стандартные UNIX-вызовы READ и WRITE, если нет необходимости в специфических свойствах SEND и RECEIVE.

7. Завершение соединения

- **Примитив: CLOSE**

  - Используется обеими сторонами для симметричного разрыва соединения.


#### Пример кода на C работы сокетов
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

#define PORT 8080

int main() {
    int server_fd, new_socket;
    struct sockaddr_in address;
    int opt = 1;
    int addrlen = sizeof(address);
    char buffer[1024] = {0};
    
    // Создание сокета
    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
        perror("socket failed");
        exit(EXIT_FAILURE);
    }

    // Привязка сокета
    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt))) {
        perror("setsockopt");
        exit(EXIT_FAILURE);
    }
    
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(PORT);

    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {
        perror("bind failed");
        exit(EXIT_FAILURE);
    }

    // Прослушивание входящих соединений
    if (listen(server_fd, 3) < 0) {
        perror("listen");
        exit(EXIT_FAILURE);
    }

    // Принятие соединения
    if ((new_socket = accept(server_fd, (struct sockaddr *)&address, 
                      (socklen_t*)&addrlen)) < 0) {
        perror("accept");
        exit(EXIT_FAILURE);
    }

    // Чтение данных
    read(new_socket, buffer, 1024);
    printf("%s\n", buffer);

    // Отправка ответа
    const char *hello = "Hello from server";
    send(new_socket, hello, strlen(hello), 0);
    
    // Закрытие сокета
    close(new_socket);
    close(server_fd);

    return 0;
}

```



#### Недочёты сокетов и их альтернативы
Тем не менее последнее слово в вопросе транспортных интерфейсов, скорее всего, останется не за сокетами. **Довольно часто приложениям приходится работать с группой связанных потоков**, например браузер может одновременно запрашивать у сервера несколько объектов. **В таком случае применение сокетов обычно означает, что для каждого объекта будет использоваться один поток**. В результате управление перегрузкой будет выполняться отдельно для каждого потока (а не для всей группы). Безусловно, **это далеко не оптимальный вариант, поскольку управление набором потоков становится задачей приложения**. Чтобы более эффективно обрабатывать группы связанных потоков и уменьшить роль приложения в этом процессе, был создан ряд дополнительных протоколов и интерфейсов. В частности, ==протокол передачи с управлением потоками (Stream Control Transmission Protocol, SCTP), и протокол QUIC. Эти протоколы слегка изменяют сокет-API для удобства работы с группами потоков,== обеспечивая новые возможности, например работу со смешанным трафиком (с установлением соединения и без) и даже поддержку множественных сетевых путей.