Транспортные службы реализуются транспортным протоколом и они напоминают протоколы канального уровня. И те и другие протоколы, помимо прочего, **занимаются обработкой ошибок, управлением очередями и потоками.**
Однако у этих протоколов также имеется множество существенных различий, из-за разных условий, в которых они работают.  На канальном уровне два маршрутизатора общаются напрямую по физическому каналу, а транспортном уровне физический канал заменен целой сетью.
![[Pasted image 20250101133748.png]]

- На транспортном уровне требуется явно указывать адрес получателя.
- На транспортном уровне начальная установка соединения происходит достаточно сложно.
- Еще одно весьма досадное различие между канальным и транспортным уровнями состоит в том, что **сеть потенциально обладает возможностями хранения информации. Последствия способности сети задерживать и копировать пакеты порой катастрофичны и требуют применения специальных протоколов**, обеспечивающих правильную передачу данных.


## Адресация

Когда прикладной процесс устанавливает соединение с другим процессом, он **указывает транспортные адреса, куда отправляются запросы на соединение**. В интернете конечные точки на транспортном уровне называются ==портами==, обозначаемыми как точки доступа к службам транспортного уровня (==TSAP==). На сетевом уровне аналогичные конечные точки называются точками доступа к сетевым службам (==NSAP==), примерами которых являются IP-адреса.
![[Pasted image 20250101134829.png]]

На хосте 2 могут располагаться и другие серверы, соединенные со своими TSAP и ожидающие входящих запросов на соединение, приходящих с той же NSAP.

#### Методы по соединению нужных TSAP 

1. Установка соединения

- **Постоянные TSAP-адреса**: Для известных служб, таких как веб-серверы или почтовые серверы, используются постоянные TSAP-адреса, которые могут быть зарегистрированы в системных файлах (например, /etc/services в UNIX).
  
2. Использование сопоставителя портов (Portmapper)

- **Функция сопоставителя портов**:
  • Пользовательский процесс устанавливает соединение с сопоставителем портов по известному TSAP-адресу.
  • Он отправляет запрос с именем службы (например, "BitTorrent").
  • Сопоставитель портов возвращает соответствующий TSAP-адрес для указанной службы.
  
- Регистрация служб: Новые службы регистрируются на сопоставителе портов, предоставляя свое имя и TSAP-адрес. Эта информация хранится в базе данных сопоставителя для обработки будущих запросов.

4. Протокол начального соединения (Initial Connection Protocol)

- Обрабатывающий сервер (Process Server):

  • Вместо назначения постоянных TSAP-адресов всем службам используется обрабатывающий сервер (например, inetd в UNIX), который прослушивает несколько портов.

  • Если запрашиваемая служба неактивна, запрос перенаправляется на обрабатывающий сервер.

- Создание под процессов:

  • Обрабатывающий сервер создает новый под процесс для запрашиваемой службы, передавая ему существующее соединение с пользователем.

  • После этого обрабатывающий сервер возвращается к ожиданию новых запросов.

## Установление соединения

Установление соединения весьма трудное дело. На первый взгляд достаточно, чтобы одна транспортная подсистема отправила адресату сегмент CONNECTION REQUEST и получила в ответ CONNECTION ACCEPTED. Неприятность заключается в том, что сеть может потерять, задержать, повредить или дублировать пакеты. Это может сильно осложнить ситуацию.

#### Проблема: задержка и дублирование пакетов
Основная проблема заключается в том, что задержавшиеся дубликаты распознаются как новые пакеты. Избежать копирования и задержки пакетов мы не можем. Но если это происходит, копии должны отвергаться и не обрабатываться как новые.

Проблему можно попытаться решить несколькими способами, но на самом деле ни один из них не является оптимальным:

1. Использовать одноразовые транспортные адреса. 
	Каждый раз, когда требуется транспортный адрес, генерируется новый адрес. Когда соединение разрывается, он уничтожается. В этом случае задержавшиеся дубликаты не смогут найти транспортный адрес и, следовательно, перестанут представлять угрозу. **Однако при этом будет сложнее установить соединение с процессом.**

2. Каждому соединению присваивается уникальный идентификатор 
	(последовательный номер, возрастающий на единицу для каждого установленного соединения). Требуется, чтобы каждая транспортная подсистема (как отправитель, так и получатель) практически бесконечно хранила определенное количество информации об истории соединений. Иначе, если устройство выйдет из строя и потеряет данные, оно не сможет определить, какие соединения уже использовались, а какие нет.

Вместо этого можно применить другой подход. Нужен механизм, уничтожающий устаревшие заблудившиеся пакеты и не позволяющий им существовать в сети бесконечно долго. Время жизни пакета может быть ограничено до известного максимума с помощью одного из следующих методов:

1. Проектирование сети с ограничениями.

2. Внедрение в каждый пакет счетчика транзитных участков.

3. Внедрение в каждый пакет временной метки.

- К первому способу относятся все методы, предотвращающие зацикливание пакетов в комбинации с ограничением задержки, включая перегрузки по самому длинному возможному пути. Осуществить эту идею достаточно трудно, учитывая, что интерсеть может охватывать как один город, так и весь мир.

- Второй способ заключается в изначальной установке счетчика на определенное значение и уменьшении его на единицу на каждом маршрутизаторе. Сетевой протокол передачи данных просто игнорирует все пакеты, у которых значение счетчика достигло нуля.

- Третий способ состоит в том, что в каждом пакете указывается время его создания, а маршрутизаторы договариваются игнорировать все пакеты старше определенного времени.

При ограниченном времени жизни пакетов можно разработать надежный и практичный способ отвергать задержавшиеся дублированные сегменты. Автор описанного метода — Томлинсон (Tomlinson, 1975); позднее он был улучшен Саншайном и Далалом (Sunshine and Dalal, 1978). Варианты этого метода широко используются на практике, и одним из примеров применения является TCP.

###### Метод присвоения последовательных номеров сегментам

**Основная идея**

- Отправитель присваивает сегментам уникальные последовательные номера, которые не повторяются в течение определенного времени  T .

- Размер номера определяется периодом  T  и скоростью передачи пакетов в секунду, что позволяет избежать повторного использования одного и того же номера.

**Проблема дубликатов**

- В системе могут возникать дубликаты пакетов, которые получатель должен уметь удалять.

- Для предотвращения ситуации, когда задержавшийся дубликат принимается за новый пакет с тем же номером, необходимо управлять временем и состоянием транспортной подсистемы.

**Решение проблемы сбоя**

- Чтобы избежать потери информации о предыдущих состояниях после сбоя, транспортная подсистема может оставаться неактивной в течение первых  T  секунд после восстановления.

- Это дает возможность старым сегментам исчезнуть, и отправитель может начать процесс заново, используя любые последовательные номера.

**Ограничения метода**

- В крупных интерсетях период времени  T  может быть значительным, что делает данный подход менее эффективным.

**Предложение Томлинсона**

- Каждый хост снабжается генератором импульсов истинного времени, который не требует синхронизации между хостами.

- Генераторы представляют собой двоичные счетчики, увеличивающиеся через равные интервалы времени.

- Количество разрядов счетчика должно быть равно или превышать количество битов в последовательных номерах.

**Начальный порядковый номер**

- При установлении соединения младшие  k -биты генераторов импульсов используются как начальный порядковый номер.

- Это позволяет каждому соединению начинать нумерацию сегментов с разных чисел.

- Диапазон порядковых номеров должен быть достаточно большим, чтобы старые сегменты исчезли до повторного использования тех же номеров.

**Управление потоком данных**

- После согласования начального порядкового номера обеими транспортными подсистемами можно применять любой протокол раздвижного окна для управления потоком данных.

- Такой протокол эффективно обнаруживает и удаляет дубликаты пакетов при их получении.

**Проблемы с запретной зоной**

- Запретная зона определяет моменты времени, когда определенные порядковые номера считаются недействительными.

- Если хост отправляет данные слишком быстро, кривая используемых порядковых номеров может превысить линию зависимости начальных номеров от времени, что приведет к попаданию номера в запретную зону.
  
**Ограничения скорости передачи данных**

- Скорость передачи данных должна быть ограничена одним сегментом за единицу времени.

- После восстановления транспортная подсистема не должна открывать новое соединение до появления нового тактового импульса, чтобы избежать повторного использования одного и того же номера.
  
**Условия работы генератора импульсов**

- Интервал импульсов должен быть коротким (1 мкс или меньше), но генератор не должен работать слишком быстро относительно порядковых номеров.

- Условие  S/C > T  должно выполняться, чтобы номера не делали полный круг слишком быстро.


#### Решение: «тройное рукопожатие»

Для разрешения специфической проблемы Томлинсон (1975) предложил **«тройное рукопожатие» (three-way handshake)**. Этот протокол установления соединения предполагает, что одна из сторон проверяет, является ли соединение все еще действующим. 

Хост 1 выбирает порядковый номер x и отправляет сегмент CONNECTION REQUEST, содержащий этот номер, хосту 2. Хост 2 отвечает сегментом ACK, подтверждая x и объявляя свой начальный порядковый номер y. Наконец, хост 1 подтверждает выбранный хостом 2 номер в первом отправленном им информационном сегменте.

###### Более обширный пример:
1. Клиент, который намеревается установить соединение, посылает серверу сегмент с номером последовательности и флагом SYN.

Дальнейший алгоритм:  
Сервер получает сегмент, запоминает номер последовательности и пытается создать сокет (буферы и управляющие структуры памяти) для обслуживания нового клиента;  
  
В случае успеха сервер посылает клиенту сегмент с номером последовательности и флагами SYN и ACK, и переходит в состояние SYN-RECEIVED;  
  
​В случае неудачи сервер посылает клиенту сегмент с флагом RST.

2. Если клиент получает сегмент с флагом SYN, то он запоминает номер последовательности и посылает сегмент с флагом ACK.

Дальнейший алгоритм:  
  
Если он одновременно получает и флаг ACK (что обычно и происходит), то он переходит в состояние ESTABLISHED;  
  
Если клиент получает сегмент с флагом RST, то он прекращает попытки соединиться;  
  
Если клиент не получает ответа в течение 10 секунд, то он повторяет процесс соединения заново.

3. Если сервер в состоянии SYN-RECEIVED получает сегмент с флагом ACK, то он переходит в состояние ESTABLISHED.

В противном случае после тайм-аута он закрывает сокет и переходит в состояние CLOSED.  
  
Процесс называется «трёхэтапным рукопожатием» (англ. three way handshake), так как несмотря на то что возможен процесс установления соединения с использованием четырёх сегментов (SYN в сторону сервера, ACK в сторону клиента, SYN в сторону клиента, ACK в сторону сервера), на практике для экономии времени используется три сегмента.

**TCP всегда использует «тройное рукопожатие» для установления соединения.** Внутри соединения к 32-битному порядковому номеру добавляется метка времени, чтобы он не мог использоваться повторно в течение максимального времени жизни пакета, даже если скорость соединения составляет несколько гигабитов в секунду. Этот механизм был добавлен в TCP для решения проблем, возникающих при использовании быстрых линий. Он описан в RFC 1323 и называется защитой от повторного использования порядковых номеров **(Protection Against Wrapped Sequence numbers, PAWS)**.

До появления PAWS при наличии нескольких соединений с начальными порядковыми номерами TCP применял метод генератора импульсов. Однако этот метод оказался неэффективным с точки зрения безопасности. Злоумышленники могли легко угадать следующий начальный порядковый номер и инициировать ложное соединение, обманув схему «тройного рукопожатия». Поэтому на практике используются псевдослучайные начальные порядковые номера. Однако необходимо, чтобы эти номера, со стороны кажущиеся абсолютно случайными, не повторялись в течение определенного промежутка времени. Иначе задержавшиеся дубликаты могут вызвать серьезные неполадки в сети.

## Разрыв соединения

Разорвать соединение проще, чем установить. Но здесь также имеются некоторые проблемы. Существует два стиля разрыва соединения: асимметричный и симметричный.

Асимметричный разрыв связи соответствует принципу работы телефонной системы: когда одна из сторон вешает трубку, связь прерывается. Такой разрыв связи является внезапным и может привести к потере данных.

При симметричном разрыве соединение рассматривается в виде двух отдельных однонаправленных связей, и требуется отдельное завершение каждого соединения.

Симметричное разъединение подходит для тех случаев, когда у каждой стороны есть фиксированное количество данных для передачи и каждая из них точно знает, когда эти данные заканчиваются. В других случаях определить, что работа окончена и соединение может быть прервано, не так просто. 
Можно представить себе протокол, в котором хост 1 говорит: «Я закончил передачу. А вы?». Если хост 2 отвечает: «Я тоже. До свидания», соединение можно безо всякого риска разъединять.

К сожалению, этот протокол работает не всегда. **Существует знаменитая проблема «двух армий» (two-army problem).** Она заключается в том что когда две стороны (или хоста) должны договориться о завершении передачи данных, но не могут быть уверены в том, что другая сторона также готова завершить соединение. 

Для решения проблемы "двух армий" могут использоваться различные механизмы:

1. Тайм-ауты: Установление тайм-аутов для ожидания ответов. Если одна сторона не получает ответ в установленный срок, она может предположить, что другая сторона не готова продолжать, и завершить соединение.

2. Сигналы завершения: Использование явных сигналов завершения передачи данных, таких как специальные сообщения или флаги, которые информируют о завершении передачи.

3. Протоколы согласования: Применение более сложных протоколов, таких как алгоритмы консенсуса (например, Paxos или Raft), которые позволяют сторонам достигать согласия даже в условиях неопределенности и сетевых сбоев.


## Контроль ошибок и управление потоком данных
 
Как происходит управление соединением во время его использования.
**Ключевыми проблемами являются контроль ошибок и управление потоком данных.** Контроль ошибок отвечает за передачу данных с необходимой степенью надежности: как правило, это означает, что данные должны доставляться без ошибок. Управление потоком состоит в согласовании скорости источника и получателя. **Оба этих вопроса и решений их  уже были на канальном уровне. На транспортном уровне используются те же механизмы.**

1. **Фрейм содержит код с обнаружением ошибок** (например, **CRC-код или контрольную сумму**), с помощью которого проверяется, правильно ли была доставлена информация.

2. **Фрейм содержит идентифицирующий порядковый номер** и передается отправителем до тех пор, пока не придет подтверждение об успешной доставке. Это называется автоматическим запросом повторной передачи (**Automatic Repeat reQuest, ARQ**).

3. **Число фреймов, передаваемых отправителем в любой момент времени, обычно ограниченно**: передача приостанавливается, если подтверждения приходят недостаточно быстро. Если этот максимум равен одному пакету, протокол называется **протоколом с остановкой и ожиданием подтверждения (stop-and-wait)**. Окна большего размера позволяют использовать конвейерную обработку, а также улучшить производительность при работе с длинными и быстрыми линиями. **Протокол раздвижного окна (sliding window)** сочетает в себе все эти возможности, а также поддерживает двунаправленную передачу данных.

Хоть данные уровни во многом копируют друг друга но существуют различия в их функционировании и качестве.

**Контрольная сумма на канальном уровне защищает фрейм, пока он передается по каналу. На транспортном уровне она защищает сегмент на всем протяжении пути**. Это сквозная проверка, которая отличается от проверки на каждом канале. **Существуют примеры повреждения пакетов даже внутри маршрутизаторов**. Контрольные суммы канального уровня обеспечивали защиту пакетов, пока они передвигались по каналу, но не тогда, когда они были внутри маршрутизатора. В результате мы имеем дело с некорректной доставкой, хотя проверка на каждом канале не выявила ошибок.

##### Сквозной принцип (end-to-end argument)

Зальцер и др. сформулировали сквозной принцип (end-to-end argument).

**Согласно этому принципу:**

- Корректность передачи данных: Проверка целостности данных должна выполняться на конечных узлах. Если данные повреждены в процессе передачи, их следует повторно отправить.

- Улучшение производительности: Хотя проверка на канальном уровне (например, контрольные суммы на уровне Ethernet) может улучшить производительность, она не является обязательной для корректной передачи данных. Например, если пакет поврежден, он может пройти через всю сеть, прежде чем будет обнаружена ошибка, что приводит к дополнительной нагрузке.

##### Управление буферизацией

Выбор компромиссного решения между буферизацией на сторонах отправителя и получателя зависит от типа трафика. 

В случае неинтенсивного и нестабильного трафика, например, когда пользователь производит клавиатурный ввод на удаленном компьютере, лучше не выделять никаких буферов, а получать их динамически на обоих концах, полагаясь на буферизацию со стороны отправителя (на случай, если сегменты будут случайно удалены). 

С другой стороны, в случае передачи файла будет лучше, если получатель выделит целое окно буферов, чтобы данные могли передаваться с максимальной скоростью. Такую стратегию использует TCP.

Тем не менее открытым остается вопрос об организации набора буферов

1. Массив буферов фиксированного размера

	Преимущества:
	- Простота управления: Легко реализовать и управлять, так как все буферы имеют одинаковый размер.
	- Предсказуемость: Простое выделение и освобождение памяти, что позволяет избежать фрагментации.
	Недостатки:
	- Неэффективное использование памяти: Если сегменты данных сильно различаются по размеру, большой буфер может оставаться недозагруженным, а маленький — не вмещать крупные сегменты.
	- Проблемы с крупными сегментами: Для хранения больших сегментов может потребоваться несколько буферов, что усложняет управление и приводит к дополнительным накладным расходам.

2. Буферы переменного размера

	Преимущества:
	- Оптимальное использование памяти: Позволяет выделять ровно столько памяти, сколько необходимо для каждого сегмента, что минимизирует потери.
	- Гибкость: Может адаптироваться под различные размеры сегментов, что особенно полезно в условиях переменной нагрузки.
	Недостатки:
	- Сложность управления: Необходимость отслеживания различных размеров буферов усложняет реализацию и управление.
	- Повышенные накладные расходы: Требуется больше ресурсов для управления памятью и выделения буферов.

3. Циклический буфер

	Преимущества:
	- Эффективное использование памяти: Позволяет непрерывно получать и обрабатывать данные независимо от их размера, что особенно полезно при высокой нагрузке.
	- Устойчивость к переполнению: При заполнении буфера новые данные могут перезаписывать старые, что может быть полезно в определенных сценариях.
	Недостатки:
	- Зависимость от нагрузки: Эффективность использования памяти снижается, если соединения не сильно нагружены, так как может возникнуть неиспользуемое пространство.
	- Сложности с управлением данными: Необходимо следить за тем, какие данные были перезаписаны, что может усложнить обработку информации.
![[Pasted image 20250101161334.png]]


При открытии и закрытии соединений и при изменении формы трафика отправитель и получатель должны динамически изменять выделенные буферы. Следовательно, транспортный протокол должен позволять отправителю отправлять запросы на выделение буфера на другой стороне. Буферы могут выделяться для каждого соединения или коллективно на все соединения между двумя хостами. В качестве альтернативы запросам получатель, зная состояние своих буферов, но не зная, какой трафик ему будет предложен, может сообщить отправителю, что он зарезервировал для него Х буферов. 

**Для реализации динамического выделения буферов** следует отделить буферизацию от подтверждений. Динамическое выделение буферов на деле означает использование окна переменного размера. Сначала отправитель запрашивает определенное число буферов согласно своим потребностям. Получатель выделяет столько, сколько может. При отправлении каждого сегмента отправитель должен уменьшать число буферов на единицу, а когда оно достигнет нуля, он должен остановиться. Получатель отправляет обратно на попутных сегментах отдельно подтверждения и сведения об имеющихся у него свободных буферах. Эта схема используется в TCP; при этом информация о буферах хранится в поле заголовка Window size (Размер окна).
Пример управления динамическим окном в дейтаграммной сети с 4-битными порядковыми номерами.
![[Pasted image 20250101173457.png]]


##### Подвод итогов

**Таким образом, раздвижное окно позволяет одновременно реализовать и управление потоком, и контроль перегрузки**. Если сеть может обработать c сегментов в секунду, а время цикла (включая передачу, распространение, ожидание в очередях, обработку получателем и возврат подтверждения) равно r, тогда размер окна отправителя должен быть равен cr. При таком окне отправитель максимально использует канал. Любое снижение производительности сети приведет к его блокировке. Так как пропускная способность меняется с течением времени, размер окна должен настраиваться довольно часто, чтобы отслеживать изменения пропускной способности. **В TCP используется похожая схема**.


## Мультиплексирование

Мультиплексирование (multiplexing), или объединение нескольких сеансов связи в одном соединении, виртуальном канале и одной физической линии.

На транспортном уровне такая потребность возникает в нескольких случаях. Например, если у хоста имеется только один сетевой адрес, он используется всеми соединениями транспортного уровня. Необходим способ, с помощью которого можно различать, какому процессу нужно передать входящий сегмент. 
![[Pasted image 20250101173934.png]]

Если пользователю требуется больше пропускной способности или более высокая надежность, чем может предоставить один сетевой путь, можно создать соединение, распределяющее трафик между путями, используя их поочередно. Такой метод называется **обратным мультиплексированием** (inverse multiplexing).

Примером обратного мультиплексирования является **протокол SCTP**, позволяющий устанавливать соединение с множественными сетевыми интерфейсами. **TCP, наоборот, использует отдельный сокет.** Обратное мультиплексирование применяется и на канальном уровне; при этом несколько ­медленных каналов связи объединяются в один, работающий гораздо быстрее.

## Восстановление после сбоев

Если хосты и маршрутизаторы подвержены сбоям или соединения длятся достаточно долго (например, при загрузке мультимедиа или программного обеспечения), вопрос восстановления после сбоев особенно актуален.

Транспортные подсистемы постоянно ожидают потери сегментов и знают, как с этим бороться: для этого выполняются повторные передачи. Более серьезную проблему представляет восстановление после сбоя хоста.

##### Варианты решение после сбоев

1. **Протоколы подтверждения**
	Описание: Использование протоколов, которые требуют подтверждения получения данных от получателя.
	
	- Метод: 
		• Сервер отправляет подтверждение (ACK) каждому полученному сегменту.
		• Клиент повторно отправляет последний неподтвержденный сегмент в случае отсутствия ACK.
	
	- Преимущества:
		• Обеспечивает надежность передачи.
		• Позволяет клиенту знать, когда следует повторить отправку.

	- Недостатки:
		• Может привести к дублированию данных, если сервер перезагрузится после отправки ACK, но до записи данных.

2. **Широковещательное уведомление о сбое**
	Описание: При перезагрузке сервер рассылает широковещательное сообщение всем клиентам о своем состоянии.

	- Метод: 
		• Сервер отправляет сообщение о перезагрузке и запрашивает статус открытых соединений.
		• Клиенты отвечают, сообщая о наличии неподтвержденных сегментов.

	- Преимущества:
		• Позволяет серверу восстановить состояние соединений после сбоя.
		• Упрощает процесс восстановления для клиентов.

	- Недостатки:
		• Нагрузка на сеть из-за широковещательных сообщений.
		• Возможные задержки в восстановлении соединений.

3. **Использование временных меток или идентификаторов сессий**
	Описание: Каждое сообщение или сегмент включает уникальный идентификатор или временную метку.

	- Метод:
		• Сервер и клиент используют идентификаторы для отслеживания состояния передачи данных.
		• При восстановлении сервер может запросить повторную передачу только тех сегментов, которые не были успешно получены.
	
	- Преимущества:
		• Минимизирует вероятность дублирования данных.
		• Позволяет точно отслеживать состояние передачи.
	
	- Недостатки:
		• Увеличение объема передаваемых данных из-за дополнительных заголовков.
		• Сложность реализации логики обработки идентификаторов.

4. **Протоколы с резервированием состояния**
	Описание: Сервер сохраняет состояние соединений в постоянной памяти или в удаленном хранилище.

	- Метод:
		• Перед сбоями сервер сохраняет текущее состояние всех активных соединений.
		• После перезагрузки сервер восстанавливает состояние из сохраненного хранилища.
	
	- Преимущества:
		• Позволяет избежать потери данных и состояния соединений.
		• Обеспечивает быстрое восстановление после сбоя.
	
	- Недостатки:
		• Необходимость в дополнительном оборудовании или программном обеспечении для хранения состояния.
		• Увеличение времени на восстановление из-за необходимости чтения состояния из хранилища.

5. **Использование протоколов с контролем последовательности**
	Описание: Протоколы, которые отслеживают порядок и целостность передаваемых сегментов.

- Метод:
	• Каждый сегмент имеет порядковый номер, что позволяет клиенту и серверу отслеживать, какие сегменты были получены и какие нужно повторно отправить.
  
- Преимущества:
	• Упрощает управление потерей и дублированием сегментов.
	• Обеспечивает надежность передачи данных.

- Недостатки:
	• Усложнение реализации протокола.
	• Потенциальные задержки при обработке последовательности.

**Заключение**

Выбор метода восстановления после сбоев зависит от специфики приложения, требований к надежности и производительности, а также архитектуры системы. Комбинирование нескольких методов может обеспечить более надежное решение для обработки сбоев в сетевых соединениях.
