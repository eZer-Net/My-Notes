
Протокол без установления соединения, UDP, просто передает пакеты между приложениями, позволяя им надстраивать свои собственные протоколы.

## Основы UDP

**Протокол передачи пользовательских дейтаграмм (User Datagram Protocol, UDP)**
Это транспортный протокол без установления соединения, описанный в RFC 768.

В сущности, весь смысл применения UDP вместо обычного IP заключается как раз в указании портов отправителя и получателя. на транспортном уровне невозможно было бы определить, что делать с входящим пакетом. В соответствии с полями портов вложенные сегменты доставляются соответствующим приложениям.
#### Заголовок протокола udp:
![[Pasted image 20250103140053.png]]

- Source port (Порт отправителя)

- Destination port (Порт получателя)

- Поле UDP length состоит из заголовка и данных. 
	Минимальная длина равна длине заголовка, то есть 8 байт. Максимальная длина составляет 65 515 байт — меньше, чем максимальное число, которое может поместиться в 16 бит, из-за ограничений на размер IP-пакета.

- Необязательное поле Checksum служит для повышения надежности. 
	Оно содержит контрольную сумму заголовка, данных и псевдозаголовка.

#### Чего UDP не делает

- Управлением потоком данных
- Контролем перегрузки
- Повторной передачей после приема испорченного сегмента

Все это перекладывается на пользовательские процессы
#### Что делает UDP

Предоставляет интерфейс для IP путем демультиплексирования нескольких процессов с использованием портов и необязательного сквозного обнаружения ошибок. На этом все.

Демультиплексирование — это процесс, который позволяет разделять и направлять данные, поступающие по одному каналу.

#### Для каких целей используется UDP

Для процессов, которые должны управлять потоком, контролировать ошибки
и временные интервалы, протокол UDP.

Особенно это полезно в клиент-серверных ситуациях. Зачастую **клиент отправляет короткий запрос серверу и надеется получить короткий ответ. Если запрос или ответ теряется, клиент по прошествии определенного временного интервала может попытаться еще раз.** Это позволяет не только упростить код, но и уменьшить требуемое количество сообщений по сравнению с протоколами, которым требуется начальная настройка (например, TCP).

**Служба имен доменов (Domain Name System, DNS) — это приложение, которое использует UDP именно так, как описано выше**. В двух словах, если программе нужно найти IP-адрес по имени хоста, например www.cs.berkeley.edu, она может отослать UDP-пакет с этим именем на сервер DNS. Сервер в ответ на запрос отправляет UDP-пакет с IP-адресом хоста. Не требуется никакой предварительной настройки, как и разрыва соединения после завершения задачи. По сети просто передаются два сообщения.

## Вызов удаленной процедуры

**Удалённый вызов процедур (Remote Procedure Call, RPC)** — это метод, который позволяет программам вызывать функции (или процедуры), находящиеся на удалённых компьютерах, так же, как если бы они вызывались локально. Это делает разработку сетевых приложений более интуитивной и удобной.

#### Как это работает?

1. Параметры и результаты: Как в обычных функциях, когда вы вызываете удалённую процедуру, вы передаёте параметры и получаете результат. Например, если у вас есть функция get_IP_address(host_name), она отправляет запрос на сервер DNS и ожидает ответ.

2. Скрытие сложности: Все сложности, связанные с сетевыми взаимодействиями (например, отправка пакетов, ожидание ответа и обработка тайм-аутов), скрыты от программиста. Вам не нужно беспокоиться о том, как именно происходит передача данных по сети.

3. Клиент и сервер: В контексте RPC:

   • Клиент — это программа, которая вызывает удалённую процедуру.

   • Сервер — это программа, которая выполняет запрашиваемую процедуру.

4. Заглушки: Для реализации RPC используются специальные "заглушки":

   • Клиентская заглушка (client stub): это небольшая библиотечная процедура на стороне клиента, которая имитирует вызов удалённой процедуры. Она принимает параметры и отправляет их на сервер.

   • Серверная заглушка (server stub): это процедура на стороне сервера, которая принимает запросы от клиента и вызывает соответствующую процедуру на сервере.

#### Проблемы и ограничения RPC

Несмотря на удобство использования RPC, у него есть свои недостатки:

1. Проблемы с указателями: В обычных локальных вызовах процедур указатели могут передаваться без проблем, так как обе процедуры находятся в одном адресном пространстве. Однако в случае RPC клиент и сервер могут находиться на разных машинах с разными адресными пространствами. Это означает, что передать указатель на объект из одного адресного пространства в другое невозможно, так как адреса не совпадают.

2. Сложности с сериализацией: Когда данные передаются по сети, они должны быть преобразованы в формат, который можно отправить (сериализация) и затем восстановлен на другой стороне (десериализация). Это может привести к дополнительным сложностям и ошибкам.

3. Задержки и тайм-ауты: Вызовы удалённых процедур могут занимать больше времени из-за задержек в сети. Это требует обработки тайм-аутов и повторных запросов.

## Транспортные протоколы реального времени

**Клиент-серверный удаленный вызов процедур — это та область, в которой UDP применяется очень широко.** Еще одной такой сферой являются мультимедийные приложения реального времени. 

С распространением интернет-радио, интернет-телефонии, видеоконференций, музыки и видео по запросу, а также других мультимедийных приложений стало понятно, что все они воссоздают примерно один и тот же транспортный протокол реального времени. Вскоре родилась идея о том, что было бы удобно иметь для них один общий транспортный протокол. Так возник ==транспортный протокол реального времени (Real-Time Transport Protocol, RTP)==. Он описан в RFC 3550 и сегодня широко используется в мультимедиа. 

RTP обычно работает поверх UDP (в операционной системе).
#### Два компонента транспортировки данных в реальном времени

- Первый протокол RTP, необходимый для пакетной передачи аудио и видео.

- Второй для обработка данных, необходимая для воспроизведения (в основном со стороны получателя)

Эти функции входят в стек протоколов:
![[Pasted image 20250103144933.png]]

#### Работа RTP поверх UDP

Происходит это так. Мультимедийное приложение может состоять из нескольких аудио-, видео-, текстовых и некоторых других потоков. Они прописываются в библиотеке RTP, которая (как и само приложение) находится в пользовательской области. Библиотека мультиплексирует потоки и вставляет их в пакеты RTP, которые, в свою очередь, отправляются в сокет. На другом конце сокета (в операционной системе) генерируются UDP-пакеты, в которые помещаются RTP-пакеты. Они передаются протоколу IP для отправки по каналу (например, Ethernet). На хосте-получателе происходит обратный процесс. В конечном итоге мультимедийное приложение получает данные из RTP-библиотеки. Оно отвечает за воспроизведение.

#### Дилемма к какому уровню отнести RTP

Определить, к какому уровню относится RTP, непросто. Так как **он работает в пользовательской области и связан с прикладной программой, он, несомненно, выглядит как прикладной протокол. С другой стороны, он является общим, независимым от приложения протоколом, который просто предоставляет транспортные услуги.** С этой точки зрения он может показаться транспортным протоколом. Наверное, лучше всего дать ему следующее определение: **RTP — это транспортный протокол, который случайно оказался на прикладном уровне**, и именно поэтому мы говорим о нем в этой главе.


#### RTP — транспортный протокол реального масштаба времени

Базовая функция RTP — мультиплексирование нескольких потоков реального времени в единый поток пакетов UDP. Поток UDP можно направлять либо по одному, либо сразу по нескольким адресам. 

**Формат RTP обладает рядом особенностей, которые помогают получателям обрабатывать мультимедийные данные.** Каждый пакет потока RTP имеет номер, на единицу превышающий номер своего предшественника. Такой способ нумерации позволяет получателю выявить потерю пакетов. При исчезновении пакета выбор оптимального для получателя решения остается за приложением. Если пакеты содержат видеоданные, возможен пропуск потерянных фреймов. В случае аудиоданных можно аппроксимировать пропущенное значение путем интерполяции. Повторная передача в данном случае не подходит, поскольку она займет много времени и заново переданный пакет окажется уже никому не нужным. Поэтому **в протоколе RTP не предусмотрено никаких подтверждений и механизмов запроса повторной передачи.**

**Каждое поле RTP Payload может содержать множество сэмплов, которые кодируются так, как этого хочет приложение**. Межсетевое взаимодействие в RTPобеспечивается за счет определения нескольких профилей (например, отдельных аудиопотоков), каждому из которых может соответствовать несколько форматов кодирования. Например, аудиопоток может кодироваться при помощи PCM (8-битными символами с полосой 8 кГц), дельта-кодирования, кодирования с предсказанием, GSM-кодирования, MP3-кодирования и т. д. **В RTP имеется специальное поле заголовка, в котором источник может указать метод кодирования,** но затем источник никак не влияет на этот процесс.

Ещё одна функция временные метки позволяют связывать время с первым элементом каждого пакета, что важно для синхронизации потоков и уменьшения эффекта колебания сетевой задержки. Это позволяет буферизовать данные и воспроизводить их с правильным интервалом, обеспечивая синхронизацию, например, видеопотока с несколькими аудиопотоками в цифровом телевидении, даже при наличии ошибок в передаче.

#### Заголовок RTP
![[Pasted image 20250103150424.png]]


- **Поле Version** - указывает на версию протокола (имеет значение 2 по умолчанию)

- **Бит P** - указывает на то, что размер пакета кратен 4 байтам за счет байтов заполнения.

- **Бит Х** - сообщает, что присутствует заголовок расширения.

- **Поле СС** - сообщает, сколько сотрудничающих источников формируют поток. Их число может колебаться от 0 до 15 

- **Бит М** — это маркер, связанный с конкретным приложением. Он может использоваться для обозначения начала видеофрейма, начала слова в аудиоканале или еще для чего-то важного и понятного для приложения. 

- **Поле Payload type (Тип данных)** - содержит информацию об использующемся алгоритме кодирования (например, несжатое 8-битное аудио, MP3 и т. д.). 

- **Sequence number (Порядковый номер)** — это счетчик, который увеличивается на единицу в каждом пакете RTP. Он используется для выявления потерянных пакетов.

- **Timestamp (Временная метка)** - генерируется источником потока и служит для записи момента создания первого слова пакета. **Метка времени помогает снизить эффект временных колебаний, или джиттер (jitter), на стороне получателя**. Это происходит за счет того, что момент воспроизведения не зависит от времени прибытия пакета.

- **Synchronization source identifier (Идентификатор источника синхронизации)** - позволяет определить, какому потоку принадлежит пакет. Это и есть используемый метод мультиплексирования и демультиплексирования нескольких потоков данных, следующих в виде единого потока UDP-пакетов.

- **Contributing source identifiers (Идентификаторы сотрудничающих источников)** - если таковые имеются, используются, когда конечный поток формируется несколькими источниками.


#### RTCP — управляющий транспортный протокол реального времени

У протокола RTP есть родственный протокол под названием **управляющий транспортный протокол реального времени (Real-Time Transport Control Protocol, RTCP)**. Он описан в RFC 3550 вместе с RTP. **В его задачи входит поддержка обратной связи, синхронизация, обеспечение пользовательского интерфейса**, однако передачей медиаданных он не занимается.


#### Буферизация и контроль джиттера при воспроизведении

Когда информация приходит к получателю, необходимо начать ее воспроизведение в правильный момент времени. Обычно этот момент не совпадает со временем прибытия RTP-пакета, поскольку время прохождения через сеть для разных пакетов немного различается.

**Если медиаданные будут проигрываться сразу же по прибытии, даже небольшой джиттер может вызвать серьезные помехи:** изображение может быть прерывистым, а звук — неразборчивым. **Решение заключается в буферизации пакетов на стороне получателя перед их воспроизведением** для снижения джиттера.

Как правило, равные промежутки времени использовать не обязательно, так как метки времени RTP содержат информацию о том, когда следует начать воспроизведение.

Если пакет задерживается настолько, что не успевает прибыть к тому моменту, когда он должен быть воспроизведен. В таком случае возможны два варианта.

- Проигрыватель может пропустить 8-й пакет и перейти к следующим пакетам

- Или же он может остановить воспроизведение, пока не придет 8-й пакет, и тем самым создать неприятную паузу в музыке или фильме.


Для равномерного воспроизведения очень важна задержка воспроизведения (playback point). Это время, в течение которого получатель ожидает медиаданные, прежде чем начать воспроизведение. Этот параметр зависит от джиттера.

Чтобы правильно подобрать задержку воспроизведения, приложение может измерить джиттер, вычислив разницу между значениями меток времени RTP и временем прибытия.

Одно из возможных решений для аудио состоит в том, чтобы корректировать задержку воспроизведения между сегментами речи (talkspurts), то есть во время пауз. Разница между короткой паузой и чуть более длинной вряд ли будет заметна. Чтобы это было возможным, RTP позволяет приложениям отмечать начало нового сегмента речи с помощью маркера M.