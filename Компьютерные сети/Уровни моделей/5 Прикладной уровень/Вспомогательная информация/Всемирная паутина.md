## Немного истории

**Всемирная паутина WWW (World Wide Web), или просто «веб»,** — это архитектура, которая является основой для доступа к соединенному ссылками контенту на миллионах компьютеров по всему интернету.

Всемирная паутина была создана в 1989 году в Европейской организации по ядерным исследованиям ЦЕРН (Conseil Européen pour la Recherche Nucléaire, CERN) в Швейцарии. 

Первый графического браузера — Mosaic. Программа увидела свет в феврале 1993 года.

В 1994 году ЦЕРН и Массачусетский технологический институт (Massachusetts Institute of Technologies, MIT) подписали соглашение об основании Консорциума Всемирной паутины (World Wide Web Consortium, W3C). Цель этой организации — дальнейшее развитие Всемирной паутины, стандартизация протоколов и поощрение взаимодействия между отдельными сайтами.

## Представление об архитектуре

Всемирная паутина состоит из огромного количества контента в виде **веб-страниц (Web pages)**. На каждой странице обычно есть ссылки на сотни других объектов, которые могут размещаться на веб-сервере в любой точке мира. 

Веб-страница также может содержать **ссылки (links)** на другие страницы, на которые можно перейти, кликнув по такой ссылке.

Идея использования страниц, направляющих друг на друга, — так называемого ==гипертекста (hypertext)== — была впервые предложена в 1945 году Ванневаром Бушем (Vannevar Bush), профессором электротехники Массачусетского технологического института. 

Для просмотра страниц обычно используется специальная программа, называемая **браузером (browser)**. 

==[[Всемирная паутина#Сторона клиента|Браузер]]== предоставляет пользователю запрашиваемую страницу, интерпретирует ее контент и выводит должным образом отформатированные страницы на экран. Контент может представлять собой сочетание текста, изображений и команд форматирования и выглядеть как обычный документ, видео или программа с графическим интерфейсом.

Строки текста, иконки, изображения и прочие элементы, представляющие собой ссылки на другие страницы, называются гиперссылками (hyperlinks).

Браузер отображает веб-страницу на клиентском компьютере, отсылая запрос на один или несколько серверов, которые отвечают, передавая контент страницы. Запросно-ответный протокол для отображения страниц представляет собой простейший текстовый протокол, работающий поверх TCP, — HTTP. Его защищенная версия HTTPS является основным способом доставки контента в современном интернете.

Страница называется **[[Всемирная паутина#Статичные веб-объекты|статичной]] (static page)**, если это документ, который всегда отображается одинаково. Если же она создается по требованию программы или сама содержит какую-либо программу, то это **[[Всемирная паутина#Динамические веб-страницы и веб-приложения|динамическая страница]] (dynamic page)**.

Для лучшего контента на сайта используются файлы cookie

#### Сторона клиента

Браузер — это программа, которая отображает веб-страницу и реагирует на пользовательские запросы «перехода» к ее элементам. При выборе элемента браузер переходит по гиперссылке и извлекает объект, на который указал пользователь.

Три самых важных вопроса, на которые нужно ответить, прежде чем отобразить выбранную страницу:
1. Как называется страница?
2. Где она расположена?
3. Как получить доступ к ней?

Каждой странице приписывается унифицированный указатель ресурса ==(Uniform Resource Locator, URL)==. URL-адрес содержит три элемента: 
- Протокол (который также называют схемой — scheme)
- DNS-имя устройства, на котором расположена страница
- Уникальный для каждой страницы путь (файл для чтения или программу для запуска на компьютере).

Последовательность действий при активации ссылки:

1. Браузер определяет URL-адрес (исходя из того, какой элемент страницы выбрал пользователь).

2. Браузер запрашивает у службы DNS IP-адрес сервера fcc.gov.

3. DNS выдает в качестве ответа адрес 23.1.55.196.

4. Браузер устанавливает TCP-соединение с этим IP-адресом; поскольку при этом применяется HTTPS, защищенная версия HTTP, TCP-соединение по умолчанию устанавливается с портом 443 (а не со стандартным портом 80 протокола HTTP, который сегодня используется все реже).

5. Браузер отправляет HTTPS-запрос на получение страницы //, которую веб-сервер обычно интерпретирует как некую индексную страницу (например, index.html , index.php и т. п., как указано в конфигурации [[Веб-сервера|веб-сервера]] хоста).

6. Сервер отправляет страницу как HTTPS-ответ, например, в виде файла /index.html, если таковой определен как индексный объект по умолчанию.

7. Если страница содержит URL-адреса, которые нужно отобразить, то браузер получает их таким же способом. В нашем случае эти URL-адреса содержат ряд встроенных изображений, также загружаемых с данного сервера, встроенные объекты с сайта gstatic.com и скрипт с сайта google-analytics.com (а также с ряда других доменов, которые здесь не показаны).

8. Браузер отображает страницу /index.html.

9. Если в течение некоторого времени на те же серверы не поступает других
запросов, TCP-соединения обрываются.

Получить более детальное представление о выполнении веб-страницы можно с помощью так называемой [[Встроенный инструмент браузера#Каскадная диаграмма (waterfall diagram)|каскадной диаграммы (waterfall diagram)]]

Получить доступ к локальному файлу как к веб-странице можно, используя протокол file (file:///home/) или просто написав его имя. Для применения этого способа не нужен сервер. Конечно, это работает только для локальных файлов, но не для удаленных.

Протокол mailto не загружает веб-страницы, но зато позволяет отправлять почту через браузер. Когда пользователь переходит по ссылке mailto, большинство браузеров запускает пользовательского агента, предоставляющего форму для написания электронного письма с уже заполненным полем адреса.

![[Pasted image 20250108160116.png]]

Таким образом, URL-адреса можно применять не только для навигации по просторам Всемирной паутины, но и для использования старых протоколов (например, FTP и электронной почты), новых протоколов (для аудио- и видеоданных), а также для обеспечения удобного доступа к локальным файлам и информации браузера.

#### Сторона сервера

Когда пользователь вводит URL-адрес или кликает по гиперссылке, браузер производит синтаксический разбор URL-адреса и интерпретирует часть, заключенную между https:// и следующей косой чертой, как искомое DNS-имя. Получив IP-адрес сервера, браузер устанавливает TCP-соединение с его портом 443. Затем отсылается команда, содержащая оставшуюся часть URL-адреса (путь к странице на данном сервере). Сервер возвращает браузеру ту страницу, которую он должен отобразить.

Если не вдаваться в детали, простой [[Веб-сервера|веб-сервер]] работает примерно так.
1. Принимает входящее TCP-соединение от клиента (браузера).
2. Получает путь к странице, являющийся именем запрашиваемого файла.
3. Получает файл (с диска).
4. Высылает содержимое файла клиенту.
5. Разрывает TCP-соединение.

Современные веб-серверы обладают более широкими возможностями, однако в основе их работы лежат именно перечисленные шаги, которые предпринимаются в случае запроса контента из файла. **Если контент динамический, третий шаг может быть заменен выполнением программы (указанной в пути), которая генерирует и возвращает определенный контент.**


Если нужно обрабатывать сотни и даже тысячи запросов в секунду, веб-серверы работают иначе. Одна из **проблем простой реализации состоит в том, что**
**доступ к файлам часто становится узким местом производительности**.
	Чтение с диска идет слишком медленно по сравнению с работой программы, и одни и те же файлы могут считываться несколько раз из-за вызовов операционной системы.
Другая проблема заключается в том, что **за раз может быть обработан только один запрос**. При запросе большого файла обработка других запросов будет блокироваться до окончания его передачи.

**Решение этой проблемы состоит в том, чтобы кэшировать в памяти n последних запрошенных файлов или определенное количество гигабайтов контента.** Прежде чем обратиться за файлом к диску, сервер проверяет содержимое кэша. 

==Параллельную обработку запросов также можно осуществить с помощью многопоточных (multithreaded) серверов.== В одной из реализаций такого подхода сервер состоит из интерфейсного модуля, принимающего все входящие запросы, и k обрабатывающих модулей
![[Pasted image 20250108161047.png]]


Преимущество такого подхода заключается в том, что пока один или несколько обрабатывающих модулей заблокированы в ожидании окончания дисковой или сетевой операции (при этом они не потребляют мощности центрального процессора), другие модули могут активно обрабатывать другие запросы. Имея k обрабатывающих модулей, производительность можно повысить в k раз по сравнению с однопоточным сервером. 
	Конечно, **если ограничивающим фактором являются диск или сеть, то необходимо наличие нескольких дисков или более быстрой сети**, чтобы действительно улучшить однопоточную модель.

Все современные веб-архитектуры построены по представленной выше схеме, с разделением на интерфейсную («фронтенд») и серверную («бэ-кенд») части. **Интерфейсный веб-сервер часто называют обратным прокси-сервером (reverse proxy)**, поскольку он как посредник («прокси») извлекает содержимое из других серверов (обычно относящихся к серверной части) и доставляет эти объекты клиенту. Слово «обратный» указывает на то, что он действует от имени сервера, а не клиента.

## Статичные веб-объекты

Самом простом случае веб-объекты статические. Сегодня практически любая веб-страница имеет динамический контент, но в то же время даже на динамических страницах значительная часть содержимого (например, логотип, таблицы стилей, верхний и нижний колонтитулы) по-прежнему носит статичный характер. 

==Статичные объекты== — **это размещенные на каком-либо сервере файлы, которые при каждом просмотре отображаются одинаково.** Обычно их можно кэшировать, и даже на длительное время, поэтому они часто размещаются в ближайшем к пользователю объектном кэше.

==Язык HTML (HyperText Markup Language — язык разметки гипертекста)==
Это язык разметки, то есть язык для описания способа форматирования документов. 
	Термин разметка (markup) восходит к тем дням, когда редактор с помощью специальной разметки указывал типографу, какой шрифт использовать для печати. Таким образом, языки разметки позволяют четко задавать команды форматирования.

Например, в HTML тег `<b> означает начало участка текста, выделенного полужирным шрифтом, а </b>` указывает на конец такого участка. В свою очередь, тег `<h1>` указывает начало заголовка уровня 1.

 В современных веб-страниц для определения гарнитуры, цвета, размера, отступов и многих других атрибутов текста, списков, таблиц, заголовков. Пишутся на языке ==CSS (Cascading Style Sheets — каскадные таблицы стилей)==.

Также существует множество программ для создания веб-страниц, например Adobe Dreamweaver.

## Динамические веб-страницы и веб-приложения

Приложения запускаются в браузере, а пользовательские данные хранятся на серверах в центрах обработки данных, подключенных к интернету.

Преимущество состоит в том, что пользователю не нужно устанавливать отдельные приложения и он может получить доступ к своим данным с разных компьютеров, причем данные сохраняются у оператора сервиса.

**По такой модели строится большая часть облачных вычислений (cloud computing)**, переводящих процесс вычисления с пользовательских компьютеров на совместно используемые кластеры серверов в интернете.

**Чтобы выступать в роли приложения, веб-страницы содержат динамический контент.**
Динамический контент может генерироваться программами, запущенными на сервере или в браузере (или на обоих хостах).

#### Динамическая генерация веб-страниц на стороне сервера

**Определение на примере** 
При взаимодействии пользователя с веб-формой (например, при покупке товара) отправляется запрос на сервер по указанному URL-адресу с введенной информацией. 

Процесс:
1. Запрос: URL идентифицирует программу для обработки, а данные передаются ей.
2. Обработка: Результат обработки запроса зависит от логики программы, а не фиксирован.
    - Например, после успешного заказа может быть возвращена страница с датой доставки.
    - В случае проблем (например, отсутствия товара или недействительной кредитной карты) возвращается соответствующее сообщение.
3. Сервер: Как именно сервер обрабатывает запрос, зависит от его конфигурации и не регламентируется веб-протоколами.

Браузер: Браузер просто отправляет запрос и получает ответ без необходимости знать внутренние детали обработки.

Для веб-серверов были разработаны стандартные [[Анализ API|API]], чтобы за-пускать программы. Существование этих интерфейсов позволяет разработчикам тратить меньше усилий на расширение различных серверов за счет веб-приложений. 

Первый API представляет собой метод обработки запросов динамических страниц, который был доступен с момента возникновения интернета. Он называется общим шлюзовым интерфейсом **(Common Gateway Interface, CGI)** и описан в RFC 3875.

==CGI== предоставляет интерфейс, позволяющий веб-серверам общаться с серверными программами и скриптами, способными принимать некоторые входные данные (например, из формы) и в ответ генерировать HTML-страницы.
	Существует договоренность, в соответствии с которой программы, запускаемые через CGI, должны размещаться в каталоге cgi-bin, который включается в URL-адрес. 

==Другой API предполагает совершенно иной подход.== В данном случае в HTML-страницу встраиваются небольшие скрипты, которые выполняются сервером для генерирования страницы. Популярным инструментом для написания таких скриптов является язык PHP (PHP: Hypertext Preprocessor — PHP: препроцессор гипертекста).

веб-страницы с PHP-кодом имеют расширение php, а не htm или html, что позволяет легко их идентифицировать. **В использовании PHP проще, чем CGI, и распространен повсеместно.**

#### Создание динамических веб-страниц на стороне клиента

Скрипты CGI и PHP решают вопросы обработки входных данных и взаимодействия с базами данных на сервере. Они могут принимать входящую информацию из форм, осуществлять поиск по одной или нескольким базам данных и в качестве результата генерировать HTML-страницы.

Но ни один из этих методов не позволяет напрямую взаимодействовать с пользователем, например реагировать на движения мыши. Для этих целей необходимы скрипты, внедренные в HTML- страницы и выполняющиеся не на серверном, а на клиентском устройстве. Начиная с HTML 4.0, появилась возможность включать скрипты такого типа с помощью тега `<script>`. ==Текущий стандарт HTML сегодня принято называть HTML5.==

HTML5 содержит множество новых возможностей синтаксиса для встраивания мультимедийного и графического контента, включая теги `<video>, <audio> и <canvas>.` 
	Элемент `<canvas>`, в частности, облегчает динамическое отображение двумерных форм и растровых изображений. Как ни странно, данный элемент вызывает большое беспокойство относительно конфиденциальности, поскольку свойства тега HTML `<canvas>` зачастую уникальны для разных устройств. Это позволяет операторам веб-сайтов следить за пользователями, даже если те избавятся от всех отслеживающих файлов cookie и скриптов.
Наиболее популярным языком для написания клиентских скриптов является
[[JavaScript|JavaScript]].

**Хотя языки PHP и JavaScript схожи в том, что они встраивают код в HTML- файлы, важно понимать, что обработка кода при этом выполняется совершенно по-разному.** 

- При использовании PHP после щелчка по кнопке подтверждения браузер собирает всю введенную информацию в одну длинную строку и отправляет ее на сервер как запрос PHP-страницы. Сервер загружает PHP-файл и выполняет встроенный в него PHP-скрипт, получая на выходе новую HTML-страницу, которая возвращается браузеру для отображения. 

- В случае JavaScript после нажатия кнопки подтверждения браузер сам интерпретирует содержащийся на странице JavaScript-код. Вся работа производится локально, внутри браузера, без какого-либо взаимодействия с сервером.
![[Pasted image 20250108164947.png]]

Эти отличия вовсе не означают, что JavaScript лучше, чем PHP. Просто у них совершенно разное назначение. PHP применяется для взаимодействия с серверной базой данных, а JavaScript (и другие языки для клиентской стороны) — для взаимодействия с пользователем на клиентском компьютере. Разумеется, как мы вскоре убедимся, PHP и JavaScript можно использовать одновременно.


## HTTP и HTTPS

==Протокол передачи гипертекста (HyperText Transfer Protocol, HTTP)==, описан в спецификации RFC 2616.

**Защищенным протоколом передачи гипертекста (Secure HyperText Transfer Protocol, HTTPS)**. В сущности, оба протокола извлекают веб-объекты одинаково, и HTTP-стандарт для извлечения объектов развивается практически независимо от своей защищенной версии. HTTPS фактически использует HTTP поверх защищенного транспортного протокола защиты транспортного уровня [[Веб-безопасность#SSL/TLS|(Transport Layer Security, TLS)]]. 

#### Общие сведения

**HTTP — простой запросно-ответный протокол. Его старые версии обычно запускаются поверх TCP, однако его самая последняя версия, HTTP/3, также нередко работает поверх UDP.** Протокол HTTP определяет, какие сообщения клиент может отправлять серверу и что может быть возвращено в качестве ответа.

Заголовки запросов и ответов, так же как в SMTP, даны в ASCII. Их содержимое имеет формат, похожий на MIME (опять же, как и в SMTP). 
	Эта модель была одной из причин успеха Всемирной паутины на раннем этапе, так как сильно упрощала процесс разработки и развертывания.

HTTP — это протокол прикладного уровня, так как он работает поверх TCP и тесно связан с интернетом. Но с другой стороны, HTTP все больше напоминает транспортный протокол, позволяющий процессам передавать контент из одной сети в другую. В качестве этих процессов могут выступать не только веб-браузер и веб-сервер.
- Медиаплеер может использовать HTTP для того, чтобы запросить у сервера информацию об альбоме. 
- Антивирус — для загрузки последних обновлений вирусной базы. 
- Разработчики — для получения файлов, относящихся к проекту, над которым они работают.

#### Методы

HTTP был разработан специально для веб-технологий, но его намеренно сделали более универсальным, чем это было необходимо, в расчете на будущее применение в объектно-ориентированных приложениях. По этой причине ==HTTP позволяет запрашивать не только веб-страницы, но и операции, называемые методами.==

Каждый запрос состоит из одной или нескольких строк ASCII-текста, где начальное слово в первой строке является именем вызываемого метода. Встроенные методы:
![[Pasted image 20250108171820.png]]
Имена методов чувствительны к регистру символов, то есть метод GET существует, а метод get — нет.

1. **GET:**

   • Описание: Используется для запроса информации с сервера. Обычно возвращает страницу или объект (например, изображение или файл).

   • Применение: Наиболее распространенный метод для получения данных. Например, когда вы вводите URL в браузере, он отправляет GET-запрос.

2. **HEAD:**

   • Описание: Запрашивает только заголовок ответа от сервера, не загружая саму страницу.

   • Применение: Полезен для проверки доступности URL или получения метаданных о ресурсе (например, размер файла или дату последнего изменения).

3. **POST:**

   • Описание: Используется для отправки данных на сервер, например, при заполнении и отправке формы.

   • Применение: Сервер обрабатывает полученные данные (например, добавляет информацию в базу данных) и возвращает ответ. Например, при покупке товара.

4. **PUT:**

   • Описание: Используется для обновления существующего ресурса или создания нового, если он не существует.

   • Применение: Например, если вы редактируете профиль пользователя на сайте, то PUT-запрос может обновить информацию в базе данных.

5. **DELETE:**

   • Описание: Используется для удаления указанного ресурса на сервере.

   • Применение: Например, если вы хотите удалить свой аккаунт или удалить товар из корзины, отправляется DELETE-запрос.

6. **TRACE:**

   • Описание: Позволяет клиенту получить диагностическую информацию о пути запроса к серверу.

   • Применение: Полезен для отладки и диагностики проблем с сетевыми соединениями.

7. **CONNECT:**

   • Описание: Используется для установки туннеля к серверу через прокси-сервер.

   • Применение: Чаще всего применяется в HTTPS-соединениях для обеспечения безопасной передачи данных.

8. **OPTIONS:**

   • Описание: Позволяет клиенту узнать, какие методы HTTP поддерживаются сервером для конкретного ресурса. В ответ на каждый запрос включается строка состояния, часто вместе с дополнительной информацией (например, веб-страница целиком или ее часть). Эта строка может содержать трех разрядный код состояния, сообщающий об успешном выполнении запроса или о причинах неудачи.
	![[Pasted image 20250108154027.png]]

   • Применение: Полезен для определения возможностей взаимодействия с ресурсом, например, перед выполнением других запросов.

При этом тело запроса содержит страницу**. Она может быть **закодирована согласно стандарту MIME**. В этом случае строки, следующие за командой PUT, могут содержать заголовки аутентификации, подтверждающие, что абонент обладает правами доступа к запрашиваемой операции.**

#### Заголовки сообщений

За строкой запроса (к примеру, содержащей метод GET) могут следовать другие строки с дополнительной информацией. Они называются заголовками запросов (request headers).

В свою очередь, ответы могут содержать заголовки ответов (response headers). Некоторые заголовки встречаются и там и там.


| Заголовок         | Тип          | Содержимое                                                       |
| ----------------- | ------------ | ---------------------------------------------------------------- |
| User-Agent        | Запрос       | Информация о браузере и его платформе                            |
| Accept            | Запрос       | Тип страниц, поддерживаемых клиентом                             |
| Accept-Charset    | Запрос       | Поддерживаемые клиентом наборы символов                          |
| Accept-Encoding   | Запрос       | Поддерживаемые клиентом типы кодирования                         |
| Accept-Language   | Запрос       | Естественные языки, доступные клиенту                            |
| If-Modified-Since | Запрос       | Время и дата последнего обновления                               |
| If-None-Match     | Запрос       | Теги, отправленные с последнего обновления                       |
| Host              | Запрос       | DNS-имя сервера                                                  |
| Authorization     | Запрос       | Список персональных идентификаторов клиента                      |
| Referer           | Запрос       | URL, с которого был отправлен предыдущий запрос                  |
| Cookie            | Запрос       | Отправка ранее принятого cookie-файла на сервер                  |
| Set-Cookie        | Ответ        | Сервер хочет, чтобы клиент сохранил cookie                       |
| Server            | Ответ        | Информация о сервере                                             |
| Content-Encoding  | Ответ        | Тип кодирования содержимого (например, gzip)                     |
| Content-Language  | Ответ        | Естественный язык, используемый на странице                      |
| Content-Length    | Ответ        | Размер страницы в байтах                                         |
| Content-Type      | Ответ        | MIME-тип страницы                                                |
| Content-Range     | Ответ        | Идентифицирует часть контента страницы                           |
| Last-Modified     | Ответ        | Время и дата внесения последних изменений в страницу             |
| Expires           | Ответ        | Время и дата, когда страница перестанет считаться действительной |
| Location          | Ответ        | Команда клиенту на пересылку его запроса по другому адресу       |
| Accept-Ranges     | Ответ        | Сервер готов принимать запросы на страницы указанного размера    |
| Date              | Запрос/Ответ | Дата и время отправки сообщения                                  |
| Range             | Запрос/Ответ | Идентифицирует часть страницы                                    |
| Cache-Control     | Запрос/Ответ | Указание на то, как обрабатывать кэш                             |
| ETag              | Запрос/Ответ | Тег для контента страницы                                        |
| Upgrade           | Запрос/Ответ | Протокол, на который хочет переключиться отправитель             |


- **С помощью заголовка User-Agent** клиент может сообщить серверу версию своего браузера (например, Mozilla/5.0 или Chrome/74.0.3729.169). Эта информация позволяет серверу адаптировать свои ответы под конкретный браузер, так как логика работы и возможности разных браузеров серьезно отличаются.

- **Четыре заголовка, начинающиеся с Accept**, сообщают серверу о том, какие типы информации готов принять клиент (если их набор ограничен).
	- Первый из них указывает допустимые MIME-типы (например, text/html).
	- Заголовок Accept-Charset указывает используемый клиентом набор символов (к примеру, ISO-8859-5 или Unicode-1-1). 
	- Заголовок Accept-Encoding указывает допустимые методы сжатия (например, gzip). 
	- Заголовок Accept-Language указывает естественный язык, используемый клиентом (например, испанский).
	Если запрос удовлетворить невозможно, возвращается код ошибки, и запрос считается неудавшимся.

- **Заголовки If-Modified-Since и If-None-Match** используются при кэшировании. Они позволяют клиенту запрашивать отправку страницы только в том случае, если в кэше нет доступной копии. 

- **Заголовок Host** указывает имя сервера, содержащееся в URL-адресе. Этот заголовок обязателен, поскольку некоторые IP-адреса могут обслуживать несколько имен DNS одновременно, и серверу необходимо каким-то образом различать, кому передавать запрос.

- **Заголовок Authorization** требуется в тех случаях, когда запрашивается защищенная страница. С его помощью клиент может подтвердить свои права на ее просмотр.

- Клиент использует **заголовок Referer**, чтобы сообщить, с какого URL-адреса был выполнен переход на запрашиваемый URL-адрес. Чаще всего это URL-адрес предыдущей страницы. Этот заголовок крайне полезен для отслеживания процесса просмотра веб-страниц, поскольку позволяет серверу узнать, каким образом клиент попал на ту или иную страницу.\

- ==**Файлы cookie**== представляют собой небольшие файлы, которые размещаются серверами на клиентских устройствах с целью запоминания информации на будущее.

- **Заголовок Set-cookie** определяет то, как серверы отправляют файлы cookie клиентам. Предполагается, что клиент сохранит у себя cookie и вернет его вместе со следующим запросом на сервер при помощи заголовка Cookie. (Обратите внимание, что существует и более поздняя спецификация для файлов cookie с обновленными заголовками, RFC 2965, но она не слишком распространена.)

- **Заголовок Server** позволяет серверу указать версию или имя своего программного обеспечения.

- **Пять заголовков, начинающиеся с Content-**, позволяют серверу описать свойства отправляемой им страницы.

- **Заголовок Last-modified** содержит дату и время внесения последних изменений в отправляемую страницу
- **Заголовок Expires** сообщает, сколько времени страница будет доступна.
Оба они играют важную роль при кэшировании страницы.

- **Заголовка Location** сервер сообщает, что клиента нужно перенаправить на другой URL-адрес.

- **Заголовок Range** сообщает, какой диапазон байтов страницы предоставляется в качестве ответа.

- **Заголовок ETag** сообщает короткий тег, выполняющий роль имени контента страницы. Он применяется для кэширования.

- **Заголовок Cache-Control** выдает другие четкие указания о том, как кэшировать (а чаще — как не кэшировать) страницы.

- **Заголовок Upgrade** используется для переключения на другой протокол обмена данными, например на новую версию HTTP или на защищенный способ передачи данных. Он позволяет клиенту и серверу сообщить, что именно они поддерживают.


#### **CORS**

**Same Origin Policy (SOP)**: По умолчанию браузеры применяют политику безопасности, называемую "Политика одного источника", которая ограничивает доступ к ресурсам, если источник запроса (домен) не совпадает с источником ресурса. Это предотвращает атаки, такие как кража данных с другого сайта.

Разработчики захотели использовать [[JavaScript#AJAX-запросы|AJAX-запросы]] для взаимодействия с удалёнными ресурсами. Однако SOP не позволяет делать запросы к ресурсам на других доменах.


**• CORS** — это механизм, который позволяет браузерам делать запросы к ресурсам на других доменах, используя специальные HTTP-заголовки.

##### Простой и сложный запросы

• Простой запрос: Запросы, которые используют методы GET, POST или HEAD и содержат только определённые заголовки:

  - Accept
  - Accept-Language
  - Content-Language
  - Content-Type с одним из значений: 
    • application/x-www-form-urlencoded
    • multipart/form-data
    • text/plain

application/x-www-form-urlencoded
- Описание: Этот тип используется, когда данные формы отправляются на сервер в виде пар "ключ-значение", закодированных в URL.
- Пример: Если у вас есть форма с полями "username" и "password", данные будут выглядеть так:  `username=johndoe&password=12345`

multipart/form-data
- Описание: Этот тип используется для отправки данных, содержащих файлы (например, изображения или документы) вместе с обычными текстовыми полями.
- Пример: При загрузке файла через форму, данные могут выглядеть так:
```
  --boundary
  Content-Disposition: form-data; name="username"

  johndoe
  --boundary
  Content-Disposition: form-data; name="file"; filename="photo.jpg"
  Content-Type: image/jpeg

  [содержимое файла]
  --boundary--
```
  
- Использование: Этот формат необходим, когда нужно передать бинарные данные (например, файлы), и он часто используется в формах с атрибутом enctype="multipart/form-data".

text/plain
- Описание: Этот тип указывает, что данные передаются в виде простого текста без какого-либо специального форматирования.
- Пример: Если вы отправляете текстовое сообщение, оно может выглядеть так:
  `Hello, this is a plain text message.`
- Использование: Этот формат может использоваться для передачи простых текстовых данных, но не так часто, как предыдущие два.
  
• Сложный запрос: Запросы, которые используют другие методы (например, DELETE, PUT) или содержат заголовки, не входящие в список разрешённых.

##### Заголовки CORS

• Access-Control-Allow-Origin: Определяет, какие источники могут получить доступ к ресурсу.

  - Например: 
    Access-Control-Allow-Origin: http://example.com — разрешает доступ только с example.com.

    Access-Control-Allow-Origin: * — разрешает доступ с любого домена.

• Браузер заблокирует ответ на запрос, если:
- Сервер вернёт Access-Control-Allow-Origin: null.
- Значение не совпадает с заголовком запроса Origin.
- Заголовок отсутствует.

##### Preflight-запрос

• При обнаружении сложного запроса браузер отправляет предварительный запрос (preflight) с использованием метода OPTIONS.

• В запрос добавляются заголовки:
  - Access-Control-Request-Method: указывает метод оригинального запроса.
  - Access-Control-Request-Headers: перечисляет все заголовки оригинального запроса (если они не входят в список разрешённых).

##### Ответ сервера на preflight-запрос

Сервер должен ответить следующими заголовками:
- Access-Control-Allow-Origin: указывает разрешённые источники.
- Access-Control-Allow-Methods: указывает разрешённые методы (например, GET, POST, DELETE).
- Access-Control-Allow-Headers: указывает разрешённые заголовки (например, X-Custom-Header, Authorization).

Пример ответа сервера:
```
HTTP/1.0 200 OK
Date: Thu, 29 Jul 2021 19:20:01 GMT
Connection: close
Server: gunicorn/19.9.0
Access-Control-Allow-Origin: *
Access-Control-Allow-Methods: DELETE, GET, POST
Access-Control-Allow-Headers: X-Custom-Header, Authorization
```
Access-Control-Allow-Origin: * указывает, что ресурс может быть доступен из любого источника.

Иногда необходимо уметь передавать Cookies при обращении к другим доменам. Заголовок Cookie не относится к списку разрешенных и попадает под политику безопасности. Чтобы их можно было передавать, сервер в ответ на preflight и на оригинальный запрос должен возвращать заголовок `Access-Control-Allow-Credentials: true`. Для работы куки также нужно возвращать в заголовке `Access-Control-Allow-Origin` конкретное значение разрешённого хоста.

Ответ от кроссдоменного запроса получен. Допустим, нужно получить доступ к заголовкам в коде JavaScript в браузере и прочитать их значения. Сделать это не так просто, потому что по умолчанию доступ из Java Script для кроссдоменных запросов есть только к следующим заголовкам:
- Cache-Control
- Content-Language
- Content-Length
- Content-Type
- Expires
- Last-Modified
- Pragma

Если JS попытается прочитать значение другого заголовка, то получит null. Но сервер в ответе на запрос может перечислить заголовки, к которым можно получить доступ из Javascript в заголовке `Access-Control-Expose-Headers`. Заголовки указываются через запятую. Например, `Access-Control-Expose-Headers: Authorization, X-Version`.

Заголовок ответа сервера `Access-Control-Max-Age` сообщает браузеру, насколько предзапрос может быть кэширован и опущен при запросах к серверу. Значение указывается в секундах. Если после первого выполнения preflight-запроса время жизни `Max-Age` не вышло, то повторной отправки не будет. Оригинальный запрос выполнится сразу.

**Пример работы CORS**


1. Простой запрос: Запрос к API на другом домене для получения данных:
   
```
   fetch('https://api.example.com/data')
       .then(response => response.json())
       .then(data => console.log(data))
       .catch(error => console.error('Error:', error));
```
   

2. Сложный запрос: Отправка данных с кастомными заголовками:

```
   fetch('https://api.example.com/data', {
       method: 'POST',
       headers: {
           'Content-Type': 'application/json',
           'Authorization': 'Bearer token'
       },
       body: JSON.stringify({ key: 'value' })
   })
   .then(response => response.json())
   .then(data => console.log(data))
   .catch(error => console.error('Error:', error));
```

#### Кэширование

Часто пользователи возвращаемся на страницы, которые уже просматривали ранее, а на связанных веб-страницах нередко размещаются одни и те же ресурсов.

Сохранение полученных страниц для дальнейшего использования называется кэшированием (caching). 
- Преимущество этого метода в том, что страница, сохраненная в кэше, может быть использована снова, при этом не обязательно повторять передачу. **У HTTP есть встроенная поддержка кэширования, чтобы помочь клиентам узнать, могут ли они безопасно использовать страницы повторно.** Эта поддержка повышает производительность, сокращая и трафик, и время ожидания.
- Недостаток в том, что теперь браузер должен хранить страницы, но это почти всегда оправданно, так как локальное хранение информации не требует серьезных затрат ресурсов. Обычно страницы хранятся на диске, так что они могут быть использованы, когда браузер будет запущен в следующий раз.

**Основные стратегии кэширования можно разделить на две категории:**

1. Проверка действительности (Validation)
	Эта стратегия предполагает, что клиент (например, браузер) сначала проверяет, есть ли свежая копия ресурса в кэше. Если кэшированная версия доступна, она может быть использована без обращения к серверу.

	- Expires: Заголовок, который указывает время, до которого ресурс считается действительным. Если текущая дата меньше значения заголовка, кэшированная версия может быть использована.
	
	- Last-Modified: Заголовок, который показывает время последнего изменения ресурса на сервере. Клиент может использовать этот заголовок для определения актуальности кэшированной версии.
	
	- If-Modified-Since: Заголовок, который клиент отправляет серверу вместе с запросом. Он содержит дату последнего изменения, и сервер отвечает только в том случае, если ресурс был изменен после указанной даты. Если изменений не было, сервер отправляет статус 304 Not Modified.

2. Условные GET-запросы
	Если нет четкой информации о сроках действия кэшированной версии (например, отсутствует заголовок Expires), клиент может использовать условный GET-запрос для проверки актуальности кэшированной копии:

	- Conditional GET: Это запрос, в котором клиент запрашивает ресурс с сервером, но только при условии, что он изменился с момента последнего запроса. Сервер проверяет состояние ресурса и отвечает либо с новым содержимым (если ресурс изменился), либо с коротким ответом 304 Not Modified (если ресурс остался неизменным).

	Эвристические правила
		Когда информация о сроках действия ресурса недоступна, браузеры могут применять эвристические правила для определения времени кэширования:

	- Например, если страница не изменялась в течение года, можно предположить, что она не изменится и в ближайшее время. Однако такие эвристики могут быть ненадежными и зависят от контекста.
#### HTTP/1 и HTTP/1.1

Обычно при установке связи с сервером браузер устанавливает TCP-соединение с **портом 443 сервера для HTTPS** (или портом 80 для HTTP), хотя формально эта процедура необязательна. Ценность использования TCP в том, что ни браузерам, ни серверам не приходится беспокоиться о том, что делать со слишком длинными сообщениями, надежностью и контролем перегрузки. Все это обеспечивается протоколом TCP.

Изначально в интернете использовался протокол HTTP/1.0, и после установления соединения отсылался один запрос, на который приходил один ответ. После этого TCP-соединение разрывалось. 

**Позже был создан протокол HTTP/1.1**, поддерживающий постоянные соединения (persistent connection), что позволило устанавливать TCP-соединения, отправлять запросы, получать ответы, а затем передавать и принимать дополнительные запросы и ответы. Эта ==стратегия называется повторным использованием соединения (connection reuse).== Стало возможным также конвейеризировать запросы, то есть отправлять запрос 2 еще до прибытия ответа на запрос 1.
![[Pasted image 20250108195759.png]]

**На практике клиенты и серверы обычно сохраняют постоянное соединение, пока не пройдет какой-то небольшой промежуток времени** (например, 60 с), в течение которого не будет отправлено ни одного запроса и не будет принято ни одного ответа, или же если открыто слишком много соединений и некоторые нужно закрыть.

Можно также отсылать один запрос по одному TCP-соединению, но устанавливать эти соединения одновременно. **Метод параллельных соединений (parallel connection)** широко использовался брау­зерами до появления постоянных соединений. У него тот же недостаток, что и у последовательных соединений — дополнительные служебные операции, — но производительность гораздо выше. Однако запуск большого числа TCP-соединений с одним и тем же сервером не лучшая идея, поскольку TCP отслеживает перегрузки для каждого соединения отдельно. В результате соединения соревнуются друг с другом, вызывая дополнительные потери пакетов, и в общем являются более агрессивными пользователями сети, чем индивидуальные соединения. 

**Постоянные соединения превосходят параллельные и являются более предпочтительными, так как избегают ненужных издержек и не страдают от проблем с перегрузками.**


#### HTTP/2

**Введение в HTTP/2 История:**

  - HTTP/1.0: Запущен в 1997 году.
  - HTTP/1.1: Выпущен в 2007 году.
  - HTTP/2: Спецификация RFC 7540 была опубликована в мае 2015 года, основанная на протоколе SPDY, разработанном Google.

**Цели разработки HTTP/2**

1. Выбор версии: Возможность клиентам и серверам выбирать, какую версию HTTP использовать.
2. Совместимость: Поддержка максимальной совместимости с HTTP/1.1.
3. Повышение производительности:
   - Мультиплексирование запросов.
   - Конвейеризация.
   - Сжатие заголовков.
4. Поддержка существующих методов: Совместимость с браузерами, серверами, прокси-серверами и сетями доставки.

**Обратная совместимость**
- Существующие приложения могут работать с HTTP/2 без изменений.
- Новые приложения могут использовать новые функции для повышения производительности.
- Заголовки, URL-адреса и общая семантика остались почти неизменными, изменились лишь способы кодирования и взаимодействия.

**Основные особенности HTTP/2**

1. Установление соединения:

   - В HTTP/1.1: Клиент устанавливает TCP-соединение, отправляет текстовый запрос, ожидает ответа и разрывает соединение после каждого запроса.

   - В HTTP/2: После установки TCP-соединения можно отправлять множество запросов в двоичном виде с возможностью приоритизации. Сервер может отвечать в любом порядке, а соединение разрывается только после отправки всех ответов.

2. Server Push:

   - Сервер может «проталкивать» файлы, которые могут понадобиться клиенту, даже если клиент их не запрашивает изначально. Например, сервер может отправить таблицы стилей и файлы JavaScript до их явного запроса клиентом.

3. Сжатие заголовков:

   - Заголовки сжимаются и отправляются в двоичном виде для экономии пропускной способности и уменьшения задержки.

4. Идентификация ответов:

   - Каждый ответ содержит идентификатор запроса, что позволяет браузеру определить, какому запросу соответствует ответ.

**Шифрование**

- Шифрование в HTTP/2 не является обязательным, но современные браузеры требуют его использования, особенно при просмотре веб-сайтов.

#### HTTP/3

HTTP/3, или просто H3, — это третья крупная версия протокола HTTP, призванная заменить HTTP/2. Главное отличие HTTP/3 состоит в использовании другого транспортного протокола для пересылки HTTP-сообщений: **вместо TCP здесь используется QUIC — версия протокола UDP**, дополненная контролем перегрузки пользовательского пространства. 

Популярные веб-серверы, включая nginx, теперь тоже позволяют использовать HTTP/3, установив соответствующие патчи.

**Транспортный протокол QUIC** поддерживает мультиплексирование потоков и примерно такой же механизм управления отдельными потоками, какой предлагался в версии HTTP/2. Надежность на уровне потока и контроль перегрузок в масштабе соединения существенно повышают производительность HTTP.

При наличии соединения с конечной точкой сервера HTTP/3 позволяет клиенту повторно использовать то же соединение с множеством различных URL-адресов.

Версия HTTP/3, использующая протокол HTTP поверх QUIC, теоретически может значительно увеличить производительность по сравнению с версией HTTP/2 (в основном за счет преимуществ QUIC над TCP). В некоторой степени протокол QUIC можно рассматривать как следующее поколение TCP. 


## Конфиденциальность в интернете

#### Файлы [[Cookies файлы|cookie]]

Один из традиционных способов отслеживания — размещение на клиентских устройствах файлов cookie. 

Когда пользователь запрашивает веб-объект (например, веб-страницу), веб-сервер может разместить на устройстве пользователя фрагмент персистентного состояния в виде файла cookie, используя директиву «set-cookie» протокола HTTP. Данные, переданные на устройство клиента с помощью этой директивы локально сохраняются на нем. 

Файлы cookie, установленные одним доменом, обычно видны только этому домену. Например, если некая рекламная сеть установит cookie на устройство пользователя, то он будет виден только ей и никому другому. Эта стратегия веб-безопасности, называемая **политикой одного источника (same-origin policy)**, предотвращает чтение одной из сторон файла cookie, установленного другой стороной, и в какой-то мере ограничивает распространение информации об отдельных пользователях.

**Супер-cookie** и другие локально сохраняемые идентификаторы отслеживания (которые пользователь не может контролировать, в отличие от обычных cookie) позволяют прокси-серверу отслеживать поведение пользователя в течение долгого времени. Уникальные идентификаторы могут включать сторонние идентификаторы отслеживания, кодируемые в заголовках HTTP (точнее, в заголовках HSTS (HTTP Strict Transport Security — строгая безопасность передачи информации по протоколу HTTP), которые не удаляются при чистке файлов cookie, и в тегах, которые третья сторона (например, провайдер мобильного интернета) может вставлять в незашифрованный трафик определенного сегмента сети. Это позволяет рекламодателям и другим заинтересованным сторонам формировать профиль посещений пользователя подобно отслеживающим файлам cookie, которые используются рекламными сетями и поставщиками приложений.

#### Снятие цифрового отпечатка устройства и браузера

Даже когда пользователи отключают такие распространенные механизмы отслеживания, как сторонние cookie, веб-сайты и третьи стороны по-прежнему могут их отслеживать, используя информацию, которая возвращается устройством серверу (об окружении, контексте и устройстве). 

Один из популярных методов — снятие цифрового отпечатка хоста (canvas fingerprinting), при котором для идентификации устройства используется тег HTML `<canvas>`. Этот тег позволяет веб-приложениям отображать графику в режиме реального времени. Из-за различий в размерах, способе рендеринга шрифтов, подходе к сглаживанию и т. д. устройства могут по-разному отображать картинки, и результирующие пиксели можно использовать в качестве цифрового отпечатка.