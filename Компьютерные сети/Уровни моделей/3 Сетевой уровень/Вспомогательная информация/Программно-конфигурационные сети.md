
Управление трафиком в сетях представляет собой сложный процесс, требующий от операторов настройки параметров конфигурации протоколов маршрутизации. Эти изменения приводят к перераспределению нагрузки по новым маршрутам, однако механизмы управления трафиком действуют косвенно и могут быть непредсказуемыми. Проблемы, возникающие в этом контексте, частично решаются с помощью **программно-конфигурируемых сетей (SDN Software-Defined Networking)**, которые будут рассмотрены далее.

## Общие сведения

Главной причиной разработки SDN стало понимание, что плоскость управления (control plane) (логика выбора маршрутов и принятия решений о передаче) работает на программном уровне и может выполняться абсолютно независимо от плоскости данных (data plane) (аппаратных технологий, которые непосредственно извлекают информацию из пакетов и решают, что с ними делать).  технология SDN активно развивается в течение многих лет, основной принцип разделения плоскости данных и плоскости управления остается неизменным.

## Плоскость управления в SDN: логически централизованное программное управление

Одна из главных технических идей в основе SDN — наличие плоскости управления, работающей независимо от маршрутизаторов, часто в виде единственной логически централизованной программы.
**Первые исследования в области SDN были направлены на то, чтобы упростить**
**для сетевых операторов задачу по регулированию трафика.**

**Вместо настройки конфигурации сети предлагалось напрямую контролировать, какой путь выбирает каждый маршрутизатор.** Первые реализации технологии SDN должны были работать в рамках существующих интернет-протоколов маршрутизации для непосредственного управления выбором путей. Одним из таких решений стала **платформа управления маршрутизацией (Routing Control Platform, RCP).** Впоследствии развернутая в магистральных сетях для балансировки нагрузки и защиты от DoS-атак. Позднее появился ряд других систем, в частности Ethane, обеспечивающая централизованный программный контроль аутентификации хостов в сети. Однако для ее реализации требовались нестандартные коммутаторы, что не способствовало ее распространению.

Когда преимущества технологии SDN для сетевого администрирования стали очевидны, к ней начали проявлять интерес операторы сетей и поставщики оборудования.
Группа исследователей провела совместную работу с поставщиками коммутаторов, чтобы сделать этот интерфейс доступным для ПО. В результате был создан
**протокол OpenFlow** 2008г.

##### Протокол OpenFlow

**Изначально OpenFlow поддерживал очень простой интерфейс: данные записывались в ассоциативную память в виде обычной таблицы сопоставления действий (match-action table). Эта таблица позволяла коммутатору идентифицировать пакеты по одному или нескольким полям заголовка** (например, по полю MAC-адреса, IP-адреса и т. д.) и выполнить какое-либо действие, включая переадресацию пакета на определенный порт, его удаление или отправку в находящийся вне маршрута программный контроллер.

Было создано несколько версий протокола OpenFlow. Версия OpenFlow 1.0 предусматривала наличие одной таблицы сопоставления действий. С помощью этой таблицы можно было найти точные совпадения с указанной комбинацией полей заголовка пакета (полей MAC-адреса, IP-адреса и т. д.) или произвести поиск по шаблону (например, по префиксу IP-адреса или MAC-адреса). В последующих версиях (наиболее заметная из них — OpenFlow 1.3) была добавлена поддержка более сложных операций, включая работу с цепочками таблиц, но лишь немногие поставщики реализовали эти возможности. 

##### Итог протокола OpenFlow

В итоге некоторые из этих технологий получили весьма ограниченное распространение: OpenFlow стал использоваться в крупных центрах обработки данных, где сетевые операторы обладали полным контролем над сетью. В глобальных и корпоративных сетях они использовались еще реже, поскольку в таблице переадресации можно было выбрать лишь очень ограниченный набор действий. 

Кроме того,многие поставщики коммутаторов так и не предоставили полную реализацию последних версий данного протокола. Это затрудняло практическое внедрение решений, использующих эти возможности. Однако в конечном счете протокол **OpenFlow оставил после себя в качестве наследия пару важных идей: контроль над сетью с помощью одной централизованной программы, координирующей сетевые устройства и элементы пересылки,** и выражение этого контроля с помощью одного высокоуровневого языка программирования (например, Python или Java).

По сути, OpenFlow является очень ограниченным интерфейсом. Он не был рассчитан на гибкое управление сетью. Скорее он стал удобным сиюминутным решением, разработка которого была обусловлена рынком.

## Плоскость данных в SDN: программируемое оборудование

В силу очевидных ограничений чипсета OpenFlow цель последующей работы с SDN заключалась в повышении степени программируемости самого оборудования. Множество разработок в этой области, касающихся сетевых карт и коммутаторов, обеспечили настройку практически всех параметров, от формата пакета до режима передачи.
**Для этой архитектуры используется общее название — протоколонезависимая архитектура коммутатора (protocol-independent switch architecture). Она предполагает наличие фиксированного набора конвейеров обработки. Каждый из них обладает памятью для таблиц сопоставления действий и определенным объемом регистровой памяти, а также поддерживает ряд простых операций, например добавление.**

Соответствующая **модель переадресации называется реконфигурируемыми таблицами сопоставления (Reconfigurable Match Tables, RMT)**; ее конвейерная архитектура была вдохновлена RISC-архитектурами. Каждая ступень конвейера обработки может считывать информацию из заголовков пакетов, модифицировать значения заголовка с помощью простых арифметических операций и записывать эти значения обратно в пакеты
**Архитектура чипа содержит программируемый парсер, набор ступеней сопоставления в определенном состоянии. Они выполняют арифметические вычисления над пакетами** и принимают простейшие решения по их передаче или удалению. Другой компонент чипа, депарсер, записывает полученные значения обратно в пакеты. 
![[Pasted image 20241225141808.png]]
**Каждая ступень чтения/модификации может менять как собственное состояние, так и любые метаданные пакетов** (например, информацию о том, какую глубину очереди видит отдельный пакет). Такая степень программируемости оказалась наиболее полезной в сетях датацентров. Благодаря своей архитектуре они способны извлечь выгоду из широких возможностей настройки. С другой стороны, данная модель обеспечивает общее повышение эффективности и расширение функциональности. Она **позволяет включать в пакеты информацию о состоянии самой сети с помощью внутриполосной сетевой телеметрии (In-band Network Telemetry, INT) (например,**
**величину задержки на каждом транзитном участке пути).**

Современные чипсеты, такие как Barefoot Tofino, позволяют выполнять протоколонезависимую обработку нестандартных пакетов на входе и на выходе илл.
![[Pasted image 20241225141919.png]]


**Одним важным шагом в области программируемого управления коммутаторами стала разработка открытой программной реализации Open vSwitch (OVS), которая позволяет обрабатывать пакеты на нескольких уровнях и работает в виде модуля ядра Linux**. OVS предлагает целый ряд возможностей, от VLAN до IPv6. Операторы сетей получили возможность настраивать переадресацию в дата-центрах, в частности, запуская OVS в качестве коммутатора в гипервизоре серверов.


## Программируемая сетевая телеметрия

Одним из наиболее важных преимуществ технологии SDN является то, что она позволяет обеспечить программируемую оценку параметров сети.

Программируемое коммутационное оборудование, представленное в предыдущем разделе, обеспечивает более гибкий сбор телеметрии. Одна из тенденций, к примеру, заключается в предоставлении операторам сетей возможности запрашивать данные о сетевом трафике на высокоуровневом языке с использованием
таких фреймворков, как MapReduce. 

##### Проблемы программируемое коммутационное оборудование
К сожалению, программируемое коммутационное оборудование еще (пока) не настолько совершенно, чтобы поддерживать сложные запросы. Иногда их нужно разделять между потоковым процессором и сетевым коммутатором. Для этого существует несколько технологий. 

Вопрос об эффективном способе отображения высокоуровневых абстракций и конструкций запросов на коммутационное аппаратное и программное оборудование более низкого уровня остается открытым.

Наконец, крупной проблемой в сфере программируемой сетевой телеметрии в ближайшие годы будет все большее распространение в интернете зашифрованного трафика. С одной стороны, это обеспечивает конфиденциальность, затрудняя несанкционированный доступ к пользовательским данным. 
Но с другой стороны, невозможность увидеть содержимое трафика усложняет задачу сетевого администрирования для операторов. К примеру, рассмотрим отслеживание качества видеопотоков. Если трафик не зашифрован, можно узнать битрейт и разрешение видео. В противном случае эти сведения приходится логически выводить на основе тех свойств сетевого трафика, которые доступны для непосредственного наблюдения.

В недавних исследованиях были представлены способы автоматического логического вывода высокоуровневых свойств трафика сетевых приложений на основе низкоуровневой статистики. Рано или поздно операторам потребуются более эффективные модели, позволяющие логически оценить влияние перегрузки и других факторов на производительность приложений.