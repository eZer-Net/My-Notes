
#### Принципы, которые легли в основу при разработке и обеспечили дальнейший успех:
принципы пронумерованы и включены в документ RFC 1958.  Этот документ использует идеи, изложенные в работах Кларка (Clark, 1988) и Зальцера и др. (Saltzer et al., 1984).

1. **Убедитесь в работоспособности**. Нельзя считать разработку (или стандарт) законченной, пока не осуществлен ряд успешных соединений между прототипами. Очень часто разработчики сначала пишут тысячестраничное описание стандарта, утверждают его, а потом обнаруживается, что он еще очень сырой или вообще неработоспособен. Тогда пишется версия 1.1. Так быть не должно.

2. **Упрощайте**. Если есть сомнения, выбирайте самое простое решение. Уильям Оккам (William Occam) декларировал этот принцип еще в XIV веке (так называемая «Бритва Оккама»). Его можно кратко выразить так: «Борись с излишествами». Если какое-то свойство не является абсолютно необходимым, забудьте о нем, особенно если того же эффекта можно добиться комбинированием уже имеющихся свойств.

3. **Всегда делайте четкий выбор**. Если есть несколько способов реализации одного и того же, выбирайте только один из них. Увеличение количества способов приведет к проблемам. В стандартах часто можно встретить несколько опций, режимов или параметров лишь потому, что при разработке несколько авторитетных сторон настаивали на своем. Разработчики должны решительно сопротивляться подобным тенденциям. Надо просто уметь говорить «нет».

4. **Используйте модульный принцип**. Это правило напрямую ведет к идее стеков протоколов, в которых каждый уровень работает независимо от остальных. Таким образом, если обстоятельства требуют изменения одного модуля или уровня, то это не затрагивает другие части системы.

5. **Учитывайте разнородность**. Любая крупная сеть может содержать различные типы оборудования, средства передачи данных и приложения. Сетевая технология должна быть достаточно гибкой, простой и обобщенной, чтобы работать в таких условиях.

6. **Избегайте статичности свойств и параметров**. Если есть какие-то обязательные параметры (например, максимальный размер пакета), то лучше заставить отправителя и получателя договариваться об их конкретных значениях, чем жестко закреплять их.

7. **Лучшее — враг хорошего**. Очень часто разработчики создают хорошие проекты, но не могут предусмотреть какие-нибудь необычные частные случаи. Не стоит портить то, что в большинстве ситуаций работает нормально. Лучше переложить бремя ответственности за «улучшения» проекта на тех, кто предъявляет свои странные требования.

8. **Будьте строги при отправке, но снисходительны при получении.** Другими словами, передавайте только те пакеты, которые полностью соответствуют всем требованиям стандартов. При этом имейте в виду, что входящие пакеты не всегда идеальны и нужно постараться их обработать.

9. **Продумайте масштабируемость**. Если в сети работают миллионы хостов и миллиарды пользователей, о централизации можно забыть. Нагрузка должна быть распределена максимально равномерно между имеющимися ресурсами.

10. **Помните о производительности и цене**. Никто не будет использовать низкопроизводительную или дорогостоящую сеть.

Детали построения сетевого уровня интернета, можно рассматривать как набор соединенных друг с другом сетей или автономных систем (АС). 
Структуры как таковой он не имеет, но все же существует несколько магистралей. Они состоят из высокопроизводительных линий и быстрых маршрутизаторов.

Самые крупные магистрали (к которым необходимо подключиться, чтобы получить доступ к остальной части интернета) называются сетями Tier 1 (Tier 1 networks).
К ним присоединены провайдеры, обеспечивающие доступ к интернету для домашних пользователей и предприятий, дата-центров и станций колокации с большим числом серверов, а также для региональных сетей (сетей среднего уровня). Центры обработки данных обслуживают большую часть интернет-трафика. К региональным сетям присоединяются другие интернет провайдеры, LAN многочисленных университетов и компаний, а также прочие периферийные сети. 
**Вся эта конструкция держится благодаря протоколу IP (Internet Protocol).**
 ==IP с самого начала разрабатывался для межсетевого обмена. Его задача предоставить уровень обслуживания best effort (то есть без гарантий) при передаче пакетов от отправителя к получателю, независимо от того, находятся они в одной сети или нет.==

**Обмен данными в интернете происходит следующим образом.** Транспортный уровень разбивает потоки данных так, чтобы их можно было отправить в виде IP-пакетов. В теории каждый пакет может достигать 64 Кбайт, но на практике он обычно не превышает 1500 байт (укладывается в один фрейм Ethernet).
IP-маршрутизаторы передают пакеты по сети, от одного маршрутизатора к другому, пока они не достигнут места назначения. Там сетевой уровень отдает данные транспортному, а тот помещает их во входной поток принимающего процесса. Когда фрагменты приходят на устройство адресата, сетевой уровень собирает их в исходную дейтаграмму, которая затем передается транспортному уровню.

[Ссылка на разбор 2 стандартов протокола](https://neerc.ifmo.ru/wiki/index.php?title=IP). 

## Протокол IP версии 4

##### Чутка истории про другие протоколы ip
На деле протокол IPv6 (следующая версия IP) разработан более десяти лет назад, но применять его начинают только сегодня. О нем мы поговорим позже в этом разделе. Широкое распространение протокол IPv6 получит, когда у каждого из почти 231 жителей Китая будет настольный ПК, ноутбук и IP-телефон. Что касается нумерации, то ничего странного в ней нет: в свое время существовал малоизвестный экспериментальный потоковый протокол реального времени IPv5.
##### Формат заголовка.
![[Pasted image 20241226093316.png]]

- **Поле Version**
	Содержит версию протокола, к которому принадлежит дейтаграмма. 
	Указание версии в начале каждой дейтаграммы позволяет переходить от одной версии к другой.

- **Поле IHL**
	Длина заголовка является переменной величиной, она указывается в поле IHL и выражается в 32-разрядных словах.
	
- **Поле Differentiated services** (Дифференцированное обслуживание)
	Предназначено для управления качеством обслуживания (QoS) в сетях. Оно позволяет классифицировать и приоритизировать трафик, что особенно важно для приложений, чувствительных к задержкам, таких как VoIP или видеоконференции. 
		1. Классификация трафика: Первые 6 бит поля определяют класс обслуживания, позволяя маршрутизаторам обрабатывать пакеты в зависимости от их приоритета и требований к качеству.
		2. Управление задержками и пропускной способностью: Поле помогает маршрутизаторам оптимизировать обработку трафика, обеспечивая более быструю доставку для критически важных данных.
		3. Уведомления о перегрузке: Последние 2 бита используются для сигнализации о состоянии перегрузки в сети, что позволяет принимать меры для управления трафиком и предотвращения потерь данных.

- **Поле Total length** (Полная длина)
	Содержит длину всей дейтаграммы: заголовок и данные. Максимальная длина дейтаграммы — 65 535 байт.

- **Поле Identification** (Идентификация)
	позволяет хосту-получателю определить, какому пакету принадлежат принятые им фрагменты. Все фрагменты одного пакета содержат одно и то же значение идентификатора.

- **Два одно битных поля DF FM**
	Относятся к фрагментации. 
		**Бит DF** означает «Don’t Fragment» («Не фрагментировать»); он запрещает маршрутизатору фрагментировать пакет.
		Пометив дейтаграмму битом DF, отправитель гарантирует, что либо дейтаграмма дойдет единым блоком, либо отправитель получит сообщение об ошибке.
		**Бит MF** означает «More Fragments» («Дополнительные фрагменты»). Он устанавливается во всех фрагментах, кроме последнего. По этому биту получатель узнает о прибытии последнего фрагмента дейтаграммы.

- **Поле Fragment offset** (Смещение фрагмента) 
	 Указывает положение фрагмента в исходном пакете. Длина всех фрагментов в байтах, кроме длины последнего фрагмента, должна быть кратной 8. Так как на это поле выделено 13 бит, максимальное количество фрагментов в дейтаграмме равно 8192, что дает максимальную длину пакета вплоть до пределов поля Total length.

- **Поле TtL, Time to live** (Время жизни)
	Представляет собой счетчик, ограничивающий время существования пакета. Изначально предполагалось, что он будет отсчитывать время в секундах. Максимальное значение равнялось 255 с. На каждом маршрутизаторе оно должно было уменьшаться как минимум на единицу плюс время стояния в очереди. Однако на практике отсчитывается количество переходов через маршрутизаторы. Когда значение этого поля достигает нуля, пакет отвергается, а отправителю отсылается пакет с предупреждением. Таким образом удается избежать вечного странствования пакетов

- **Поле Protocol** (Протокол)
	 Нумерует процесс для сетевого уровня решая, что делать ему, какому процессу транспортного уровня нужно передать пакет: TCP, UDP или какому либо другому. Нумерация процессов глобально стандартизирована по всему интернету. Номера протоколов (и некоторые другие) были перечислены в RFC 1700, но теперь они собраны в базе данных 
	 по адресу www.iana.org.

- **Поле Header checksum** (Контрольная сумма заголовка)
	Алгоритм вычисления суммы просто складывает все 16-разрядные полуслова заголовка по мере их поступления с помощью арифметики дополнительных кодов, а затем использует дополнение результата. Алгоритм предполагает, что контрольная сумма заголовка по прибытии должна быть нулевой. Этот метод полезен для обнаружения ошибок, возникающих во время прохождения пакета по сети.
		Для данного поля сумма должна подсчитываться заново на каждом транзитном участке, поскольку хотя бы одно поле постоянно меняется (поле Time to live).

- **Поля Source address (Адрес отправителя)** и **Destination address (Адрес получателя)**
	Указывают IP-адреса сетевых интерфейсов отправителя и получателя. 

- **Поле Options**
	 Было разработано, чтобы с появлением новых вариантов протокола не пришлось вносить в заголовок поля, отсутствующие в нынешнем формате.
	 **Изначально было определено пять разновидностей этого поля:**
	 1. Security - Указывает уровень секретности дейтаграммы
	 2. Strict source routing - Задает полный путь следования дейтаграммы
	 3. Loose source routing - Задает список маршрутизаторов, которые нельзя миновать
	 4. Record route - Требует, чтобы все маршрутизаторы добавляли свой IP-адрес
	 5. Timestamp - Требует, чтобы все маршрутизаторы добавляли свой IP-адрес и временную метку


## IP-адреса

Определяющим признаком IPv4 является его 32-битный адрес. 
IPv4-адрес состоит из четырех [[Компьютерные сети/Термины#Октет|октетов]] (по 8 бит каждый), которые удобно представляются в десятичном формате как четыре числа, разделенные точками (например, 192.168.1.1). Каждый октет может принимать значения от 0 до 255.

У каждого хоста и маршрутизатора в интернете есть IP-адрес, который может использоваться в полях Source address (адрес отправителя) и Destination address(адрес получателя) IP-пакетов.

**Важно отметить, что IP-адрес на самом деле не имеет отношения к хосту**. Он относится к сетевому интерфейсу, поэтому хост, соединенный с двумя сетями, должен иметь два IP-адреса. Однако на практике большинство хостов подключены к одной сети, следовательно, имеют один адрес. Маршрутизаторы, наоборот, обычно имеют
несколько интерфейсов, а значит, и несколько IP-адресов.

#### Префиксы

**IP-протокол использует префиксы для разделения сети на подсети, что необходимо из-за ограничений адресного пространства.** Префиксы помогают организовать адресацию, обеспечивая более эффективное использование IP-адресов и упрощая маршрутизацию.

##### Префиксы работают следующим образом:
• Сетевой адрес — это часть IP-адреса, которая идентифицирует саму сеть.

• Маска подсети — указывает, сколько битов в адресе используется для сетевого идентификатора (Примеры: /12 /17 или 255.255.128.0).

**Маска подсети может быть представлена в виде десятичного числа (например, /24) или в виде полного двоичного формата.** Например, маска /24 означает, что первые 24 бита адреса используются для обозначения сети, а оставшиеся 8 бит — для хостов в этой сети.

==IP-адрес с префиксом: 192.168.1.10/24==
Это означает, что сеть состоит из адресов от 192.168.1.0 до 192.168.1.255. Первые 24 бита (192.168.1) идентифицируют сеть, а последние 8 бит (10) — конкретный хост в этой сети.

**Пример перевода маски в префикс**

Маска подсети - 255.255.128.0
   • 255 в двоичном — 11111111
   • 255 в двоичном — 11111111
   • 128 в двоичном — 10000000
   • 0 в двоичном — 00000000
   
11111111.11111111.10000000.00000000

Подсчитав 1 получаем /17
##### Преимущества префиксов

Важное преимущество префиксов состоит в том, что маршрутизаторы могут направлять пакеты, используя только сетевую часть адреса, поскольку каждой сети соответствует свой уникальный адресный блок. Маршрутизатору не нужно учитывать часть адреса, задающую хост, так как пакеты для всех хостов одной сети передаются в одном направлении. Пакеты передаются на хосты только после того, как попадают в нужную сеть. В результате таблицы маршрутизации значительно сокращаются. 

##### Недостатки префиксов

**IP-адрес хоста зависит от его местоположения в сети**. Адреса Ethernet можно использовать в любой точке мира, а IP-адрес принадлежит конкретной сети, и поэтому маршрутизаторы могут доставить пакет, предназначенный для данного адреса, только в эту сеть. Чтобы хосты могли перемещаться из одной сети в другую, сохраняя свой IP-адрес, необходимы новые решения, такие как мобильный IP.

Второй недостаток состоит в том, что **неправильная иерархия может привести к неэффективному использованию адресов**. Если адреса приписываются сетям слишком крупными блоками, много адресов будет выделено, но не будет использоваться. Этот факт не имел бы большого значения, если бы адресов было достаточно, но уже более десяти лет назад стало ясно, что свободное адресное пространство в интернете заполняется с невероятной скоростью.

#### Подсети

Во избежание конфликтов номера сетей назначаются некоммерческой организацией — **Корпорацией по управлению доменными номерами и IP-адресами (Internet Corporation for Assigned Names and Numbers, ICANN)**. ICANN передала полномочия по присвоению некоторых частей адресного пространства региональным органам, занимающимся выделением IP-адресов провайдерам и другим компаниям. Именно так компании получают блоки IP-адресов.

**Маршрутизация по префиксу требует, чтобы у всех хостов сети был один и тот же сетевой номер.** Это свойство IP-адресации может вызвать проблемы при увеличении сети. **Проблема решается предоставлением сети возможности разделения на несколько частей** с точки зрения внутренней организации. **Это называется разбиением на подсети (subnetting).**
![[Pasted image 20241226134328.png]]

Когда приходит пакет, маршрутизатор просматривает адрес назначения и определяет, к какой подсети он относится. Для этого он может выполнить операцию AND от этого адреса и маски каждой подсети, сравнивая результат с соответствующим префиксом.
Пример:
	У нас есть пакет с адресом 128.208.2.151. Чтобы проверить, относится ли он к факультету информатики, прибавим к нему (используя логическое AND) маску 255.255.128.0, таким образом отрезав первые 17 бит (то есть 128.208.0.0). Далее сравним полученный результат с префиксом (128.208.128.0). Они не совпадают. Для факультета электротехники аналогичным образом берем первые 18 бит адреса и получаем 128.208.0.0. Это значение совпадает с префиксом, поэтому пакет передается на интерфейс, ведущий к сети факультета электротехники.

Разбиение на подсети можно впоследствии изменить. Для этого нужно обновить сведения о сетевых масках подсетей на всех маршрутизаторах данного места. За пределами сети это разделение незаметно, поэтому нет нужды с появлением каждой подсети обращаться в ICANN


#### Классовая и специальная адресация (до появления CIDR)

Метод, который применялся ранее. До 1993 года IP-адреса разделялись на 5 категорий.

Класс А: 1.0.0.0 — 126.0.0.0, маска 255.0.0.0  
	(кол. хостов более 16 миллионов)

Класс В: 128.0.0.0 — 191.255.0.0, маска 255.255.0.0 
	(кол. хостов более 65 тысяч)

Класс С: 192.0.0.0 — 223.255.255.0, маска 255.255.255.0  
	(256 устройств)

Класс D: 224.0.0.0 — 239.255.255.255, маска 255.255.255.255
	(класс зарезервирован для многоадресной рассылки ) 

Класс Е: 240.0.0.0 — 247.255.255.255, маска 255.255.255.255 
	(зарезервирован для научных исследований)

Проблема данной структуры в том что многие компании верили что в 1 момент они разрастутся до великих размеров и у них будет много устройств, но зачастую всем хватило бы класса C.

#### CIDR — бесклассовая междоменная маршрутизация

CIDR (Classless Inter-Domain Routing) — это метод маршрутизации, который был введен в 1993 году для улучшения управления адресами в Интернете и оптимизации маршрутизации. Он заменил традиционную классовую систему адресации, которая делила IP-адреса на классы (A, B, C и т.д.) с фиксированной длиной префикса.

Последняя на сегодняшний день версия описана в RFC 4632 (Фуллер и Ли; Fuller and Li, 2006)

По сути, CIDR работает так. Когда прибывает пакет, необходимо определить, указан ли нужный адрес в префиксе; для этого просматривается таблица маршрутизации. Может оказаться, что по значению подойдет несколько записей, тогда выбирается самый длинный префикс. То есть если найдено совпадение для маски /20 и /24, то для выбора исходящей линии будет использоваться запись, соответствующая /24. Однако если бы таблица действительно просматривалась запись за записью, этот процесс был бы слишком долгим. Чтобы этого избежать, был разработан сложный алгоритм для ускорения процесса поиска адреса в таблице (Руис-Санчес и др.; Ruiz-Sanchez et al., 2001). В маршрутизаторах для коммерческого использования применяются специальные чипы VLSI, в которые эти алгоритмы встроены на аппаратном уровне.
##### Основные аспекты CIDR

1. **Префиксная запись**: 
   CIDR использует префиксную запись для обозначения диапазонов IP-адресов. Например, вместо указания класса (A, B, C), адрес записывается как 192.168.0.0/24, где /24 указывает на количество бит, отведенных под сеть (в данном случае 24 бита).

2. **Агрегация маршрутов**:
   CIDR позволяет агрегировать несколько маршрутов в один, что снижает количество записей в таблицах маршрутизации. Например, вместо того чтобы хранить записи для всех адресов от 192.168.0.0 до 192.168.3.255, можно использовать один маршрут 192.168.0.0/22.

3. **Гибкость адресации**:
   CIDR позволяет использовать адреса переменной длины (Variable Length Subnet Masking, VLSM), что означает, что сети могут быть разбиты на подсети различного размера в зависимости от потребностей. Это позволяет более эффективно использовать адресное пространство.

4. **Устранение недостатка классовой системы**:
   Классовая система адресации имела серьезные недостатки, такие как неэффективное использование адресов и ограниченность в выборе размеров подсетей. CIDR решает эти проблемы, позволяя создавать сети любых размеров.

##### Проблемы, которые решает CIDR

1. Экономия адресного пространства:
   CIDR позволяет более эффективно распределять IP-адреса, избегая ситуации, когда организации получают больше адресов, чем им нужно.

2. Снижение размера таблиц маршрутизации:
   Агрегация маршрутов позволяет уменьшить количество записей в таблицах маршрутизации на маршрутизаторах, что облегчает их работу и ускоряет процесс маршрутизации.

3. Гибкость в управлении сетью:
   CIDR позволяет создавать сети различных размеров и конфигураций в зависимости от текущих потребностей, что делает управление сетью более гибким и адаптивным.

4. Поддержка роста Интернета:
   CIDR стал важным инструментом для поддержки роста Интернета, позволяя эффективно управлять растущим числом устройств и пользователей.

##### Пример структуры CIDR
![[Pasted image 20241226141102.png]]



#### NAT — трансляция сетевого адреса

NAT (Network Address Translation) — это технология, используемая в сетях для преобразования адресов IP и портов, которая позволяет нескольким устройствам в локальной сети (LAN) использовать один или несколько общих публичных IP-адресов для доступа к Интернету. NAT часто реализуется на маршрутизаторах.
![[Pasted image 20241226150103.png]]

##### Как работает NAT

1. Преобразование адресов:
   Когда устройство в локальной сети отправляет запрос на доступ к Интернету, маршрутизатор с NAT заменяет его частный IP-адрес (например, 192.168.1.2) на свой публичный IP-адрес. Это позволяет устройствам в локальной сети выходить в Интернет, используя один общий адрес.

2. Отслеживание соединений:
   NAT также отслеживает соединения, создавая таблицу сопоставления между внутренними (частными) и внешними (публичными) адресами и портами. Например, когда устройство с частным IP-адресом 192.168.1.2 отправляет запрос, NAT запоминает, какой внутренний IP-адрес и порт использовались, и сопоставляет их с публичным IP-адресом и портом.

3. Обратное преобразование:
   Когда ответ от сервера приходит обратно на публичный IP-адрес маршрутизатора, NAT использует свою таблицу для преобразования адреса обратно на частный IP-адрес устройства, которое инициировало соединение.
##### Недостатки NAT

1. Проблемы с некоторыми протоколами:

   • FTP: Протокол FTP (File Transfer Protocol) использует два канала для передачи данных: один для команд (управляющий канал) и другой для передачи данных (канал данных). При использовании NAT управляющий канал может работать нормально, но при установлении канала данных могут возникнуть проблемы, так как адреса и порты передаются в самом протоколе FTP и могут не совпадать с теми, что используются в NAT.

   • SIP: Протоколы, такие как SIP (Session Initiation Protocol), также могут сталкиваться с проблемами из-за того, что они передают информацию о сетевых адресах в своих сообщениях.

2. Усложнение настройки:
   NAT может усложнить настройку сетевых приложений, особенно тех, которые требуют прямого доступа к устройствам в локальной сети (например, VPN-соединения).

3. Проблемы с производительностью:
   NAT может вызывать задержки из-за необходимости обработки пакетов и поддержания таблиц соединений. В больших сетях это может привести к снижению производительности.

4. Безопасность:
   Хотя NAT может обеспечить некоторую степень безопасности путем скрытия внутренних IP-адресов, он не является полноценным решением для защиты сети. Необходимо использовать дополнительные меры безопасности, такие как брандмауэры.

5. Ограничения на количество подключений:
   В зависимости от реализации NAT и количества доступных портов на публичном IP-адресе может возникнуть проблема с одновременными соединениями.



##### Виды NAT

1. Статический: Один локальный адрес равен одному глобальному адресу

2. Динамический: Кто первый взял глобальный адрес того и адрес

3. PAT: Переводит несколько локальных адресов в один или несколько глобальных адресов 
## Протокол IP версии 6

#### Немного истории 

Протокол IP активно применяется и даже несмотря на то что CIDR и NAT используют пространство достаточно экономно протокола ipv4, последние адреса IPv4 были выделены 25 ноября 2019 года. Но данную беду заметили ещё 20 лет назад так что было принято начать разработку нового стандарта или протокола который заменить ipv4.

 **IETF сформулировал следующие основные цели для формирования нового протокола.**
 
1. Поддерживать миллиарды хостов даже при неэффективном использовании
адресного пространства.

2. Сократить таблицы маршрутизации.

3. Упростить протокол для ускорения обработки пакетов маршрутизаторами.

4. Обеспечить более высокий уровень безопасности (аутентификации и конфиденциальности).

5. Уделять больше внимания типу службы, особенно при передаче данных в реальном времени.

6. Упростить работу многоадресных рассылок с помощью указания областей рассылки.

7. Предоставить хосту возможность перемещаться, сохраняя сетевой адрес.

8. Предусмотреть будущее развитие протокола.

9. Обеспечить сосуществование старого и нового протоколов в течение нескольких лет.

Был получен двадцать один ответ. В декабре 1992 года были рассмотрены семь серьезных предложений. Их содержание варьировалось от небольших изменений в IP до полного отказа от него и замены совершенно другим протоколом.

В частности, **было предложено запустить TCP на базе CLNP**, протокола сетевого уровня, разработанного для OSI. Обладая 160-разрядным адресом, CLNP навсегда обеспечил бы достаточное адресное пространство. **Он мог бы предоставить адрес каждой молекуле воды в Мировом океане**.  
**Но тогда пришлось бы признать, что кое-что в модели OSI было сделано правильно, а это утверждение является политически некорректным в интернет-кругах.** Протокол CLNP на самом деле очень мало отличается от IP. Окончательный выбор был сделан в пользу протокола, отличающегося от IP значительно сильнее. Еще одним **аргументом против CLNP была его слабая поддержка типов служб**, которые требовались для эффективной передачи мультимедиа.

После долгих обсуждений, переработок и борьбы за первое место была выбрана модифицированная комбинированная версия Диринга и Фрэнсиса, получившая название Простого **интернет-протокола Плюс (Simple Internet Protocol Plus, SIPP)**. Новому **протоколу было дано обозначение IPv6**.

#### Преимущество версии 6 над 4

Протокол IPv6 прекрасно справляется с поставленными задачами. Он обладает достоинствами IP и лишен некоторых его недостатков (либо обладает ими в меньшей степени), к тому же наделен новыми свойствами. Как правило, IPv6 несовместим с IPv4. Зато **он сочетается со всеми остальными протоколами интернета, включая TCP, UDP, ICMP, IGMP, OSPF, BGP и DNS**. Иногда это требует небольших изменений для работы с более длинными адресами. Функции IPv6 можно найти в стандартах RFC 2460–RFC 2466.

Прежде всего, **поля адресов у протокола IPv6 больше, чем у IPv4. Их длина составляет 128 бит**, что решает основную задачу, поставленную при разработке протокола, — обеспечить практически неограниченный запас интернет-адресов.

**IPv6 по сравнению с IPv4 состоит в упрощенном заголовке пакета. Он состоит всего из 7 полей (вместо 13 у IPv4)**. Таким образом, маршрутизаторы могут быстрее обрабатывать пакеты, что повышает производительность.

**В протоколе было уделено больше внимания QoS.** Различные нерешительные попытки по реализации QoS предпринимались и в прошлом, но рост мультимедийного интернет-трафика требует безотлагательных действий в этой сфере.

#### Основной заголовок IPv6
![[Pasted image 20241226155043.png]]


- **Поле Version**
	содержит число 6 для IPv6 (и 4 для IPv4). На период перехода с IPv4 на IPv6, который длится уже более десяти лет, маршрутизаторы по значению этого поля смогут различать пакеты нового и старого стандартов.

- **Поле Differentiated services** (изначально Traffic class, Класс трафика)
	Необходим, чтобы отличать пакеты с разными требованиями к доставке в реальном времени. Оно используется для обеспечения QoS вместе с архитектурой дифференцированного обслуживания.

- **Поле Flow label** (Метка потока) 
	Применяется для того, чтобы отправитель и получатель могли сообщить сети об определенных свойствах пакетов и требованиях к их обработке; при этом между ними устанавливается псевдосоединение.
		Поток устанавливается заранее и получает идентификатор. Когда прибывает пакет с ненулевым значением в поле Flow label, все маршрутизаторы проверяют свои таблицы, чтобы определить, какой тип особой обработки ему требуется. Таким образом, новый протокол пытается объединить достоинства подсетей различных типов: гибкость дейтаграмм и гарантии виртуальных каналов.

- **Поле Payload length** (Длина пользовательских данных)
	Сообщает, сколько байтов следует за 40-байтным заголовком. В заголовке IPv4 аналогичное поле называлось Total length и определяло весь размер пакета. В новом протоколе 40 байт заголовка учитываются отдельно. Это значит, что теперь пользовательские данные могут занимать 65 535 байт вместо 65 515.

- **Поле Next header** (Следующий заголовок)
	Можно использовать дополнительные (необязательные) расширенные заголовки. Это поле сообщает, какой из шести таких заголовков (на текущий момент) следует за основным. В последнем IP-заголовке поле Next header информирует, какому обработчику транспортного уровня (то есть TCP или UDP) передать пакет.

- **Поле Hop limit** (Максимальное число транзитных участков)
	Не дает пакетам вечно блуждать по сети. Оно имеет практически то же назначение, что и поле Time to live в заголовке IPv4. Это поле уменьшается на единицу на каждом транзитном участке. Теоретически в IPv4 это поле должно было содержать секунды существования пакета, однако ни один маршрутизатор не использовал его подобным образом, поэтому имя поля было приведено в соответствие со способом его применения.

-  **Поля Source address и Destination address**
	16-байтные адреса фиксированной длины для отправителя и получателя.

###### Разбор адреса ipv6

Для написания 16-байтных адресов была выработана новая нотация. **Адреса в IPv6 записываются в виде восьми групп по четыре шестнадцатеричные цифры**, разделенных двоеточиями, 
например: 8000:0000:0000:0000:0123:4567:89AB:CDEF

Поскольку многие адреса содержат большое количество нулей, разрешены
три метода сокращенной записи. 
1. могут быть опущены ведущие нули в каждой группе, например 0123 можно записывать как 123
2. одна или несколько групп, полностью состоящих из нулей, могут заменяться парой двоеточий. Пример: 8000::123:4567:89AB:CDEF
3. адреса IPv4 могут записываться как пара двоеточий, после которой пишется адрес в старом десятичном формате, например: ::192.31.20.46

###### Сравнение того что осталось ток в ipv4 заголовке

-  Поле IHL исчезло
	так как заголовок IPv6 имеет фиксированную длину

- Поле Protocol исчезло
	поскольку поле Next header сообщает, что следует за последним IP-заголовком (например, UDP- или TCP-сегмент).

- Поля относящиеся к фрагментации
	IPv6 используется другой подход к этому.  
	Все хосты, поддерживающие IPv6, должны динамически определять нужный размер пакета (Для этого используется метод поиска путевого значения MTU).
	Маршрутизатор, неспособный переслать пакет дальше, возвращает сообщение об ошибке. Получив это сообщение, хост должен прекратить всю передачу этому адресату.
	**Гораздо правильнее научить все хосты отправлять пакеты требуемого размера, нежели учить маршрутизаторы фрагментировать их на лету.**

- Поле Checksum исчезло 
	Подсчет контрольной суммы значительно снижает производительность. В настоящее время все шире используются надежные линии связи, а на канальном и транспортном уровнях подсчитываются свои контрольные суммы, так что наличие еще одной проверки не стоит требуемых затрат ресурсов.

#### Заголовки расширений 

Иногда удаленные поля заголовка могут понадобиться, поэтому в протоколе IPv6 была представлена новая концепция необязательного расширения заголовка (extension header). Можно добавить дополнительную информацию, при этом она эффективно закодирована.

Определены шесть типов таких заголовков (показано на илл.). Все они необязательны, но если их два и более, то они должны идти сразу за фиксированным заголовком, желательно в указанном порядке (как в таблице).

| Заголовок расширения       | Описание                                                   |
| -------------------------- | ---------------------------------------------------------- |
| Hop-by-hop options         | Разнообразная информация для маршрутизаторов               |
| Destination options        | Дополнительная информация для получателя                   |
| Routing                    | Частичный список транзитных маршрутизаторов на пути пакета |
| Fragment                   | Управление фрагментами дейтаграмм                          |
| Authentication             | Проверка подлинности отправителя                           |
| Encrypted security payload | Информация о зашифрованном содержимом                      |

- Заголовок Hop-by-hop options (Опции переходов)
	Содержит информацию, которая должна исследоваться маршрутизаторами на протяжении всего пути следования пакета.
	![[Pasted image 20241227100823.png]]
	**Дейтаграммы с такими заголовками расширений называются джамбограммами (jumbograms)**. Джамбограммы нужны для суперкомпьютерных приложений, передающих по интернету гигабайты данных.

- Заголовок Destination options (Опции адресата)
	Предназначен для полей, которые должны интерпретироваться только хостом-получателем.

- Заголовок Routing (Маршрутизация)
	Содержит информацию об одном или нескольких маршрутизаторах, которые следует посетить на пути к получателю.
	![[Pasted image 20241227101127.png]]

- Заголовок Fragment (Фрагмент)
	Решает проблему фрагментации способом, схожим с протоколом IPv4. Он содержит идентификатор дейтаграммы, номер фрагмента и бит, информирующий о том, является ли этот фрагмент последним. В отличие от IPv4, в протоколе IPv6 фрагментировать пакет может только хост-источник. Маршрутизаторы фрагментировать пересылаемые пакеты не могут. 

- Заголовок Authentication (Аутентификация)
	 предоставляет механизм подтверждения подлинности отправителя пакета. Заголовок Encrypted security payload (Шифрование пользовательских данных) обеспечивает конфиденциальность: прочесть содержимое пакета сможет только тот, для кого он предназначен. Для выполнения этих задач в заголовках используются криптографические методы.

#### Полемика споры при разработке

Все жуткие подробности можно найти в соответствующих RFC.

- Споры по поводу длины поля адреса

- Размер поля Hop limit
	участники дискуссии считали, что ограничение количества транзитных участков числом 255 (которое явно следует из использования 8-битного поля) — большая ошибка. В самом деле, маршруты из 32 транзитных участков уже стали обычным явлением, а через 10 лет в обиход могут войти более длинные пути.

- Максимальный размер пакета
	Обладатели суперкомпьютеров настаивали на размере пакетов, превышающем 64 Кбайт. Когда суперкомпьютер начинает передачу, он занимается серьезным делом и не хочет, чтобы его прерывали через каждые 64 Кбайт. Аргумент против больших пакетов заключается в том, что если пакет размером в 1 Мбайт будет передаваться по линии Т1 со скоростью 1,5 Мбит/с, то он займет линию на целых 5 с, что вызовет слишком большую задержку, заметную для интерактивных пользователей. В итоге удалось достичь компромисса: обычные пакеты ограничены размером 64 Кбайт, но с помощью заголовка расширения можно передавать огромные дейтаграммы.

- Удаление контрольной суммы IPv4
	Кое-кто сравнивал этот ход с удалением тормозов из автомобиля. При этом автомобиль становится легче и может двигаться быстрее, но если на пути что-то встретится, возникнет проблема. Аргумент против контрольных сумм состоял в следующем. Каждое приложение, которое действительно заботится о целостности своих данных, считает контрольную сумму на транспортном уровне, поэтому еще одна на сетевом является излишней (кроме того, она подсчитывается еще и на уровне передачи данных)


## Управляющие протоколы интернета

Помимо IP, используемого для передачи данных, в интернете есть несколько дополнительных управляющих протоколов сетевого уровня, к которым относятся
ICMP, ARP и DHCP.


#### ICMP — протокол управляющих сообщений интернета

За работой интернета следят маршрутизаторы. **Если во время обработки пакета происходит что-то непредвиденное, маршрутизатор сообщает об этом отправителю с помощью протокола управляющих сообщений интернета (Internet Control Message Protocol, ICMP).** Он также используется для тестирования интернета. Существует около десятка типов сообщений ICMP. Каждое ICMP-сообщение вкладывается в IP-пакет. Наиболее важные из них перечислены на илл.
![[Pasted image 20241227103834.png]]

- Сообщение DESTINATION UNREACHABLE (адресат недоступен)
	Используется, когда маршрутизатор не может обнаружить пункт назначения или когда пакет с битом DF (не фрагментировать) не может быть доставлен, так как путь ему преграждает сеть с ограничением на размер пакетов.

- Сообщение TIME EXCEEDED (время истекло)
	Отправляется, когда пакет игнорируется, так как его счетчик TtL (Time to live) уменьшился до нуля. Это событие — признак того, что пакеты двигаются по зацикленному пути или что установлено слишком низкое значение таймера.

- Сообщение PARAMETER PROBLEM (проблема параметра)
	Указывает на то, что обнаружено ошибочное значение в поле заголовка. Это признак наличия ошибки в программном обеспечении хоста, отправившего этот пакет, или промежуточного маршрутизатора.

- Сообщение SOURCE QUENCH (подавление источника)
	Ранее использовалось для «усмирения» хостов, которые отправляли слишком много пакетов. Хост, получивший такое сообщение, должен был снизить свою активность. В настоящее время SOURCE QUENCH используется редко, так как при возникновении перегрузки эти пакеты только подливают масла в огонь, еще больше загружая сеть. К тому же неясно, как на них отвечать. Теперь борьба с перегрузкой в интернете осуществляется в основном на транспортном уровне.

- Сообщение REDIRECT (переадресовать)
	Отсылается хосту-источнику, когда маршрутизатор замечает, что у пакета ошибка в адресе назначения. Таким способом маршрутизатор предлагает хосту обновить путь.

- Сообщения ECHO (запрос отклика) и ECHO REPLY (отклик)
	Отправляются, чтобы определить, достижим ли в данный момент конкретный адресат и функционирует ли он. Получив ECHO, хост должен ответить сообщением ECHO REPLY. Эти сообщения **используются утилитой ping**, которая проверяет, работает ли хост и подключен ли он к интернету.

- Сообщения TIMESTAMP REQUEST (запрос временной метки) и TIMESTAMP REPLY (отклик с временной меткой)
	Имеют то же назначение, но при этом в ответе проставляется время получения сообщения и время отправления ответа. Этот механизм применяется для измерения производительности сети.

- Сообщения ROUTER ADVERTISEMENT (обнаружение маршрутизатора) и ROUTER SOLICITATION (запрос к маршрутизатору)
	Позволяют хостам находить ближайшие маршрутизаторы. Хосту необходимо знать IP-адрес хотя бы одного из них, чтобы он мог передавать пакеты за пределы LAN.

 [полный список сообщений](https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml).

#### ARP — протокол разрешения адресов

Хотя у каждого устройства в интернете есть один или несколько IP-адресов, их недостаточно для отправки пакетов. Сетевые карты канального уровня, например Ethernet-карты, не понимают интернет-адресов.

ARP (Address Resolution Protocol) — это **сетевой протокол, используемый для преобразования IP-адресов в физические адреса (MAC-адреса) в локальных сетях**. 

###### Как работает ARP

1. **Запрос ARP:** Когда устройство (например, компьютер) хочет отправить данные на другой компьютер в локальной сети, оно сначала проверяет свой ARP-кэш, чтобы увидеть, есть ли уже соответствующий MAC-адрес для заданного IP-адреса. Если адреса нет, устройство отправляет широковещательный ARP-запрос (ARP Request) на всю сеть с просьбой предоставить MAC-адрес для указанного IP.

2. **Ответ ARP:** Устройство, которому принадлежит указанный IP-адрес, получает запрос и отправляет обратно ответ (ARP Reply), содержащий свой MAC-адрес. Этот ответ также может быть широковещательным, если требуется, чтобы другие устройства сети также обновили свои кэши.

3. **Кэширование:** После получения ответа, устройство сохраняет соответствие IP-адреса и MAC-адреса в своем ARP-кэше для будущего использования, что позволяет избежать повторных широковещательных запросов.

**Улучшения ARP**

1. **Кэширование ARP**: Устройства сохраняют соответствия IP и MAC в ARP-кэше, что позволяет повторно использовать информацию без необходимости отправлять новые запросы.

2. **Добровольное ARP (Gratuitous ARP)**: Это механизм, позволяющий устройству отправлять собственный IP и MAC адрес в виде широковещательного сообщения. Это помогает другим устройствам обновить свои кэши и обнаружить потенциальные конфликты IP-адресов.

3. **Устаревание записей**: Записи в ARP-кэше имеют срок действия и устаревают через несколько минут, что позволяет обновлять информацию в случае изменения адресов.

**Методы повышения эффективности ARP**

1. **ARP-прокси**: Этот метод позволяет одному устройству (обычно маршрутизатору) отвечать на ARP-запросы от других устройств для IP-адресов, которые находятся за пределами локальной сети. Это полезно в сценариях с несколькими подсетями или при использовании NAT (Network Address Translation).

2. **Пакеты ARP с несколькими адресами**: Некоторые реализации позволяют запрашивать несколько адресов одновременно, что уменьшает количество широковещательных запросов.

3. **Снижение широковещательных запросов**: Использование статических записей в ARP-кэше для критически важных устройств может снизить количество необходимых запросов.


#### DHCP — протокол динамической настройки хостов

DHCP (Dynamic Host Configuration Protocol) — это **сетевой протокол, который позволяет автоматически назначать IP-адреса и другие параметры конфигурации сетевых устройств (хостов) в локальной сети**. Это упрощает управление сетью, особенно в больших организациях, где количество устройств может быть значительным.

###### Как работает DHCP

DHCP работает по принципу клиент-серверной модели и включает несколько этапов:

1. **Запрос на получение IP-адреса (DHCP Discover)**: Когда устройство (клиент) подключается к сети, оно отправляет широковещательный запрос (DHCP Discover) для поиска доступных DHCP-серверов.

2. **Предложение IP-адреса (DHCP Offer)**: DHCP-серверы, получившие запрос, отвечают широковещательным предложением (DHCP Offer), в котором содержится доступный IP-адрес и другие параметры конфигурации (например, маска подсети, шлюз, DNS-серверы).

3. **Запрос на подтверждение (DHCP Request)**: Клиент выбирает одно из предложений и отправляет запрос (DHCP Request) на подтверждение выбранного IP-адреса.

4. **Подтверждение (DHCP Acknowledgment)**: DHCP-сервер получает запрос и отправляет подтверждение (DHCP Acknowledgment), после чего клиент может использовать назначенный IP-адрес.

Протокол DHCP описан в стандартах RFC 2131 и 2132. Он ==широко применяется в интернете для настройки ряда параметров и приписывания IP-адресов==. Помимо сетей предприятий и домашних сетей, DHCP используют провайдеры. С его помощью они настраивают устройства через интернет-соединение, чтобы абонентам не приходилось узнавать эту информацию у своего провайдера по телефону. Чаще всего с помощью DHCP передается маска сети, IP-адрес шлюза по умолчанию, а также IP-адреса DNS и серверов времени. 

## Коммутация меток и MPLS

MPLS (MultiProtocol Label Switching) — это **технология, используемая для повышения скорости и управляемости передачи данных в сетях**. Она позволяет передавать данные по сети с использованием меток, которые упрощают маршрутизацию и управление трафиком.

#### Как работает MPLS

1. **Создание меток:** Когда пакет данных поступает в сеть MPLS, ему присваивается метка. Эта метка добавляется в новый заголовок MPLS, который помещается перед исходным IP-заголовком пакета. Метка используется для определения пути, по которому пакет будет передан через сеть.

2. **Перенаправление по меткам:** При прохождении через маршрутизаторы MPLS (Label Switch Routers, LSR), пакеты передаются не на основе IP-адреса, а на основе метки. Каждый LSR принимает решение о том, куда отправить пакет, основываясь на значении метки, а не на анализе заголовка IP.

3. **Упрощение маршрутизации:** Поскольку маршрутизаторы работают с метками, а не с полными заголовками пакетов, процесс маршрутизации становится более эффективным. Это позволяет снизить нагрузку на процессоры маршрутизаторов и ускорить передачу данных.

4. **Удаление меток:** Когда пакет достигает конечного пункта назначения или выходит из сети MPLS, заголовок MPLS удаляется, и пакет передается дальше как обычный IP-пакет.

#### Уровень 2.5 в модели OSI

MPLS часто называют протоколом уровня 2.5, что связано с его расположением между сетевым уровнем (уровень 3) и канальным уровнем (уровень 2) модели OSI:

• Почему уровень 2.5?: MPLS **использует адресацию сетевого уровня (например, IP-адреса) для назначения меток, что делает его зависимым от сетевого уровня. Однако он также выполняет функции, характерные для канального уровня, такие как управление трафиком и маршрутизация на основе меток.** Это сочетание функций делает его промежуточным уровнем между двумя этими уровнями.

#### Проблемы MPLS

1. **Добавление заголовка MPLS:** Одной из основных проблем является необходимость добавления нового заголовка MPLS в начало IP-пакета. Поскольку стандартные IP-пакеты не содержат места для хранения информации о метках, MPLS требует создания дополнительного заголовка. Это может увеличить общий размер пакета и повлиять на производительность сети.

2. **Совместимость с существующими протоколами**: MPLS должен быть совместим с различными протоколами и технологиями передачи данных. Это может создать сложности при интеграции MPLS в уже существующие сети.

3. **Сложность конфигурации и управления**: Несмотря на то что MPLS упрощает маршрутизацию, настройка и управление сетями MPLS могут быть сложными задачами, требующими специализированных знаний и навыков.

4. **Безопасность**: MPLS не предоставляет встроенных механизмов безопасности, что может привести к рискам, связанным с перехватом или подменой данных. Дополнительные меры безопасности могут потребоваться для защиты данных в сети MPLS.


## Протокол внутреннего шлюза OSPF

OSPF (Open Shortest Path First) — это **протокол внутридоменной маршрутизации, который используется для обмена маршрутной информацией между маршрутизаторами в одной автономной системе (АС)**. Он был разработан для решения недостатков более старых протоколов, таких как RIP, и стал стандартом для динамической маршрутизации в современных сетях.

#### Причины появления OSPF

1. **Недостатки RIP**: Протокол RIP использует алгоритм векторного расстояния, который имеет ограничения, такие как медленная сходимость и проблемы с счетом до бесконечности. В больших сетях это может привести к неэффективной маршрутизации и временным потерям связи.

2. **Необходимость в более эффективных алгоритмах**: С увеличением размеров сетей возникла необходимость в более сложных и эффективных алгоритмах маршрутизации, способных учитывать различные параметры, такие как задержка, пропускная способность и надежность соединений.

3. **Динамическая адаптация к изменениям**: Современные сети требуют протоколов, которые могут быстро адаптироваться к изменениям топологии, например, при отказах оборудования или изменениях в маршрутах.

4. **Открытость и стандартизация**: Потребность в открытом стандарте, доступном для различных производителей оборудования, была также важной причиной разработки OSPF. Это позволяет избежать зависимости от одного производителя и способствует совместимости между устройствами.


#### Проблемы, которые решает OSPF

1. **Скорость сходимости**: OSPF обеспечивает более быструю сходимость по сравнению с RIP. При изменении топологии сети OSPF быстро обновляет информацию о маршрутах, минимизируя время простоя.

2. **Поддержка больших сетей**: OSPF может эффективно работать в больших и сложных сетях благодаря своей способности разбивать сеть на области (areas) и поддерживать иерархическую структуру маршрутизации.

3. **Учет различных параметров**: OSPF использует метрики, основанные на стоимости (cost), которые могут учитывать различные параметры, такие как пропускная способность и задержка, что позволяет выбирать оптимальные маршруты.

4. **Поддержка мультиплексирования**: OSPF поддерживает различные типы сетевых технологий и протоколов, что делает его универсальным решением для различных сетевых сред.


#### Как работает OSPF

1. **Обнаружение соседей**: Каждый маршрутизатор OSPF отправляет пакеты Hello для обнаружения соседних маршрутизаторов в своей сети. Это позволяет формировать соседние отношения и обмениваться информацией о маршрутах.

2. **Формирование базы данных состояния канала (LSDB)**: Каждый маршрутизатор создает базу данных состояния канала, которая содержит информацию о всех маршрутизаторах и их связях в сети. Эта база данных используется для построения карты топологии сети.

3. **Алгоритм Дейкстры**: OSPF использует алгоритм Дейкстры для вычисления кратчайших путей от каждого маршрутизатора до всех остальных маршрутизаторов в сети на основе информации из LSDB. Это позволяет определять оптимальные маршруты для передачи данных.

4. **Обновление информации о маршрутах**: Когда происходит изменение топологии (например, выход из строя маршрутизатора), OSPF автоматически отправляет обновления другим маршрутизаторам, чтобы они могли обновить свои базы данных и пересчитать маршруты.

5. **Разделение на области**: OSPF поддерживает иерархическую структуру с использованием областей (areas). Это позволяет разбивать большие сети на более мелкие части, что упрощает управление и уменьшает объем трафика обновлений маршрутов.

#### Типы сообщений 

1. Hello  
   Назначение: Сообщения Hello используются для обнаружения соседних маршрутизаторов и поддержания отношений соседства. Эти пакеты отправляются периодически для проверки доступности соседей и обновления информации о состоянии соединений.

2. Link State Update (LSU)  
   Назначение: Сообщения Link State Update содержат информацию о состоянии каналов (link state) и передаются между маршрутизаторами для обновления их баз данных состояния канала (LSDB). Они содержат информацию о маршрутизаторах, их интерфейсах и связях, что позволяет строить полную карту топологии сети.

3. Link State Acknowledgment (LSAck)  
   Назначение: Сообщения Link State Acknowledgment используются для подтверждения получения сообщений Link State Update. Они обеспечивают надежность передачи данных, позволяя отправителю знать, что его информация была успешно получена соседним маршрутизатором.

4. Database Description (DBD)  
   Назначение: Сообщения Database Description содержат краткую сводку о содержимом базы данных состояния канала маршрутизатора. Они используются для обмена информацией о том, какие LSA (Link State Advertisements) есть у маршрутизаторов, чтобы определить, какие обновления необходимо отправить. Это помогает минимизировать объем передаваемой информации при первоначальном обмене данными между соседями.

5. Link State Request (LSR)  
   Назначение: Сообщения Link State Request используются для запроса конкретных LSA от соседних маршрутизаторов. Если маршрутизатор обнаруживает, что у него нет актуальной информации о состоянии канала, он может отправить LSR, чтобы получить недостающие данные.

## Протокол внешнего шлюза BGP

Border Gateway Protocol (BGP) — это **протокол динамической маршрутизации, используемый для обмена маршрутной информацией между автономными системами (AS) в Интернете**. BGP является основным протоколом, который обеспечивает маршрутизацию между различными сетями, и его работа критически важна для функционирования глобальной сети.

#### Основные задачи BGP

1. Обмен маршрутной информацией: BGP позволяет маршрутизаторам обмениваться информацией о доступных маршрутах и их атрибутах, что помогает принимать решения о том, как направлять трафик.

2. Поддержка политик маршрутизации: BGP предоставляет механизмы для реализации сложных политик маршрутизации, которые могут учитывать экономические, политические и другие факторы. Это позволяет операторам сетей гибко настраивать маршруты в соответствии с их требованиями.

3. Обеспечение надежности: BGP поддерживает механизмы для обнаружения и устранения сбоев в сети, что повышает надежность маршрутизации.

#### Стратегии маршрутизации и выбор пути

Выбор маршрута в BGP осуществляется на основе нескольких критериев, которые могут включать:

1. **Локальный приоритет**: Маршруты с наибольшим значением локального приоритета выбираются первыми. Это позволяет администраторам сети задавать предпочтения для определенных маршрутов.

2. **Длина пути AS**: Если несколько маршрутов имеют одинаковый локальный приоритет, выбирается маршрут с наименьшей длиной пути через автономные системы (AS). Это минимизирует количество промежуточных сетей, через которые проходит трафик.

3. **Тип подключения**: Предпочтение отдается маршрутам, полученным через внешние подключения (eBGP), по сравнению с маршрутами, полученными через внутренние подключения (iBGP).

4. **Атрибут MED**: Среди маршрутов от одной и той же соседней AS выбирается маршрут с наименьшим значением атрибута MED (Multiple Exit Discriminator). Этот атрибут указывает предпочтительный выход из AS.

5. **Стоимость пути IGP**: Если все вышеперечисленные критерии равны, выбирается маршрут с наименьшей стоимостью пути IGP к IP-адресу следующего транзитного узла в BGP-маршруте.

#### Политика маршрутизации

Политика маршрутизации в BGP может быть очень индивидуальной и часто не разглашается. Она может включать ограничения, такие как:

• Не передавать коммерческий трафик в образовательные сети.

• Избегать маршрутов, проходящих через определенные географические регионы (например, не передавать трафик Пентагона через Ирак).

• Выбор провайдеров на основе стоимости и производительности (например, использовать TeliaSonera вместо Verizon).

• Ограничения на передачу трафика для определенных компаний (например, трафик Apple не должен проходить через Google).

#### Причины использования BGP

1. Глобальная маршрутизация: BGP является единственным протоколом, способным эффективно управлять маршрутами между различными автономными системами в глобальном масштабе.

2. Гибкость и масштабируемость: BGP поддерживает сложные политики маршрутизации и может масштабироваться для работы с миллионами маршрутов.

3. Устойчивость к сбоям: Протокол обеспечивает автоматическое восстановление после сбоев и поддерживает альтернативные пути для маршрутизации трафика.

4. Контроль трафика: С помощью BGP операторы могут контролировать направление трафика и оптимизировать его в соответствии с бизнес-потребностями.