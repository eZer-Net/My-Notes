
В некоторых, например в оптоволоконных каналах телекоммуникационных сетей, вероятность ошибки крайне низкая, поэтому потеря данных происходит редко.

Но количество ошибок в беспроводных или старых локальных сетях в десятки раз больше, и они даже считаются нормой. Для того чтобы полностью исключить их, потребуются слишком большие расходы с точки зрения производительности.
Поэтому нам необходимо изучить методы их обнаружения и устранения.

Разработчики сетей создали **две основные стратегии для борьбы с ошибками**, основанные на добавлении к передаваемым данным некоторой избыточной информации. 
	В одном случае с ее помощью принимающая сторона может определить, какие данные должны были прийти, 
	в другом — это всего лишь оповещение об ошибке (без указания ее типа), после которого получатель запрашивает повторную передачу.
	
	Первая стратегия  корректирующие коды (error-correcting codes).
    Использование корректирующего кода часто называют упреждающей коррекцией 
    ошибок (Forward Error Correction, FEC). 
	вторая стратегия  коды для обнаружения ошибок (error-detecting codes).

В высоконадежных (например, оптоволоконных) каналах дешевле использовать код для обнаружения ошибок и просто заново передавать поврежденные блоки. А беспроводные соединения, в которых возникает множество ошибок, чаще используют избыточность информации, позволяющей определить, какие данные должны были прийти.

#### **КОРРЕКТИРУЮЩИЕ КОДА**

Коды обнаружения ошибок применяются на канальном, сетевом и транспортном уровнях.
    1. Коды Хэмминга.
	2. Двоичные сверточные коды.
	3. Коды Рида — Соломона.
	4. Коды с малой плотностью проверок на четность.

##### 1. Коды Хэмминга
Коды Хэмминга помогают находить и исправлять ошибки в данных. Они добавляют специальные контрольные биты к сообщениям.
Эти контрольные биты позволяют определить, если в процессе передачи данных произошла ошибка.
	Пример:
		Допустим, у нас есть кодовое слово 10001001. Мы добавляем контрольные биты, и после передачи получаем 10011001. Мы можем проверить, есть ли ошибка, используя контрольные биты.
		Если мы обнаружим, что один бит изменился, то мы можем его исправить.
	Плюсы:
		• Могут исправлять одиночные ошибки и находить двойные.
		• Просты в использовании и понимании.
	Минусы:
		• Не работают хорошо, если ошибок много.
		• Требуют дополнительных битов для контроля (примерно 25% от объема данных).
##### 2. Двоичные сверточные коды
Сверточные коды работают по принципу обработки входящих данных с учетом предыдущих значений. Это позволяет создавать более надежные коды, которые могут исправлять ошибки.
	Пример:
		Представьте, что вы передаете последовательность битов, и каждый новый бит зависит не только от текущего, но и от нескольких предыдущих.
		Если один из битов был поврежден, вы можете использовать информацию о предыдущих битах, чтобы восстановить правильное значение.
	Плюсы:
		Хорошо работают в шумных условиях.
		Эффективны для передачи данных в реальном времени.
	Минусы:
		Сложнее реализовать, чем коды Хэмминга.
		Могут требовать много вычислительных ресурсов.
##### 3. Коды Рида — Соломона
Коды Рида — Соломона — это более сложные коды, которые могут исправлять несколько ошибок одновременно.
Они основаны на математике и используются в различных технологиях, таких как CD и QR-коды.
	Пример:
		Если вы записали данные на диск и некоторые из них были повреждены (например, из-за царапин),
		коды Рида — Соломона могут помочь восстановить потерянные данные, анализируя оставшиеся части информации.
	Плюсы:
		Исправляют множество ошибок.
		Широко используются в реальных приложениях.
	Минусы:
		Сложнее реализовать.
		Требуют больше вычислений для восстановления данных.
##### 4. Коды с малой плотностью проверок на четность (LDPC)
LDPC-коды используют специальные матрицы для проверки данных. Они обеспечивают высокую надежность при передаче информации.
	Пример:
		Представьте себе сетку, где каждая ячейка отвечает за проверку определенных битов. Если один из битов поврежден,
		можно использовать информацию из других ячеек сетки, чтобы найти и исправить ошибку.
	Плюсы:
		Очень эффективны в условиях сильного шума.
		Могут достигать максимальной теоретической производительности.
	Минусы:
		Сложны в реализации и требуют много памяти.
		Нужно много вычислений для исправления ошибок.


#### **КОДЫ ДЛЯ ОБНАРУЖЕНИЯ ОШИБОК**

**три кода для обнаружения ошибок**. Все они относятся к линейным систематическим блочным кодам:
	1. Код с проверкой на четность.
	2. Код с контрольными суммами.
	3. Циклический избыточный код.

##### 1. Код с проверкой на четность
Код с проверкой на четность — это один из самых простых методов обнаружения ошибок. Он добавляет один дополнительный бит (бит четности) к сообщению,
чтобы сделать общее количество единиц четным (или нечетным, в зависимости от выбранного метода).
	Пример:
		Для сообщения 1011, общее количество единиц равно 3 (нечетное). Чтобы сделать его четным, добавляется бит четности 1, и передается 10111.
	Плюсы:
		Простота реализации.
		Низкие затраты на вычисления и память.
	Недостатки:
		 Может обнаружить только нечетное количество ошибок. Если произошла четная ошибка (например, два бита изменились), код не сможет этого выявить.
##### 2. Код с контрольными суммами
Контрольная сумма — это метод, при котором к передаваемым данным добавляется сумма всех битов (или определенных групп битов) для проверки целостности данных.
При получении данных контрольная сумма пересчитывается и сравнивается с переданной.
	Пример:
		Для сообщения 1011 контрольная сумма может быть рассчитана как сумма всех битов:
			 1 + 0 + 1 + 1 = 3.
		Если передать 1011 вместе с контрольной суммой 0011 (в двоичном виде), то получатель может проверить сумму.
	Плюсы:
		Может обнаруживать случайные ошибки и ошибки последовательности.
		Более надежен, чем простой код с проверкой на четность.
	Недостатки:
		Не гарантирует обнаружение всех типов ошибок (например, если происходит изменение нескольких битов, которые в сумме дают ту же контрольную сумму).
##### 3. Циклический избыточный код (CRC)
Циклический избыточный код (CRC) — это более сложный метод обнаружения ошибок, который использует деление полиномов в двоичной арифметике.
Он генерирует контрольную последовательность (CRC), которая прикрепляется к данным перед передачей.
	Пример:
		Для сообщения 1101 и полинома 1011, деление выполняется, и получается остаток, который затем добавляется к сообщению.
	Плюсы:
		Очень эффективен для обнаружения ошибок, особенно в сетевых протоколах и хранилищах данных.
		Может обнаруживать множество типов ошибок, включая все одиночные и двойные ошибки, а также некоторые случаи ошибок с несколькими битами.
		Подходит для аппаратной реализации.
	Недостатки:
		Более сложен в реализации по сравнению с кодами с проверкой на четность и контрольными суммами.