**Процесс** — это экземпляр выполняемой программы. Когда вы запускаете программу, операционная система создает процесс, который включает в себя:
- Код программы (инструкции).
- Данные (переменные, структуры данных).
- Состояние выполнения (регистры процессора, стек, счетчик команд).
- Ресурсы (открытые файлы, сетевые соединения, память).

Процесс — это **основная единица работы** в операционной системе. Каждая программа выполняется в контексте одного или нескольких процессов.

**Аналогии для понимания процессов**

1. Кухня в ресторане:
    - Программа — это рецепт блюда.
    - Процесс — это повар, который готовит блюдо по рецепту.
    - Ресурсы — это ингредиенты и кухонные приборы.


# В Linux существует три основных типа процессов:

   **Процессы переднего плана** (или «интерактивные процессы») — инициализируются и управляются с помощью терминального сеанса. Другими словами, необходимым условием для запуска таких процессов является наличие пользователя, подключенного к системе; они не запускаются автоматически как часть системных функций/служб. Когда команда/процесс выполняется на переднем плане, то они полностью занимают запустивший их терминал. Вы не сможете использовать другие команды, т.к. приглашение оболочки будет недоступно, пока данный процесс выполняется на переднем плане.

   **Фоновые процессы** (или «автоматические процессы») — это процессы, не подключенные к терминалу; они не ожидают пользовательского ввода данных. Таким образом, другие процессы могут выполняться параллельно с процессом, запущенным в фоновом режиме, поскольку им не нужно ждать его завершения.

   **Демоны** (англ. «daemons») — это особый тип фоновых процессов, которые запускаются при старте системы и продолжают работать в виде службы; они не _умирают_. Такие процессы запускаются как системные задачи (службы). Однако при этом они могут управляться пользователем через init-процесс (о котором мы поговорим чуть позже). Например, к демонам относится служба электронных сообщений _sendmail_ и _sshd_ (служба, принимающая от клиентов запросы на соединения по протоколу ssh). За исключением процесса _init_ и некоторых других, процессы демонов обычно имеют окончание `d` в своем имени.

---
## [[Как Linux идентифицирует процессы?]]

Процессы запущенной программы имеют уникальный пятизначный номер 
- ==PID== (сокр. от _«**P**rocess **ID**entificator»_ — _«идентификатор процесса»_), а также 
- ==PPID== (сокр. от _«**P**arent **P**rocess **ID**entificator»_ — _«идентификатор родительского процесса»_). В связи с этим процессы дополнительно разделяют на две группы:

**Родительские процессы** — это процессы, которые во время своего выполнения создают другие процессы.

**Дочерние процессы** — эти процессы, создаваемые другими процессами во время своего выполнения.

---
## Состояния процесса в Linux

Основные состояния процесса:

**Выполнение** — процесс либо запущен (текущий процесс в системе), либо готов к запуску (ожидает передачи на выполнение процессору).

**Ожидание** — процесс ожидает наступления некоторого события (пользовательского ввода, сигнала от другого процесса и т.п.) или выделения системных ресурсов. Кроме того, ядро также различает два типа ожидающих процессов:
- прерываемые ожидающие процессы — могут быть прерваны сигналами;
- непрерываемые ожидающие процессы_— процессы ожидают непосредственно на аппаратном уровне и не могут быть прерваны каким-либо событием/сигналом.

**Завершен** — процесс был остановлен, как правило, путем получения сигнала штатного завершения работы _exit()_.

**Зомби** — иногда, когда родительский процесс убивается до завершения дочернего процесса, дочерние процессы становятся «осиротевшими», при этом в качестве нового родителя (с соответствующим изменением PPID) им назначается процесс init. Убитые процессы, но при этом все еще отображающиеся в таблице процессов, называются процессами **_зомби_** (они мертвы и не используются).

---
## Как получить идентификатор (PID) процесса

Для отображения идентификатора нужного нам процесса можно использовать **команду pidof**, например:
`$ pidof bash`

---
## [[Запуск фонового процесса в Linux]]

Чтобы запустить процесс в фоновом режиме, используйте символ `&` после имени запускаемой программы.
`$ firefox &`

`jobs` - выведет в консоль те запущенные программы которые запускались через консоль

Мы также можем отправить процесс в фоновый режим, приостановив его с помощью сочетания клавиш _Ctrl+Z_.

Чтобы продолжить выполнение вышеупомянутой приостановленной команды в фоновом режиме, используем **команду bg** (от англ. _«**b**e**g**in»_):
`$ bg`

Чтобы отправить фоновый процесс на передний план, используйте **команду fg** (от англ. _«**f**ore**g**round»_) вместе с идентификатором задания следующим образом:
`$ jobs`   
`$ fg %1`

---
## [[Отслеживание активных процессов]]

### Команда ps

Отображает информацию об активных процессах в системе, как показано на следующем скриншоте:
```
$ ps

$ ps -e | head  #(head – фильтр, отображающий только первые 10 строк вывода команды "ps -e")
```
![[Pasted image 20250227135221.png]]

Для получения дополнительной информации о процессах, запущенных текущим пользователем, применяется опция `-f`:
`$ ps -f`
![[Pasted image 20250227135317.png]]
Столбцы, присутствующие в выводе команды `ps`, имеют следующие значения:
   **UID** — идентификатор пользователя, которому принадлежит процесс (тот, от чьего имени происходит выполнение).
   **PID** — идентификатор процесса.
   **PPID** — идентификатор родительского процесса.
   **C** — загрузка CPU процессом.
   **STIME** — время начала выполнения процесса.
   **TTY** — тип терминала, связанного с процессом.
   **TIME** — количество процессорного времени, потраченного на выполнение процесса.
   **CMD** — команда, запустившая этот процесс.

Команда `ps` поддерживает функцию сортировки процессов по соответствующим столбцам. Например, чтобы отсортировать список процессов _по потреблению ресурсов процессора (в порядке возрастания)_, введите команду:
`$ ps -aux --sort=**%cpu**`

### Команда top

**Команда top** отображает информацию о запущенных процессах в режиме реального времени:
`$ top`
![[Pasted image 20250227135659.png]]
Рассмотрим детально:
   **PID** — идентификатор процесса.
   **USER** — пользователь, которому принадлежит процесс.
   **PR** — приоритет процесса на уровне ядра.
   **NI** — приоритет выполнения процесса от `-20` до `19`.
   **VIRT** — общий объем (в килобайтах) виртуальной памяти (физическая память самого процесса; загруженные с диска файлы библиотек; память, совместно используемая с другими процессами и т.п.), используемой задачей в данный момент.
   **RES** — текущий объем (в килобайтах) физической памяти процесса.
   **SHR** — объем совместно используемой с другими процессами памяти.
   **S** (сокр. от _«**S**TATUS»_) — состояние процесса:
   **S** (сокр. от _«**S**leeping»_) — прерываемое ожидание. Процесс ждет наступления события.
   **I** (сокр. от _«**I**dle»_) — процесс бездействует.
   **R** (сокр. от _«**R**unning»_) — процесс выполняется (или поставлен в очередь на выполнение).
   **Z** (сокр. от _«**Z**ombie»_) — зомби-процесс.
   **%CPU** — процент используемых ресурсов процессора.
   **%MEM** — процент используемой памяти.
   **TIME+** — количество процессорного времени, затраченного на выполнение процесса.
   **COMMAND** — имя процесса (команды).

Также в сочетании с основными символами состояния процесса (**S** от _«**S**TATUS»_) вы можете встретить и дополнительные:
   `<` — процесс с высоким приоритетом;
   `N` — процесс с низким приоритетом;
   `l` — многопоточный процесс;
   `+` — фоновый процесс;
   `s` — лидер сессии.

----
## Управление процессами в Linux

Также в Linux присутствуют некоторые **команды для управления процессами**:
- **kill** — посылает процессу сигнал завершения работы;
- **pkill** — завершает процесс по его имени;
- **pgrep** — ищет процесс по его имени (и, опционально, по имени запустившего его пользователя);
- **killall** — завершает все активные процессы.

Ниже приведены несколько основных примеров их использования:
```
$ pgrep -u diego firefox   
$ kill 6516   
$ pgrep -u diego firefox   
$ pgrep -u diego glances   
$ pkill glances   
$ pgrep -u diego glances
```

### Отправка сигналов процессам

Основополагающим способом управления процессами в Linux является отправка им соответствующих сигналов. Для перечисления списка всех доступных сигналов, введите команду:
`$ kill -l`
![[Pasted image 20250227140011.png]]

Чтобы отправить процессу нужный сигнал, используйте команды `kill`, `pkill` или `pgrep`, о которых мы упоминали ранее. Но программы могут реагировать на сигналы только в том случае, если они запрограммированы на распознавание этих сигналов.

Большинство сигналов предназначены для внутреннего использования системой или для программистов, когда они пишут код. Ниже приведены наиболее полезные сигналы:
- **SIGHUP (1)** — отправляется процессу, когда его управляющий терминал закрыт.
- **SIGINT (2)** — отправляется процессу управляющим терминалом, когда пользователь прерывает процесс нажатием клавиш _Ctrl+C_.
- **SIGQUIT (3)** — отправляется процессу, если пользователь посылает сигнал выхода _Ctrl+D_.
- **SIGKILL (9)** — этот сигнал немедленно завершает (убивает) процесс, и процесс не будет выполнять никаких операций очистки за собой.
-  **SIGTERM (15)** — сигнал завершения программы (отправляется командой `kill` по умолчанию).
- **SIGTSTP (20)** — отправляется процессу управляющим терминалом с запросом на остановку; инициируется пользователем нажатием клавиш _Ctrl+Z_.

Ниже приведены примеры команды `kill` для уничтожения приложения `firefox` с помощью PID, после его зависания:
```
$ pgrep -u diego firefox   
2275 #ответ терминала_  
$ kill 9 2275
```
или
`$ kill -KILL 2275`
или
`$ kill -SIGKILL 2275`
Чтобы убить приложение, используя его имя, применяются команды `pkill` или `killall`, например:
`$ pkill firefox`
или
`$ killall firefox`


### Изменение приоритета процесса

В системе Linux все активные процессы имеют определенный приоритет выполнения, задаваемый так называемым _**nice**_-значением. Процессы с более высоким приоритетом обычно получают больше процессорного времени, чем процессы с более низким приоритетом. Однако пользователь с root-правами может повлиять на это с помощью **команд nice** и **renice**.

Узнать значение приоритета команды можно по выводу команды `top` (столбец _NI_):
`$ top`
![[Pasted image 20250227140353.png]]
Используйте команду `nice`, чтобы задать _NI_-значение для запускаемого процесса. ==Имейте в виду, что обычные пользователи могут задавать данный параметр в диапазоне от `0` до `20` тем процессам, которыми они владеют. Только пользователь root может использовать отрицательные значения приоритета.==

==Чем больше nice-значение, тем меньшим приоритетом будет обладать процесс.== Например, вы можете задать приоритет для запускаемого процесса следующим образом:
`$ nice -n 10 firefox`

Чтобы изменить приоритет уже запущенного процесса, используйте команду `renice` следующим образом:
`$ renice +8 5547`
`$ renice +8 1151`

----
## [[Daemon programs]]

Программы действующие в фоновом режиме и выполняют свою работу без участия пользователя.

----

## `/proc`

`/proc` — это виртуальная файловая система в Linux, которая предоставляет информацию о запущенных процессах и состоянии ядра. Она не содержит реальных файлов на диске, а представляет собой интерфейс для взаимодействия с ядром. Каждый запущенный процесс имеет свою директорию в `/proc`, названную по его PID (идентификатору процесса). Например, для процесса с PID 1234 будет создана директория `/proc/1234/`.

**Основные файлы и директории в `/proc`:**
- `/proc/[PID]/` — информация о конкретном процессе.
    - `/proc/[PID]/exe` — символическая ссылка на исполняемый файл процесса.
    - `/proc/[PID]/cwd` — символическая ссылка на текущую рабочую директорию процесса.
    - `/proc/[PID]/fd/` — содержит файловые дескрипторы, открытые процессом.
    - `/proc/[PID]/maps` — отображает память, выделенную процессу.
    - `/proc/[PID]/status` — информация о состоянии процесса (например, UID, GID, состояние выполнения).
    - `/proc/[PID]/environ` — переменные окружения процесса.
    - `/proc/[PID]/cmdline` — командная строка, с которой был запущен процесс.

- `/proc/[PID]/root` — символическая ссылка на корневую директорию процесса (если используется `chroot`).

- `/proc/[PID]/task/` — содержит информацию о потоках (threads) процесса.

- `/proc/[PID]/mem` — виртуальная память процесса (требует прав root для доступа).

----

## **Процесс init и вызовы fork() exec()**

### Определение init

- **init** — это первый процесс, который запускается ядром Linux при загрузке системы. Его PID (Process ID) всегда равен **1**.

- **init** является **родительским процессом** для всех остальных процессов в системе. Если процесс теряет своего родителя (например, родительский процесс завершается), он автоматически "усыновляется" init.


### Почему у init нет родительского процесса?

- Когда система загружается, ядро Linux инициализирует аппаратное обеспечение и запускает init как **первый пользовательский процесс**.

- Поскольку init запускается ядром, у него нет родительского процесса в пользовательском пространстве. Ядро считается его "родителем" на самом низком уровне.

### Роль init в системе

1. **Инициализация системы**:
    - init запускает все необходимые системные сервисы и демоны (например, сетевые службы, планировщик задач, логирование).

2. **Управление процессами**:
    - init отслеживает состояние дочерних процессов.
    
    - Если процесс завершается, init освобождает его ресурсы и предотвращает появление "зомби"-процессов.

3. **Переключение между уровнями выполнения (runlevels)**:
    - init управляет уровнями выполнения системы (например, однопользовательский режим, многопользовательский режим, перезагрузка).

4. **Запуск и остановка служб**:
    - init запускает и останавливает службы в зависимости от уровня выполнения.

### Современные замены init

- В современных дистрибутивах Linux `init` часто заменен на более продвинутые системы инициализации:
    - **systemd**: Наиболее популярная замена `init`, которая предоставляет расширенные возможности управления процессами и службами.

    - **Upstart**: Альтернатива init, разработанная Ubuntu (хотя сейчас Ubuntu также перешла на systemd).

### Что такое fork() и exec()?

#### fork()
- **fork()** — это системный вызов, который создает **дочерний процесс**, являющийся почти точной копией родительского процесса.

- После вызова `fork()`:
    - Родительский и дочерний процессы выполняют один и тот же код.
    - Они отличаются только PID и возвращаемым значением `fork()`:
        - В родительском процессе `fork()` возвращает PID дочернего процесса.
        - В дочернем процессе `fork()` возвращает `0`.

##### Опасности fork():

1. **Утечка ресурсов**:
    - Если родительский процесс не отслеживает дочерние процессы, они могут остаться "зомби" (завершенные, но не удаленные из системы).

2. **Состояние гонки (Race Conditions)**:
    - Если родительский и дочерний процессы пытаются использовать общие ресурсы (например, файлы), это может привести к конфликтам.

3. **Переполнение памяти**:
    - Если процесс создает слишком много дочерних процессов, это может привести к исчерпанию системных ресурсов.

#### **exec()**

- **exec()** — это семейство системных вызовов, которые заменяют текущий образ процесса новым образом (например, запускают другую программу).
    
- После вызова `exec()`:
    - Текущий код процесса заменяется кодом новой программы.
    - PID процесса остается неизменным.
    - Все открытые файлы и ресурсы сохраняются (если не указано иное).

#### **Опасности exec():**

1. **Неправильные аргументы**:
    - Если передать неправильные аргументы в `exec()`, это может привести к запуску непредусмотренных программ.

2. **Утечка ресурсов**:
    - Если процесс не закрывает файлы или сокеты перед вызовом `exec()`, они могут быть унаследованы новой программой.

3. **Уязвимости в целевой программе**:
    - Если программа, запускаемая через `exec()`, содержит уязвимости, это может привести к компрометации системы.

### 3. Как fork() и exec() работают вместе?**

- Обычно `fork()` и `exec()` используются вместе для запуска новых программ:
    1. Процесс вызывает `fork()`, чтобы создать дочерний процесс.
    2. Дочерний процесс вызывает `exec()`, чтобы заменить свой код на код новой программы.
    3. Родительский процесс может продолжать выполнение или ждать завершения дочернего процесса.

### Чем опасны fork() и exec()?

1. **Утечка ресурсов**:
    - Если процессы не освобождают ресурсы (например, память, файловые дескрипторы), это может привести к исчерпанию системных ресурсов.

2. **Состояние гонки (Race Conditions)**:
    - Если процессы неправильно синхронизированы, это может привести к непредсказуемому поведению.

3. **Уязвимости в дочерних процессах**:
    - Если дочерний процесс запускает уязвимую программу через `exec()`, это может привести к компрометации системы.

4. **Зомби-процессы**:
    - Если родительский процесс не обрабатывает завершение дочернего процесса, он может остаться в системе как "зомби".

----
## Зачем нужны дочерние процессы?

Дочерние процессы используются для выполнения задач параллельно или изолированно от родительского процесса. Вот основные причины их использования:

#### 1. Параллельное выполнение задач

- Дочерние процессы позволяют выполнять несколько задач одновременно. Например, веб-сервер может создавать дочерние процессы для обработки запросов от разных клиентов.
#### 2. Изоляция

- Дочерние процессы работают в отдельном адресном пространстве. Если один процесс завершится с ошибкой, это не повлияет на другие процессы.

#### 3. Модульность

- Дочерние процессы могут выполнять специализированные задачи. Например, родительский процесс может управлять логикой приложения, а дочерний — выполнять тяжелые вычисления.

#### 4. Безопасность

- Дочерние процессы могут запускаться с ограниченными правами (например, через `setuid` или `capabilities`), что снижает риски компрометации системы.