
# В Linux существует три основных типа процессов:

   **Процессы переднего плана** (или «интерактивные процессы») — инициализируются и управляются с помощью терминального сеанса. Другими словами, необходимым условием для запуска таких процессов является наличие пользователя, подключенного к системе; они не запускаются автоматически как часть системных функций/служб. Когда команда/процесс выполняется на переднем плане, то они полностью занимают запустивший их терминал. Вы не сможете использовать другие команды, т.к. приглашение оболочки будет недоступно, пока данный процесс выполняется на переднем плане.

   **Фоновые процессы** (или «автоматические процессы») — это процессы, не подключенные к терминалу; они не ожидают пользовательского ввода данных. Таким образом, другие процессы могут выполняться параллельно с процессом, запущенным в фоновом режиме, поскольку им не нужно ждать его завершения.

   **Демоны** (англ. «daemons») — это особый тип фоновых процессов, которые запускаются при старте системы и продолжают работать в виде службы; они не _умирают_. Такие процессы запускаются как системные задачи (службы). Однако при этом они могут управляться пользователем через init-процесс (о котором мы поговорим чуть позже). Например, к демонам относится служба электронных сообщений _sendmail_ и _sshd_ (служба, принимающая от клиентов запросы на соединения по протоколу ssh). За исключением процесса _init_ и некоторых других, процессы демонов обычно имеют окончание `d` в своем имени.

---
## [[Как Linux идентифицирует процессы?]]

Процессы запущенной программы имеют уникальный пятизначный номер 
- ==PID== (сокр. от _«**P**rocess **ID**entificator»_ — _«идентификатор процесса»_), а также 
- ==PPID== (сокр. от _«**P**arent **P**rocess **ID**entificator»_ — _«идентификатор родительского процесса»_). В связи с этим процессы дополнительно разделяют на две группы:

**Родительские процессы** — это процессы, которые во время своего выполнения создают другие процессы.

**Дочерние процессы** — эти процессы, создаваемые другими процессами во время своего выполнения.

---
## Состояния процесса в Linux

Основные состояния процесса:

**Выполнение** — процесс либо запущен (текущий процесс в системе), либо готов к запуску (ожидает передачи на выполнение процессору).

**Ожидание** — процесс ожидает наступления некоторого события (пользовательского ввода, сигнала от другого процесса и т.п.) или выделения системных ресурсов. Кроме того, ядро также различает два типа ожидающих процессов:
- прерываемые ожидающие процессы — могут быть прерваны сигналами;
- непрерываемые ожидающие процессы_— процессы ожидают непосредственно на аппаратном уровне и не могут быть прерваны каким-либо событием/сигналом.

**Завершен** — процесс был остановлен, как правило, путем получения сигнала штатного завершения работы _exit()_.

**Зомби** — иногда, когда родительский процесс убивается до завершения дочернего процесса, дочерние процессы становятся «осиротевшими», при этом в качестве нового родителя (с соответствующим изменением PPID) им назначается процесс init. Убитые процессы, но при этом все еще отображающиеся в таблице процессов, называются процессами **_зомби_** (они мертвы и не используются).

---
## Как получить идентификатор (PID) процесса

Для отображения идентификатора нужного нам процесса можно использовать **команду pidof**, например:
`$ pidof bash`

---
## [[Запуск фонового процесса в Linux]]

Чтобы запустить процесс в фоновом режиме, используйте символ `&` после имени запускаемой программы.
`$ firefox &`

`jobs` - выведет в консоль те запущенные программы которые запускались через консоль

Мы также можем отправить процесс в фоновый режим, приостановив его с помощью сочетания клавиш _Ctrl+Z_.

Чтобы продолжить выполнение вышеупомянутой приостановленной команды в фоновом режиме, используем **команду bg** (от англ. _«**b**e**g**in»_):
`$ bg`

Чтобы отправить фоновый процесс на передний план, используйте **команду fg** (от англ. _«**f**ore**g**round»_) вместе с идентификатором задания следующим образом:
`$ jobs`   
`$ fg %1`

---
## [[Отслеживание активных процессов]]

### Команда ps

Отображает информацию об активных процессах в системе, как показано на следующем скриншоте:
```
$ ps

$ ps -e | head  #(head – фильтр, отображающий только первые 10 строк вывода команды "ps -e")
```
![[Pasted image 20250227135221.png]]

Для получения дополнительной информации о процессах, запущенных текущим пользователем, применяется опция `-f`:
`$ ps -f`
![[Pasted image 20250227135317.png]]
Столбцы, присутствующие в выводе команды `ps`, имеют следующие значения:
   **UID** — идентификатор пользователя, которому принадлежит процесс (тот, от чьего имени происходит выполнение).
   **PID** — идентификатор процесса.
   **PPID** — идентификатор родительского процесса.
   **C** — загрузка CPU процессом.
   **STIME** — время начала выполнения процесса.
   **TTY** — тип терминала, связанного с процессом.
   **TIME** — количество процессорного времени, потраченного на выполнение процесса.
   **CMD** — команда, запустившая этот процесс.

Команда `ps` поддерживает функцию сортировки процессов по соответствующим столбцам. Например, чтобы отсортировать список процессов _по потреблению ресурсов процессора (в порядке возрастания)_, введите команду:
`$ ps -aux --sort=**%cpu**`

### Команда top

**Команда top** отображает информацию о запущенных процессах в режиме реального времени:
`$ top`
![[Pasted image 20250227135659.png]]
Рассмотрим детально:
   **PID** — идентификатор процесса.
   **USER** — пользователь, которому принадлежит процесс.
   **PR** — приоритет процесса на уровне ядра.
   **NI** — приоритет выполнения процесса от `-20` до `19`.
   **VIRT** — общий объем (в килобайтах) виртуальной памяти (физическая память самого процесса; загруженные с диска файлы библиотек; память, совместно используемая с другими процессами и т.п.), используемой задачей в данный момент.
   **RES** — текущий объем (в килобайтах) физической памяти процесса.
   **SHR** — объем совместно используемой с другими процессами памяти.
   **S** (сокр. от _«**S**TATUS»_) — состояние процесса:
   **S** (сокр. от _«**S**leeping»_) — прерываемое ожидание. Процесс ждет наступления события.
   **I** (сокр. от _«**I**dle»_) — процесс бездействует.
   **R** (сокр. от _«**R**unning»_) — процесс выполняется (или поставлен в очередь на выполнение).
   **Z** (сокр. от _«**Z**ombie»_) — зомби-процесс.
   **%CPU** — процент используемых ресурсов процессора.
   **%MEM** — процент используемой памяти.
   **TIME+** — количество процессорного времени, затраченного на выполнение процесса.
   **COMMAND** — имя процесса (команды).

Также в сочетании с основными символами состояния процесса (**S** от _«**S**TATUS»_) вы можете встретить и дополнительные:
   `<` — процесс с высоким приоритетом;
   `N` — процесс с низким приоритетом;
   `l` — многопоточный процесс;
   `+` — фоновый процесс;
   `s` — лидер сессии.

----
## Управление процессами в Linux

Также в Linux присутствуют некоторые **команды для управления процессами**:
- **kill** — посылает процессу сигнал завершения работы;
- **pkill** — завершает процесс по его имени;
- **pgrep** — ищет процесс по его имени (и, опционально, по имени запустившего его пользователя);
- **killall** — завершает все активные процессы.

Ниже приведены несколько основных примеров их использования:
```
$ pgrep -u diego firefox   
$ kill 6516   
$ pgrep -u diego firefox   
$ pgrep -u diego glances   
$ pkill glances   
$ pgrep -u diego glances
```

### Отправка сигналов процессам

Основополагающим способом управления процессами в Linux является отправка им соответствующих сигналов. Для перечисления списка всех доступных сигналов, введите команду:
`$ kill -l`
![[Pasted image 20250227140011.png]]

Чтобы отправить процессу нужный сигнал, используйте команды `kill`, `pkill` или `pgrep`, о которых мы упоминали ранее. Но программы могут реагировать на сигналы только в том случае, если они запрограммированы на распознавание этих сигналов.

Большинство сигналов предназначены для внутреннего использования системой или для программистов, когда они пишут код. Ниже приведены наиболее полезные сигналы:
- **SIGHUP (1)** — отправляется процессу, когда его управляющий терминал закрыт.
- **SIGINT (2)** — отправляется процессу управляющим терминалом, когда пользователь прерывает процесс нажатием клавиш _Ctrl+C_.
- **SIGQUIT (3)** — отправляется процессу, если пользователь посылает сигнал выхода _Ctrl+D_.
- **SIGKILL (9)** — этот сигнал немедленно завершает (убивает) процесс, и процесс не будет выполнять никаких операций очистки за собой.
-  **SIGTERM (15)** — сигнал завершения программы (отправляется командой `kill` по умолчанию).
- **SIGTSTP (20)** — отправляется процессу управляющим терминалом с запросом на остановку; инициируется пользователем нажатием клавиш _Ctrl+Z_.

Ниже приведены примеры команды `kill` для уничтожения приложения `firefox` с помощью PID, после его зависания:
```
$ pgrep -u diego firefox   
2275 #ответ терминала_  
$ kill 9 2275
```
или
`$ kill -KILL 2275`
или
`$ kill -SIGKILL 2275`
Чтобы убить приложение, используя его имя, применяются команды `pkill` или `killall`, например:
`$ pkill firefox`
или
`$ killall firefox`


### Изменение приоритета процесса

В системе Linux все активные процессы имеют определенный приоритет выполнения, задаваемый так называемым _**nice**_-значением. Процессы с более высоким приоритетом обычно получают больше процессорного времени, чем процессы с более низким приоритетом. Однако пользователь с root-правами может повлиять на это с помощью **команд nice** и **renice**.

Узнать значение приоритета команды можно по выводу команды `top` (столбец _NI_):
`$ top`
![[Pasted image 20250227140353.png]]
Используйте команду `nice`, чтобы задать _NI_-значение для запускаемого процесса. ==Имейте в виду, что обычные пользователи могут задавать данный параметр в диапазоне от `0` до `20` тем процессам, которыми они владеют. Только пользователь root может использовать отрицательные значения приоритета.==

==Чем больше nice-значение, тем меньшим приоритетом будет обладать процесс.== Например, вы можете задать приоритет для запускаемого процесса следующим образом:
`$ nice -n 10 firefox`

Чтобы изменить приоритет уже запущенного процесса, используйте команду `renice` следующим образом:
`$ renice +8 5547`
`$ renice +8 1151`

----
## [[Daemon programs]]

программы действующие в фоновом режиме и выполняют свою работу без участия пользователя.


Остановка системы
    halt - используется для немедленной остановки всех процессов и завершения работы системы
    poweroff - завершает работу системы и отключает питание. Это более безопасный способ выключения, чем просто отключение питания
    reboot - перезагружает систему. 
	    Она завершает работу всех процессов и перезапускает операционную систему
    shutdown - используется для безопасного завершения работы системы. 
	    Она позволяет указать время, через которое система будет остановлена, а также отправить уведомления пользователям.
            sudo shutdown now - для немедленного выключения
            sudo shutdown +10 - для выключения через 10 минут
            sudo shutdown -r now - для перезагрузки
            
            sudo shutdown -r +10  - "Система будет перезагружена через 10 минут. 
            Пожалуйста, сохраните свою работу." отправит сообщение всем 
            пользователям и через 10 минут система перезагрузиться




cgroups - это механизм, который позволяет ограничивать, контролировать и изолировать ресурсы (такие как процессор, память, диск и сеть) для групп процессов.
    Создание cgroup:
        mkdir /sys/fs/cgroup/subsystem/cgroup_name
	        subsystem: тип ресурсов, которые вы хотите контролировать (например, cpu, memory).
	        cgroup_name: имя вашей группы.
    Добавление процесса в cgroup:
        echo pid > /sys/fs/cgroup/subsystem/cgroup_name/cgroup.procs
            pid идентификатор процесса, который вы хотите добавить в cgroup.
    Настройка параметров cgroup:
        Например, для ограничения использования памяти:
            echo memory_limit>/sys/fs/cgroup/memory/cgroup_name/memory.limit_in_bytes
	            memory_limit: максимальный объем памяти, который может использовать группа процессов.



 Основные параметры cgroups Типы ресурсов, которые могут быть ограничены механизмом cgroups, таковы.
	1. Устройства (blkio ) — устанавливает лимиты на доступ к запоминающим устройствам (жестким дискам, USB-накопителям и т. д.).
	2. Процессор ( cpu ) — обеспечивает доступ процессов в рамках контрольной группы к CPU.
	3. Учет процессов (cpuacct) — генерирует отчеты об использовании ресурсов процессора. С помощью данной информации можно рассчитать, сколько клиенты должны будут заплатить за объем задействуемой ими вычислительной мощности.
	4. Распределение процессоров (cpuset) — при наличии нескольких процессорных ядер распределяет между ними задачи в рамках контрольной группы.
	5. Доступ к устройствам (devices) — разрешает или блокирует доступ (mknod) к выбранным устройствам.
	6. Приостановка процесса (freezer) — приостанавливает и возобновляет выполнение задач в рамках контрольной группы.
	7. Использование памяти (memory) — управляет выделением памяти для групп процессов и создает отчеты об используемых ресурсах.
	8. Пропускная способность сети (net_cls ) — ограничивает доступ к сети для выбранных задач в рамках контрольной группы. Помечает сетевые пакеты специальной меткой, позволяя идентифицировать порождаемые определенной задачей в рамках контрольной группы.
	9. Сетевой трафик (net_prio) — используется для динамической установки приоритетов по трафику, позволяет администратору изменять приоритеты.
	10. Пространство имен (ns) — разделяет контрольные группы на пространства имен, причем для одной контрольной группы видны только связанные пространства имен. Пространства имен могут включать отдельные таблицы процессов, таблицы монтирования и сетевые интерфейсы.


 cpu: управляет использованием процессора. 
	 cpu.shares: относительная доля времени процессора для группы.
    cpu.cfs_quota_us: максимальное время, которое группа может использовать процессор за определенный период.
    
memory: управляет использованием памяти.
	memory.limit_in_bytes: максимальный объем памяти для группы.
	memory.soft_limit_in_bytes: "мягкий" предел, который не может быть превышен, но система может его игнорировать при наличии свободной памяти.
	
blkio: управляет вводом-выводом на диске.
	blkio.throttle.read_bps_device: ограничение скорости чтения с устройства.
	blkio.throttle.write_bps_device: ограничение скорости записи на устройство.
	
Пример использования
	Если вы хотите создать cgroup для ограничения использования памяти до 512 МБ для процесса с PID 1234, вы можете сделать следующее:
	mkdir /sys/fs/cgroup/memory/my_cgroup
	echo 536870912 > /sys/fs/cgroup/memory/my_cgroup/memory.limit_in_bytes
	echo 1234 > /sys/fs/cgroup/memory/my_cgroup/cgroup.procs