
**cat** - используется для вывода содержимого файлов в стандартный вывод (обычно это консоль) (так же может принимать с ввода клавиатуры текст в файл: cat > файл
(ctrl+d чтоб сохранить)), а также может объединять несколько файлов в один
Параметры для вывода:
	-A - показывает все символы (синоним -vET).
		Пример вывода текста 
			"  Привет мир" 
				"^I Привет  мир$"
	-b - нумерует только непустые строки.
		Пример вывода текста "
			nПриветnмирn" 
				"1  Привет
				2  мир""
	-e - показывает $ в конце строк, игнорируя -n (синоним -vE).
		Пример вывод текста
			 "Приветnмир"
				"Привет$ мир$""
	-E - показывает $ в конце каждой строки.
	-n - нумерует все строки.
		Пример вывода текста 
			"Приветnмир"
				"1  Привет
				2  мир""
	-s - выводит не более одной пустой строки подряд.
		Пример вывода текста 
			"Приветnnnмир"
				"Привет мир""
	-t - показывает невидимые символы (синоним -vT).
		Пример вывода текста 
			"Приветtмир"
				"Привет^Iмир"
	-T - показывает символы табуляции как ^I.
		Пример вывода текста
			 "Приветtмир"
				"Привет^Iмир""
	-u - игнорируется.
	-v - показывает невидимые символы, кроме переводов строк и табуляций.
		Пример вывода текста 
			"Приветnмир"
				"Привет^M
				мир^M""
Примеры:
	cat имя_файла - Вывод содержимого файла
	cat файл1 файл2 > объединенный_файл - Объединение нескольких файлов
	cat > имя_файла - Создание нового файла и ввод текста
	cat >> имя_файла - Добавление текста в существующий файл
	cat -n имя_файла - Вывод с номерами строк
	cat -n файл1 файл2 > объединенный_файл - Объединение и вывод с номерами строк

**sort** - программа сортирует содержимое стандартного ввода или одного или нескольких файлов.
Параметры
	-b - игнорирует начальные пробелы в строках
		Пример:
			sort -b data.txt
	-f - игнорирует регистр при сортировке (например, 'a' и 'A' будут считаться одинаковыми)
		Пример:
			sort -f data.txt
	-n - сортирует строки опираясь на числовые значения в строках
		Пример:
			sort -n numbers.txt
	-r - сортирует в обратном порядке (по убыванию)
		Пример:
			sort -r data.txt
	-k - задает ключ для сортировки, позволяя сортировать по определенному полю в строке
		Пример:
			sort -k 2 data.txt
	-m - объединяет отсортированные файлы, не требуя дополнительной памяти
		Пример:
			sort -m file1.txt file2.txt
	-o - записывает результат сортировки в указанный файл вместо стандартного вывода
		Пример:
			sort -o sorted_data.txt data.txt
	-t - задает разделитель полей, используемый для разбивки строк на поля
		Пример
			sort -t 'n' -k 2 data.txt
	-u - удаляет повторяющие строки

**uniq** - выявление или удаление повторяющихся строк. когда передаётся
отсортированный файл.
	(если файл не отсортирован то не сработает, ищет только если данные повторяющиеся будут следовать друг за другом) она удаляет повторяющиеся строки и выводит результат в стандартный вывод. Важно uniq выводит результат через стандартный вывод (терминал), это значит если надо сохранить результат в файл то надо перенаправить вывод в этот файл.
Параметры:
	-c - вывести список повторяющихся строк и их число найденных дубликатов
	-d - вывести только повторяющиеся, не уникальные строки
	-f число - пропустить 'число' начальных полей в каждой строке.  Деление на поля производится по пробельным символам, как в программе sort (по умолчанию),
	однако команда uniq не имеет альтернатив по настройке деления
	-i - сравнить строки без учёта регистра
	-s число - пропустить 'число' начальных символов в каждой строке
	-u - вывести только уникальные строки. подразумевается по умолчанию

**cut** - удаление фрагментов из всех строк в файлах
Параметры:
	-c список_символов - извлекает фрагмент строки, определяемый список_символов. Список символов может включать один или несколько числовых диапазонов, разделённых запятыми
	-f список_полей - извлекает одно или несколько полей из строки, как определено аргументом список_полей.
	-d 'символ_разделения' - по умолчанию разделитель один символ табуляции, но данный параметр даёт возможность указать любой разделитель
	--complement - извлекает строку текста целиком, кроме фрагментов, определяемых параметромм -с и/или -f

**paste** - слияние строк из файлов

 **join** - объединение строк из двух файлов по общему полю, действует подобно paste но делает это по общему "ключу" Данные должны быть отсортированы по ключевому полю. По умолчанию join использует первое поле (колонку).
Параметры:
	-1 n: Указывает, что ключ для первого файла находится в колонке n. По умолчанию используется первая колонка (1).
		Пример:
			join -1 2 file1.txt file2.txt
				Если file1.txt:
					1 Alice
					2 Bob
					3 Charlie
				и file2.txt:
					1 Smith
					2 Johnson
				Результат будет:
					1 Alice Smith
					2 Bob Johnson
	-2 n: Указывает, что ключ для второго файла находится в колонке n. По умолчанию также используется первая колонка (1).
		Пример:
			join -2 3 file1.txt file2.txt
			Если file1.txt:
				1 Alice
				2 Bob
				3 Charlie
			и file2.txt:
				2 Smith
				3 Johnson
			Результат будет:
				2 Bob Smith
				3 Charlie Johnson
	-o format: Определяет формат вывода. Можно указать, какие поля из обоих файлов будут включены в вывод.
		Пример:
			join -o 0,1.2,2.2 file1.txt file2.txt
			Результат будет:
				2 Bob Johnson
	-t char: Указывает разделитель полей. По умолчанию используется пробел, но можно изменить его на любой другой символ, например, табуляцию или запятую.
		Пример:
			join -t ',' file1.txt file2.txt
				Результат будет:
					2,Bob,Smith
					3,Charlie,Johnson
	-a fileno: Включает все строки из указанного файла (1 или 2), даже если нет совпадений по ключу.
		Пример:
			join -a 1 file1.txt file2.txt
				Результат будет:
					1 Alice
					2 Bob Smith
					3 Charlie Johnson
	-e string: Указывает строку, которая будет выведена вместо пустых полей.
		Пример:
			join -e 'N/A' file1.txt file2.txt
				Результат будет:
					1 Alice N/A
					2 Bob Smith
					3 Charlie Johnson
	-i: Игнорирует регистр при сравнении ключей.
		Пример:
			join -i file1.txt file2.txt
				Если в file1.txt будут ключи в разном регистре, например:
					1 alice
					2 BOB
				и file2.txt:
					1 Smith
					2 johnson
				Результат будет:
					1 alice Smith
					2 BOB johnson
	-v fileno: Выводит строки из указанного файла (1 или 2), которые не имеют совпадений по ключу.
		Пример:
			join -v 2 file1.txt file2.txt
				Результат будет:
					1 Alice
	-r: Объединяет строки в обратном порядке, т.е. сначала строки из второго файла, затем из первого.
		Пример:
			join -r file1.txt file2.txt
				Результат будет:
					2 Johnson Bob
					3 Johnson Charlie

**comm** - построчное сравнение текста двух сортированных файлов
Параметры
	-1 - подавить колонку 1 (строки, уникальные для ФАЙЛ1)
	-2 - подавить колонку 2 (строки, уникальные для ФАЙЛ2)
	-3 - подавить колонку 3 (строки, которые присутствуют в обоих файлах)
	--check-order - проверить, что ввод отсортирован правильно, даже если все строки ввода могут быть сопоставлены
	--nocheck-order - не проверять, что ввод отсортирован правильно
	--output-delimiter=STR - разделить колонки с помощью STR
	--total - вывести сводку
	-z, --zero-terminated - разделитель строк — NUL, а не перевод строки
	--help - отобразить эту справку и выйти
	--version - вывести информацию о версии и выйти

**diff** - построчное сравнение файлов. Подобно программе comm, diff намного более сложный инструмент поддерживающий вывод во многих форматов и способен обрабатывать множество файлов, позволяет рекурсивно обходить файлы. Часто применяют для создания diff-файлов или заплат (patches).
По умолчанию вывод краткое описание
	diff file1.txt file2.txt - команда
		1d0 - строка 1 из file1.txt была удалена в file2.txt.
		< a - строка показывает, что строка "a" присутствует в file1.txt, но отсутствует в file2.txt. Символ "<" указывает на то, что это содержимое первого файла.
		4a4 - строка 4 из file2.txt была добавлена в file1.txt.
		e - строка показывает, что строка "e" присутствует в file2.txt, но отсутствует в file1.txt. Символ ">" указывает на то, что это содержимое второго файла.
Параметры:
	Пример файлов        
		cat test1.txt   a b c d
		cat test2.txt   b c d e
	-c — выводит контекстный формат (context format), который показывает несколько строк контекста вокруг изменений. Это позволяет лучше понять, как изменения вписываются в общий текст.
	Пример: diff -c file1.txt file2.txt
			![[Pasted image 20241212133135.png]]
			*** 1,4 *** - обозначает, что изменения касаются строк с 1 по 4 в test1.txt.
			- a - строка "a" присутствует в test1.txt, но отсутствует в test2.txt. Символ - указывает на удаление.
			b
			c
			! d - строка "d" присутствует в обоих файлах, но с символом !, который может означать, что строка была изменена (например, форматирование или содержание).
			\ В конце файла нет новой строки
			--- 1,4 ---- - обозначает, что изменения касаются строк с 1 по 4 в test2.txt.
			b
			c
			d 
			+ e - строка "e" присутствует только в test2.txt
	-u  — выводит унифицированный формат (unified format), который также включает несколько строк контекста, но в более компактном виде. Это популярный формат для патчей.
    Пример: diff -u file1.txt file2.txt
	        ![[Pasted image 20241212133712.png]]
            --- test1.txt   2024-10-16 15:53:20.959807851 +0500 - указывает на файл test1.txt и время его последнего изменения.
            +++ test2.txt   2024-10-16 15:53:35.607742861 +0500 - указывает на файл test2.txt и время его последнего изменения.
            @@ -1,4 +1,4 @@ - обозначает, что далее будут перечислены изменения. -1,4 указывает, что в test1.txt а потом и в test2.txt изменения касаются строк с 1 по 4.
            -a - строка "a" присутствует в test1.txt, но отсутствует в test2.txt. Символ - указывает на удаление строки.
            b
            c
            +e - строка "e" присутствует только в test2.txt, что означает, что она была добавлена. Симв-u  — выводит унифицированный формат (unified format), который также включает несколько строк контекста, но в более компактном виде. Это популярный формат для патчей.ол + указывает на добавление строки
        Индикаторы
                    (нет) - строка показана для контекста. В ней отсутствуют различия между файлами
                    - - строка отсутствует в 1 файле
                    + - строка пресутствует только в 1 файле
	-r — рекурсивно сравнивает каталоги, позволяя находить различия во всех файлах внутри указанных директорий.
    -i — игнорирует регистр при сравнении строк.
    -w — игнорирует пробелы при сравнении, что полезно для файлов, где форматирование может отличаться, но содержание остается тем же.
    --side-by-side — выводит различия в виде двух колонок, что позволяет визуально сравнить оба файла параллельно.
    --suppress-common-lines — подавляет вывод общих строк при использовании опции --side-by-side.

 path - применение diff файла к оригиналу diff-файлы описывают различия между между предыдущей версией и новой

Преимущество данной команды в том что:
        diff-файлы очень невелик по сравнению с полным деревом исходного текста.
        diff-файл наглядно показывает произведённые изменения

Чтоб подготовить diff-файл для последующего его применения программой path, документация gnu предлагает использовать diff:
    diff -Naur старый_файл новый_файл > diff_файл
        (-N: этот параметр указывает diff рассматривать отсутствующие файлы как пустые. Это полезно, когда один из файлов не существует, и вы хотите увидеть разницу между существующим и несуществующим файлом. -a: этот параметр заставляет diff обрабатывать все файлы как текстовые, даже если они бинарные. Э то может быть полезно, если вы хотите сравнить текстовые представления бинарных файлов. -u: этот параметр выводит различия в "унифицированном" формате, который более читабелен и показывает контекст изменений (несколько строк до и после изменений). -r: этот параметр позволяет рекурсивно сравнивать каталоги, если указаны директории вместо отдельных файлов.)


**tr параметры исходны_данные преобразованные_данные** - перекодирование или удаление символов Перекодирование это процесс изменения символов из одного алфавита символов в другой алфавит.
Примеры:
	echo "lowercase letters" | tr a-z A-Z
	LOWERCASE LETTERS
Множество символов можно выразить 3 способами
		в виде списка ABCD...
		в виде диапазона A-Z
		в виде классов символов POSIX [:upper:]
Параметры:
	-d: Удаляет указанные символы из входного потока.
		Пример: echo "hello" | tr -d 'l'
			heo
	-s: Сжимает последовательные повторяющиеся символы в один.
		Пример: echo "hello   world" | tr -s ' '
			hello world
	-c: Указывает на дополнение к набору символов. Используется для работы с символами, не входящими в указанный набор.
		Пример: echo "hello" | tr -c 'aeiou' 'x'
			xxxxo
	-t: Заменяет указанные символы на соответствующие символы из второго набора. (по умолчанию)
		Пример: echo "abc" | tr 'abc' '123'
			123
 Доп инфа
	ROT13: НЕ САМЫЙ НАДЕЖНЫЙ СПОСОБ ШИФРОВАНИЯ
	Одно забавное применение команды tr — шифрование текста по алгоритму ROT13.
	ROT13 — тривиальный тип шифрования, основанный на простом подстановочном шифре. Шифрованием назвать этот алгоритм можно только с большой натяжкой, скорее
	это алгоритм обфускации (запутывания) текста. Он используется иногда для запутывания потенциально уязвимого содержимого. Метод заключается в простом смещении
	каждого символа на 13 позиций далее по алфавиту. Так как число 13 соответствует
	середине набора из 26 символов, повторное применение алгоритма к тексту приводит
	к его восстановлению в исходное состояние. Шифрование с помощью tr выполняется,
	как показано ниже:
	echo "secret text" | tr a-zA-Z n-za-mN-ZA-M
	frperg grkg
	Повторное применение той же процедуры приводит к обратному преобразованию:
	echo "frperg grkg" | tr a-zA-Z n-za-mN-ZA-M
	secret text
	Многие программы для работы с электронной почтой и чтения новостей Usenet поддерживают шифрование ROT13

**sed опция команда путь/до/файла** - потоковый редактор для фильтрации и
преобразования текста. Позволяет построчно читать информацию, изменять её в
соответствии с заданными командами и выводить результат.
Опции
	-n - Не выводить строки по умолчанию. Используется в сочетании с командами вывода (например, `p`), чтобы контролировать, какие строки будут отображаться.
		Пример
			sed -n 's/apple/orange/p' fruits.txt  # Заменяет "apple" на "orange" и выводит только измененные строки
	-e - Позволяет указать несколько команд для выполнения.
		Пример
			sed -e 's/apple/orange/g' -e 's/banana/kiwi/g' fruits.txt  # Заменяет "apple" на "orange" и "banana" на "kiwi"
	-f - Читает команды из указанного файла.
		Пример
			sed -f команды.sed файл.txt  # Выполняет команды, записанные в файле commands.sed
	-i - Изменяет файл на месте (in-place), без создания резервной копии.
		Пример
			sed -i 's/foo/bar/g' файл.txt  # Заменяет "foo" на "bar" в файле непосредственно
Команды
	's/pattern/replacement/' - Заменяет первое вхождение шаблона pattern на replacement в каждой строке.
		Пример:
			sed 's/old/new/' файл.txt
	'g' - Глобальная замена, заменяет все вхождения шаблона в строке.
		Пример:
			sed 's/old/new/g' файл.txt
	`d` - Удаляет строки, соответствующие шаблону.
		Пример:
			sed '/pattern/d' файл.txt
	`p` - Печатает строки, соответствующие шаблону.
		Пример:
			sed -n '/pattern/p' файл.txt
	`a\` - Добавляет текст после строки.
		Пример:
			sed '2a\new line' файл.txt (добавляет "new line" после второй строки)
	`i\` - Вставляет текст перед строкой.
		Пример:
			sed '2i\new line' файл.txt (вставляет "new line" перед второй строкой)
Использующие sed также часто выбирают
	Программа sed обладает очень широкими возможностями. С ее помощью можно
	решать весьма сложные задачи, связанные с редактированием потока текста. Но
	чаще она используется для выполнения простеньких операций, определение которых укладывается в одну строку. Для решения объемных задач многие предпочитают использовать другие инструменты. Наиболее популярными из них являются awk и perl. Они не относятся к разряду простых инструментов, как программы, обсуждаемые здесь, а являются полноценными языками программирования. perl, например, часто применяется взамен языка командной оболочки для решения многих задач системного администрирования, а также пользуется большой популярностью как средство разработки веб-приложений. awk имеет более узкую область применения. Основное его достоинство заключается в возможности управления табличными данными. Он
	напоминает sed в том смысле, что программы на awk обычно занимаются построчной обработкой текстовых файлов, используя схему, похожую на адреса в sed со следующими за ними операциями. Даже при том, что обсуждение awk и perl выходит за рамки этой книги, они являются отличными инструментами для пользователей командной строки в Linux.


**aspell параметр команда** - интерактивная проверка орфографии
Параметр
	-c - Проверка файла на наличие ошибок.
		Пример:
			aspell -c текст.txt
	-d - Указывает язык словаря (например, en, ru).
		Пример:
			aspell -d ru check текст.txt
	--personal - Указывает пользовательский словарь.
		Пример:
			aspell --personal=мой_словарь.add check текст.txt
	--ignore-case - Игнорировать регистр при проверке.
		Пример:
			aspell --ignore-case check текст.txt
Команда
	list - Выводит список слов, которые не распознаны.
		Пример:
			aspell list < текст.txt
	check - Запускает интерактивную проверку орфографии.
		Пример:
			aspell check текст.txt
	dump - Выводит содержимое словаря.
		Пример:
			aspell dump master
	add - Добавляет слово в пользовательский словарь.
		Пример:
			echo "новое_слово" | aspell add
	create - Создает новый словарь из файла.
		Пример:
			aspell create ./mydictionary < слова.txt


