
`grep <параметр> <регулярное_выражение> <файл>` - поиск и вывод при помощи регулярных выражений или ещё их называют шаблонами
	Параметры
		-i - игнорировать регистр при поиске.
		-v - выводить строки, которые не содержат шаблон, инвертировать условия.
		-c - выводить количество найденных совпадений вместо самих строк.
		-l - выводить только имена файлов, в которых найдено совпадение.
		-L - выводить только имена файлов, в которых не найдено совпадение
		-n - выводить номера строк, где найдено совпадение.
		-r - рекурсивно искать по всем файлам в указанной директории.
		-E - указывает на использование диалекта ERE в POSIX


Регулярные выражения могут содержать как метасимволы так и литералы

Литералы — это обычные символы, которые представляют сами себя.
	a, b, c — ищут соответствующие буквы.
	123 — ищет последовательность цифр.
	!, @, # — ищут соответствующие специальные символы.
	
**Мета символы** — это специальные символы, которые имеют особое значение в контексте регулярных выражений. Они позволяют задавать более сложные условия поиска, такие как диапазоны, повторения и группы. используются в поиске как 'мета символы'
	^ — якорь указывает на начало строки.
			Пример: 
				^кот найдет "кот" только если он стоит в начале строки.
	$ — якорь указывает на конец строки.
			Пример: 
				кот$ найдет "кот" только если он стоит в конце строки.
	. — соответствует любому одному символу (кроме символа новой строки).
			Пример:
				 к.t найдет "кат", "кот", "кит" и т.д.
	[] — задает класс символов. Соответствует любому одному символу из указанных внутри скобок. Мета символы, заключённые в квадратные скобки, теряют свои специальные значения. Лишь символы ^ и - интерпретируются как ^ - обозначает отрицание, - - указывает на диапазон, однако если дефис находится в начале или в конце списка символов, он интерпретируется как обычный символ
			Пример: 
				[кo]от найдет "кот" и "от".
	{n} — соответствует ровно n повторениям предыдущего символа или группы.
			Пример: 
				a{3} найдет "aaa".
	- — используется для указания диапазона а так же символа в зависимости от места нахождения
			Пример: 
				[A-Z] указывает на весь алфавит
	? — соответствует нулю или одному повторению предыдущего символа или группы.
			Пример: 
				ко?t найдет "кот" и "крт".
	* — соответствует нулю или более повторениям предыдущего символа или группы.
			Пример: 
				ко*т найдет "кот", "коот", "кооот" и т.д.
	+ — соответствует одному или более повторениям предыдущего символа или группы.
			Пример: 
				ко+t найдет "кот", "коот", "кооот", но не "крт".
	() - используется для группировки символов или выражений. Позволяет применять к группе мета символы, такие как *, +, ? и другие.
			Пример: 
				^(кот|собака) будет искать в начале либо "кот", либо "собака". если же ^кот|собака то ^ применяется ток к "кот"
	| — логическое "ИЛИ". Соответствует одному из вариантов.
			Пример: 
				кот|собака найдет либо "кот", либо "собака".
	\ - используется для экранирования мета символов, чтобы они воспринимались как обычные символы.
			Пример: 
				. найдет точку, а не любой символ.


Классы символов POSIX
К сожалению диапазон символов не во всех программах поддерживается для частичного решения этой проблемы стандарт posix предусматривает несколько классов символов, описывающие диапазоны символов.
	[:alnum:] - Алфавитно-цифровые символы, эквивалентен диапазона[A-Za-z0-9]
	[:word:] - Сочетание букв, цифр и символа подчеркивания, эквивалентно [A-Za-z0-9_]
	[:alpha:] - Все буквы алфавита, эквивалентно [A-Za-z]
	[:blank:] - Пробелы и символы табуляции, эквивалентно [ t]
	[:cntrl:] - Управляющие символы (например, символы, не отображаемые на экране, такие как возврат каретки)
	[:digit:] - Цифры, эквивалентно [0-9]
	[:graph:] - Все видимые символы, исключая пробел эквивалентно [^[:space:]]
	[:lower:] - Все строчные буквы, эквивалентно [a-z]
	[:punct:] - Знаки препинания (например, ! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [  ] ^ _  { | } ~`)
	[:print:] - Все печатаемые символы, включая пробелы, эквивалентно [^[:cntrl:]]
	[:space:] - Пробелы, символы табуляции и другие пробельные символы (например, n, r, t, f, v)
	[:upper:] - Все заглавные буквы, эквивалентно [A-Z]
	[:xdigit:] - Шестнадцатеричные цифры, эквивалентно [0-9A-Fa-f]

Простые и расширенные регулярные выражения POSIX. Стандарт POSIX также делит реализации регулярных выражений на два вида: 
простые регулярные выражения BRE 
расширенные регулярные выражения ERE.

Отличаются BRE и EREО набором мета символов:
	В диалекте BRE:
		^ — соответствует началу строки.
		$ — соответствует концу строки.
		. — соответствует любому одиночному символу, кроме символа новой строки.
		[] — используется для определения класса символов; соответствует любому из символов, указанных внутри квадратных скобок. Например, [abc] соответствует a, b или c.
		* — соответствует "ноль или более" повторений предыдущего символа или группы.
		Все остальные символы считаются литералами и интерпретируются как сами по себе.
    В ERE (расширенные регулярные выражения) 
	    Мета символы включают в себя те же символы, что и в BRE, но также добавляют несколько дополнительных возможностей. Квантификаторы в регулярных выражениях — это специальные символы, которые определяют количество вхождений предыдущего символа или группы.
	    Квантификаторами являются:
			? — "ноль или одно вхождение"
				Это значит, что символ или группа символов могут быть, а могут и не быть.
				Например, в выражении a?b символ a может присутствовать (тогда будет "ab") или отсутствовать (тогда будет просто "b").
			+ — "одно или более вхождений"
				Это означает, что символ или группа символов должны появиться хотя бы один раз.
				Например, в выражении a+b символ a должен быть, но может повторяться (например, "ab", "aab", "aaab" и т.д.).
			{n} — "точно n вхождений"
				Здесь вы указываете, сколько раз должен появиться символ или группа символов.
				Например, в выражении a{3} должно быть ровно три символа a, то есть "aaa".
			{n,} — "n или более вхождений"
				Это значит, что символ или группа символов могут появляться n раз или больше.
				Например, в выражении a{2,} нужно как минимум два символа a, но может быть и больше, например, "aa", "aaa", "aaaa" и т.д.
			{n,m} — "от n до m вхождений"
				В этом случае вы указываете диапазон: минимальное (n) и максимальное (m) количество вхождений.
				Например, в выражении a{2,4} должно быть от двух до четырех символов a, то есть "aa", "aaa" или "aaaa".
			| — обозначает логическое "ИЛИ", позволяя выбирать между несколькими альтернативами.
		
Таким образом, в ERE мета символы предоставляют более гибкие и мощные способы описания шаблонов, чем в BRE.


Так же есть поиск: файлов с помощью
locate
	Параметры:
		--regexp - позволяет использовать обычные регулярные выражения
			Пример: locate --regexp '.*.txt$'
		--regex - где мета символы, такие как +, ? и {} имеют специальные значения без необходимости экранирования.
			Пример: locate --regex 'data[0-9]+.csv'
поиск текста в vim с less
		Только простые регулярные выражения и для поиска текста можно использовать команду /, после которой следует искомая строка или шаблон пример: /[A-Z][a-z]*
zgrep реализует интерфейс grep искать в жатых файлов
	-E: позволяет использовать расширенные регулярные выражения (ERE), где мета символы, такие как +, ? и {}, имеют специальные значения без необходимости экранирования. Обычные регулярные выражения можно использовать без дополнительных параметров.
		Примеры:
			zgrep -E 'warning|error' logfile.gz
			zgrep 'error' logfile.gz




