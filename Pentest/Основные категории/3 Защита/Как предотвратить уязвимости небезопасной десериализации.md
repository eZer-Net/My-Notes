##### 1. Не десериализовать данные от пользователя вообще
    - Использовать JSON без функций (`json.loads()` вместо `pickle`).

##### 2. Цифровая подпись данных
- Если данные должны приходить от клиента — подписывать их HMAC.

1. Сервер подписывает данные перед отправкой:
```
    data = b'{"user": "guest", "role": "user"}'
    signature = hmac.new(SECRET_KEY, data, hashlib.sha256).hexdigest()
```
2. Отправляет клиенту:
```
{
  "data": "{\"user\": \"guest\", \"role\": \"user\"}",
  "signature": "7a8f9b3c6d5e4f2a1b0c9d8e7f6a5b4c3d2e1f0a9b8c7d6e5f4a3b2c1d0e9f8"
}
```
- Клиент возвращает эти данные обратно (например, в cookie).

3. Злоумышленник пытается подменить `role` на `admin`:
```
{
  "data": "{\"user\": \"hacker\", \"role\": \"admin\"}",
  "signature": "старая_подпись"  # не знает новый HMAC!
}
```

4. Сервер проверяет подпись:
```
received_data = b'{"user": "hacker", "role": "admin"}'
is_valid = verify_hmac(received_data, "старая_подпись")  # False
```
- → Подпись не совпадает! Данные отбрасываются.

##### 3. Белые списки классов
- Разрешать десериализацию только безопасных классов.

#### В общем
В общем, десериализации пользовательского ввода следует избегать, если только это не является абсолютно необходимым. Высокая степень опасности эксплойтов, которые она потенциально допускает, и сложность защиты от них во многих случаях перевешивают преимущества.

Если вам действительно нужно десериализовать данные из ненадежных источников, включите надежные меры, чтобы убедиться, что данные не были подделаны. Например, вы можете реализовать цифровую подпись для проверки целостности данных. Однако помните, что любые проверки должны проводиться **до** начала процесса десериализации. В противном случае они бесполезны.

Если возможно, вам следует избегать использования общих функций десериализации вообще. Сериализованные данные из этих методов содержат все атрибуты исходного объекта, включая закрытые поля, которые потенциально содержат конфиденциальную информацию. Вместо этого вы можете создать свои собственные методы сериализации, специфичные для класса, чтобы вы могли по крайней мере контролировать, какие поля будут раскрыты.

Наконец, помните, что уязвимость заключается в десериализации пользовательского ввода, а не в наличии цепочек гаджетов, которые впоследствии обрабатывают данные. Не полагайтесь на попытки устранить цепочки гаджетов, которые вы идентифицируете во время тестирования. Непрактично пытаться закрыть их все из-за паутины кросс-библиотечных зависимостей, которые почти наверняка существуют на вашем веб-сайте. В любой момент времени публично задокументированные эксплойты повреждения памяти также являются фактором, что означает, что ваше приложение может быть уязвимо в любом случае.