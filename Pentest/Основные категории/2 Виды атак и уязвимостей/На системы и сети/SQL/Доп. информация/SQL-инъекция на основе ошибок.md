SQL-инъекция на основе ошибок относится к случаям, когда вы можете использовать сообщения об ошибках для извлечения или вывода конфиденциальных данных из базы данных, даже в слепом контексте. Возможности зависят от конфигурации базы данных и типов ошибок, которые вы можете вызвать:

- Вы можете заставить приложение возвращать конкретный ответ об ошибке на основе результата логического выражения. Вы можете использовать это так же, как и условные ответы, которые мы рассматривали в предыдущем разделе. Дополнительные сведения см. в разделе Использование слепого внедрения SQL путем вызова условных ошибок.
- Возможно, вы сможете вызывать сообщения об ошибках, которые выводят данные, возвращаемые запросом. Это эффективно превращает слепые уязвимости SQL-инъекций в видимые. Дополнительные сведения см. в разделе Извлечение конфиденциальных данных с помощью подробных сообщений об ошибках SQL.

### Использование слепой SQL-инъекции путем вызова условных ошибок

Некоторые приложения выполняют запросы SQL, но их поведение не меняется, независимо от того, возвращает ли запрос какие-либо данные. Техника, описанная в предыдущем разделе, не будет работать, поскольку введение различных логических условий не влияет на ответы приложения.

Часто можно заставить приложение вернуть другой ответ в зависимости от того, произошла ли ошибка SQL. Вы можете изменить запрос так, чтобы он вызывал ошибку базы данных только в том случае, если условие истинно. Очень часто необработанная ошибка, выданная базой данных, приводит к некоторым изменениям в ответе приложения, например к появлению сообщения об ошибке. Это позволяет вам сделать вывод об истинности введенного состояния.

Чтобы увидеть, как это работает, предположим, что отправлены два запроса, содержащие следующее: `TrackingId` значения cookie по очереди:
```
xyz' AND (SELECT CASE WHEN (1=2) THEN 1/0 ELSE 'a' END)='a 
xyz' AND (SELECT CASE WHEN (1=1) THEN 1/0 ELSE 'a' END)='a
```

Эти входы используют `CASE` ключевое слово для проверки условия и возврата другого выражения в зависимости от того, истинно ли оно:

- При первом вводе `CASE` выражение работает по условию иначе то есть `'a'`, что не вызывает никаких ошибок.
- При втором вводе он работает по условию тогда `1/0`, что вызывает ошибку деления на ноль.

Если ошибка вызывает разницу в HTTP-ответе приложения, вы можете использовать это, чтобы определить, верно ли введенное условие.

Используя этот метод, можно получать данные, проверяя по одному символу за раз:
```
xyz' AND (SELECT CASE WHEN (Username = 'Administrator' AND SUBSTRING(Password, 1, 1) > 'm') THEN 1/0 ELSE 'a' END FROM Users)='a
```
Структура запроса
```
SELECT 
    CASE 
        WHEN (Username = 'Administrator' AND SUBSTRING(Password, 1, 1) > 'm') 
            THEN 1/0
        ELSE 'a' 
    END
FROM Users;
```

Существуют разные способы возникновения условных ошибок, и разные методы лучше всего работают с разными типами баз данных. Более подробная информацию в [шпаргалке по внедрению SQL](https://portswigger.net/web-security/sql-injection/cheat-sheet).

### Пример лабы
[[Лабораторная работа Слепое внедрение SQL с условными ошибками]]


### Извлечение конфиденциальных данных с помощью подробных сообщений об ошибках SQL

Неправильная конфигурация базы данных иногда приводит к появлению подробных сообщений об ошибках. Они могут предоставить информацию, которая может быть полезна злоумышленнику. Например, рассмотрим следующее сообщение об ошибке, которое появляется после добавления одинарной кавычки в `id` параметр:

```
Unterminated string literal started at position 52 in SQL SELECT * FROM tracking WHERE id = '''. Expected char
```

Это показывает полный запрос, созданный приложением с использованием наших входных данных. Мы видим, что в этом случае мы вставляем строку в одинарные кавычки внутри `WHERE` заявление. Это упрощает создание допустимого запроса, содержащего вредоносную полезную нагрузку. Комментирование остальной части запроса не позволит лишней одинарной кавычке нарушить синтаксис.

Иногда мы можем заставить приложение сгенерировать сообщение об ошибке, содержащее некоторые данные, возвращаемые запросом. ==Это эффективно превращает скрытую уязвимость SQL-инъекции в видимую.==

Можно **использовать `CAST()` функция для достижения этой цели. Он позволяет конвертировать один тип данных в другой**. Например запрос, содержащий следующий оператор:
`CAST((SELECT example_column FROM example_table) AS int)`

Часто данные, которые мы пытаемся прочитать, представляют собой строку. Попытка преобразовать это в несовместимый тип данных, например `int`, может вызвать ошибку, подобную следующей:
`ERROR: invalid input syntax for type integer: "Example data"`

Этот тип запроса также может быть полезен, если ограничение на количество символов не позволяет вам инициировать условные ответы.

#### Лаба
[[Лабораторная работа Видимое внедрение SQL на основе ошибок]]