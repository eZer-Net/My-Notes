Если приложение уязвимо для SQL-инъекции и результаты запроса возвращаются в ответах приложения, вы можете использовать метод `UNION` ключевое слово для получения данных из других таблиц в базе данных. Это широко известно как атака UNION с помощью SQL-инъекции.

`UNION` Ключевое слово позволяет вам выполнить одно или несколько дополнительных `SELECT` запросы и добавляйте результаты к исходному запросу. Например:
```
SELECT a, b FROM table1 UNION SELECT c, d FROM table2
```

Этот ==SQL-запрос возвращает один набор результатов с двумя столбцами,== содержащими значения из столбцов. `a` и `b` в `table1` и столбцы `c` и `d` в `table2`.

**Чтобы запрос работал, должны быть выполнены два ключевых требования:**
- Отдельные запросы должны возвращать одинаковое количество столбцов.
	`SELECT a, b FROM table1` и `SELECT c, d FROM table2`

- Типы данных в каждом столбце должны быть совместимы между отдельными запросами.
	 если столбец a — это целое число, то и столбец c тоже должен быть целым числом.

Чтобы выполнить атаку UNION с помощью SQL-инъекции, убедитесь, что ваша атака соответствует этим двум требованиям. Обычно это предполагает выяснение:
- Сколько столбцов возвращается из исходного запроса.
- Какие столбцы, возвращенные из исходного запроса, имеют подходящий тип данных для хранения результатов внедренного запроса.

## Определение количества необходимых столбцов

Когда выполняется атака UNION с помощью SQL-инъекции, **существует два эффективных метода** определения количества столбцов, возвращаемых из исходного запроса.

==Один из методов== предполагает введение серии `ORDER BY` предложений и увеличивать указанный индекс столбца до тех пор, пока не произойдет ошибка. Например, если точка внедрения представляет собой строку в кавычках внутри `WHERE` пункт исходного запроса, вы должны отправить:

`' ORDER BY 1-- ' ORDER BY 2-- ' ORDER BY 3-- etc.`

Эта серия полезных данных изменяет исходный запрос, чтобы упорядочить результаты по разным столбцам в наборе результатов. Столбец в `ORDER BY` Предложение может быть указано по его индексу, поэтому вам не нужно знать имена каких-либо столбцов. Когда указанный индекс столбца превышает количество фактических столбцов в наборе результатов, база данных возвращает ошибку, например:
`The ORDER BY position number 3 is out of range of the number of items in the select list.`

Приложение может фактически вернуть ошибку базы данных в своем HTTP-ответе, но оно также может выдать общий ответ об ошибке. В других случаях он может просто не вернуть никаких результатов. В любом случае, если вы обнаружите некоторую разницу в ответе, вы сможете сделать вывод, сколько столбцов возвращается по запросу.

==Чтобы пробелы не обрезались использовать "+" или кодировать пробел url==

==Второй метод== предполагает отправку серии `UNION SELECT` полезные данные, указывающие разное количество нулевых значений:
```
' UNION SELECT NULL-- 
' UNION SELECT NULL,NULL-- 
' UNION SELECT NULL,NULL,NULL-- 

etc.
```

Если количество нулей не соответствует количеству столбцов, база данных возвращает ошибку, например:
`All queries combined using a UNION, INTERSECT or EXCEPT operator must have an equal number of expressions in their target lists.`

Мы используем `NULL` как значения, возвращаемые из введенного `SELECT` запрос, поскольку типы данных в каждом столбце должны быть совместимы между исходным и внедренным запросами. `NULL` конвертируется в любой общий тип данных, поэтому максимизирует вероятность того, что полезная нагрузка будет успешной, если количество столбцов правильное.

Как и в случае `ORDER BY` При использовании этого метода приложение может фактически вернуть ошибку базы данных в своем ответе HTTP, но может вернуть общую ошибку или просто не вернуть никаких результатов. Когда количество значений NULL соответствует количеству столбцов, база данных возвращает дополнительную строку в наборе результатов, содержащую значения NULL в каждом столбце. Влияние на ответ HTTP зависит от кода приложения. Если вам повезет, вы увидите в ответе дополнительный контент, например дополнительную строку в таблице HTML. В противном случае нулевые значения могут вызвать другую ошибку, например `NullPointerException`. В худшем случае ответ может выглядеть так же, как ответ, вызванный неправильным количеством нулей. Это сделает этот метод неэффективным.

## Поиск столбцов с полезным типом данных

Атака UNION с помощью SQL-инъекции позволяет получить результаты внедренного запроса. Интересные данные, которые вы хотите получить, обычно представлены в строковой форме. Это означает, что вам нужно найти в исходных результатах запроса один или несколько столбцов, тип данных которых совместим со строковыми данными или совместим с ними.

Определив количество необходимых столбцов, вы можете проверить каждый столбец, чтобы проверить, может ли он содержать строковые данные. Вы можете отправить серию `UNION SELECT` полезные данные, которые по очереди помещают строковое значение в каждый столбец. Например, если запрос возвращает четыре столбца, вы должны отправить:
```
' UNION SELECT 'a',NULL,NULL,NULL-- 
' UNION SELECT NULL,'a',NULL,NULL-- 
' UNION SELECT NULL,NULL,'a',NULL-- 
' UNION SELECT NULL,NULL,NULL,'a'--
```

Если тип данных столбца несовместим со строковыми данными, внедренный запрос вызовет ошибку базы данных, например:
`Conversion failed when converting the varchar value 'a' to data type int.`

Если ошибка не возникает и ответ приложения содержит дополнительный контент, включая введенное строковое значение, то соответствующий столбец пригоден для получения строковых данных.

## Использование атаки UNION с помощью SQL-инъекции для получения интересных данных

Когда мы определили количество столбцов, возвращаемых исходным запросом, и выяснили, какие столбцы могут содержать строковые данные, мы сможем получить интересные данные.

Предположим, что:
- Исходный запрос возвращает два столбца, оба из которых могут содержать строковые данные.
- Точка внедрения — это строка в кавычках внутри `WHERE` пункт.
- В базе данных есть таблица с названием `users` с колоннами `username` и `password`.

В этом примере мы можем получить содержимое файла `users` таблицу, отправив входные данные:
`' UNION SELECT username, password FROM users--`

Чтобы выполнить эту атаку, нам нужно знать, что существует таблица с именем `users` с двумя столбцами, называемыми `username` и `password`. Без этой информации нам пришлось бы угадывать названия таблиц и столбцов. Все современные базы данных предоставляют способы изучения структуры базы данных и определения того, какие таблицы и столбцы они содержат.

## Получение нескольких значений в одном столбце

В некоторых случаях запрос может возвращать только один столбец.

Мы можем получить несколько значений вместе в одном столбце, объединив их. Можно включить разделитель, чтобы различать объединенные значения. Например, в Oracle можно отправить входные данные:
`' UNION SELECT username || '~' || password FROM users--`

Здесь используется последовательность двух труб. `||` который является оператором конкатенации строк в Oracle. Внедренный запрос объединяет значения `username` и `password` поля, разделенные `~` характер.

Результаты запроса содержат все имена пользователей и пароли, например:
`... administrator~s3cure wiener~peter carlos~montoya ...`

Разные базы данных используют разный синтаксис для объединения строк. Более подробную информацию можно найти [в шпаргалке по SQL-инъекциям](https://portswigger.net/web-security/sql-injection/cheat-sheet) .

### Пример лабы
[[Лабораторная работа Атака с помощью SQL-инъекции, выведение списка содержимого базы данных в базах данных, отличных от Oracle.]]