
## SSRF с входными фильтрами на основе черного списка

Некоторые приложения блокируют ввод, содержащий имена хостов, например `127.0.0.1` и `localhost`или конфиденциальные URL-адреса, например `/admin`. В этой ситуации часто можно обойти фильтр, используя следующие приемы:

- Использовать альтернативное IP-представление `127.0.0.1`, такой как 
	`2130706433` (10-тичная система), 
	`017700000001` (8-ричная система), 
	`127.1` (опускать нули).

- Зарегистрировать собственное доменное имя, которое разрешается `127.0.0.1`. Мы можем использовать `spoofed.burpcollaborator.net` для этой цели.

- Запутывать заблокированные строки
	использовать кодировку URL, двойную кодировку url 
	изменение регистра (example EXAMPLE ....)

- Указать URL-адрес, которым мы управляем, который перенаправляет на целевой URL-адрес. Попробовать использовать разные коды перенаправления, а также разные протоколы для целевого URL. Например, переключение с `http:` к `https:` 
	Было показано, что URL-адрес во время перенаправления обходит некоторые фильтры против SSRF.

## SSRF с входными фильтрами на основе белых списков

Некоторые приложения допускают только соответствующие входные данные — белый список разрешенных значений. Фильтр может искать совпадение в начале ввода или в нем. Возможно, обойти этот фильтр, воспользовавшись несоответствиями в анализе URL-адресов.

Спецификация URL-адреса содержит ряд функций, которые, вероятно, будут упущены из виду, когда URL-адреса реализуют специальный анализ и проверку с использованием этого метода:

- Можно встроить учетные данные в URL-адрес перед именем хоста, используя `@` характер. Например:
    `https://hack@example.com
	В зависимости от анализатора URL-адресов он может обработать `https://hack` или `https://example.com`

- Можно использовать `#` символ в URL. Например:    
    `https://evil-host#comment`
    `#` - отбрасывает всё то что после неё

- Использовать иерархию имен DNS, чтобы поместить необходимые входные данные в полное DNS-имя, которым мы управляем. Например:
    `https://expected-host.evil-host`

- Закодировать символы URL-адреса, чтобы запутать код анализа URL-адресов. Это особенно полезно, если код, реализующий фильтр, обрабатывает символы в кодировке URL-адреса иначе, чем код, выполняющий внутренний HTTP-запрос. Также можно попробовать символы двойной кодировки; некоторые серверы рекурсивно декодируют URL-адрес получаемых ими входных данных, что может привести к дальнейшим расхождениям.

- Использовать комбинации этих техник вместе.


## Обход фильтров SSRF через открытое перенаправление

Иногда можно обойти защиту на основе фильтров, воспользовавшись уязвимостью открытого перенаправления.

Представим, что в предыдущем примере URL-адрес, отправленный пользователем, строго проверяется, чтобы предотвратить злонамеренное использование поведения SSRF. Однако приложение, URL-адреса которого разрешены, содержит открытую уязвимость перенаправления. При условии, что API, используемый для создания внутреннего HTTP-запроса, поддерживает перенаправления, вы можете создать URL-адрес, который удовлетворяет фильтру и приводит к перенаправлению запроса к желаемой внутренней цели.

Например, приложение содержит открытую уязвимость перенаправления, при которой следующий URL-адрес:
`/product/nextProduct?currentProductId=6&path=http://evil-user.net`

возвращает перенаправление на:
`http://evil-user.net`

Можно использовать уязвимость открытого перенаправления, чтобы обойти фильтр URL-адресов, и использовать уязвимость SSRF следующим образом:
```
POST /product/stock HTTP/1.0 
Content-Type: application/x-www-form-urlencoded 
Content-Length: 118 

stockApi=http://weliketoshop.net/product/nextProduct?currentProductId=6&path=http://192.168.0.68/admin
```

Этот эксплойт SSRF работает, поскольку приложение сначала проверяет, что предоставленный `stockAPI` URL-адрес находится в разрешенном домене, и это так. Затем приложение запрашивает предоставленный URL-адрес, что запускает открытое перенаправление. Он следует за перенаправлением и отправляет запрос на внутренний URL-адрес по выбору злоумышленника.


#### Лаба
[[Лабораторная работа SSRF с обходом фильтра через уязвимость открытого перенаправления]]