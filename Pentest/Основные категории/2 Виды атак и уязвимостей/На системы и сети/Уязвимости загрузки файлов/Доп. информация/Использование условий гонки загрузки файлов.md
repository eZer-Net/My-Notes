Современные фреймворки более защищены от данной атаки. **Обычно они не загружают файлы напрямую в назначенное место на файловой системе.** Вместо этого они принимают меры предосторожности, такие как ==загрузка в временный, изолированный каталог и рандомизация имени файла, чтобы избежать перезаписи существующих файлов==. Затем они выполняют валидацию этого временного файла и только после этого перемещают его в конечное место, когда он считается безопасным.

Тем не менее, **разработчики иногда реализуют собственную обработку загрузки файлов независимо от какого-либо фреймворка**. Это не только довольно сложно сделать правильно, но также может привести к опасным условиям гонки, которые позволяют злоумышленнику полностью обойти даже самую надежную валидацию.

Например, некоторые веб-сайты загружают файл непосредственно в основную файловую систему, а затем снова удаляют его, если он не проходит проверку. Такое поведение типично для веб-сайтов, которые используют антивирусное программное обеспечение и т.п. для проверки на наличие вредоносных программ. Это может занять всего несколько миллисекунд, но в течение того короткого времени, пока файл существует на сервере, злоумышленник потенциально все еще может его выполнить.

Эти уязвимости зачастую чрезвычайно незаметны, что затрудняет их обнаружение во время тестирования «черного ящика», если только вы не найдете способ утечки соответствующего исходного кода.

## Условия гонки при загрузке файлов на основе URL

Подобные условия гонки могут возникнуть в функциях, которые позволяют вам загружать файл, предоставив URL. В этом случае сервер должен принести файл через Интернет и создать локальную копию, прежде чем он сможет выполнить любую проверку.

Поскольку файл загружается с использованием HTTP, разработчики не могут использовать встроенные механизмы своей структуры для надежной проверки файлов. Вместо этого они могут вручную создавать свои собственные процессы для временного хранения и проверки файла, который может быть не таким безопасным.

Например, если файл загружается во временный каталог со случайным именем, теоретически злоумышленник не сможет воспользоваться какими-либо условиями гонки. Если они не знают имени каталога, они не смогут запросить файл, чтобы инициировать его выполнение. С другой стороны, если рандомизированное имя каталога генерируется с использованием псевдослучайных функций, таких как PHP `uniqid()`, потенциально это может быть перебором.

Чтобы ==упростить подобные атаки, можно попытаться увеличить время, необходимое для обработки файла, тем самым удлинив окно для перебора имени каталога==. Один из способов сделать это — загрузить файл большего размера. Если он обрабатывается частями, мы потенциально можем воспользоваться этим, создав вредоносный файл с полезной нагрузкой в ​​начале, за которой следует большое количество произвольных байтов заполнения.