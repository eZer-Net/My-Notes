## Что такое сохраненный межсайтовый скриптинг?

Хранимый межсайтовый скриптинг (также известный как XSS второго порядка или постоянный XSS) возникает, когда приложение получает данные из ненадежного источника и включает эти данные в свои последующие HTTP-ответы небезопасным способом.

Предположим, что веб-сайт позволяет пользователям оставлять комментарии к записям в блоге, которые отображаются для других пользователей. Пользователи оставляют комментарии с помощью HTTP-запроса, например, следующего:
```
POST /post/comment HTTP/1.1 
Host: vulnerable-website.com 
Content-Length: 100 

postId=3&comment=This+post+was+extremely+helpful.&name=Carlos+Montoya&email=carlos%40normal-user.net
```

После отправки этого комментария любой пользователь, посетивший запись в блоге, получит в ответе приложения следующее:
`<p>This post was extremely helpful.</p>`
Если предположить, что приложение не выполняет никакой другой обработки данных, злоумышленник может отправить вредоносный комментарий следующего вида:
`<script>/* Bad stuff here... */</script>`

В запросе злоумышленника этот комментарий будет закодирован в URL следующим образом:
`comment=%3Cscript%3E%2F*%2BBad%2Bstuff%2Bhere...%2B*%2F%3C%2Fscript%3E`

Теперь любой пользователь, посетивший запись в блоге, получит в ответе приложения следующее:
`<p><script>/* Bad stuff here... */</script></p>`

Скрипт, предоставленный злоумышленником, затем будет выполнен в браузере пользователя-жертвы в контексте его сеанса работы с приложением.

# Влияние сохраненных XSS-атак

Если злоумышленник может контролировать скрипт, который выполняется в браузере жертвы, то он, как правило, может полностью скомпрометировать этого пользователя. Злоумышленник может выполнить любые действия, которые применимы к воздействию [[Отраженный XSS#Влияние отраженных XSS-атак|отраженных уязвимостей XSS]] .

С точки зрения эксплуатируемости, ключевое различие между отраженным и сохраненным XSS заключается в том, что **сохраненная уязвимость XSS позволяет проводить атаки, которые являются самодостаточными внутри самого приложения.** Злоумышленнику не нужно искать внешний способ заставить других пользователей сделать определенный запрос, содержащий его эксплойт. Вместо этого злоумышленник помещает свой эксплойт в само приложение и просто ждет, пока пользователи с ним столкнутся.

Самодостаточная природа хранимых эксплойтов межсайтового скриптинга особенно актуальна в ситуациях, когда уязвимость XSS влияет только на пользователей, которые в данный момент вошли в приложение. Если XSS отражается, то атака должна быть удачно рассчитана по времени: пользователь, которого склоняют сделать запрос злоумышленника в то время, когда он не вошел в систему, не будет скомпрометирован. Напротив, если XSS сохраняется, то пользователь гарантированно войдет в систему в момент, когда он столкнется с эксплойтом.

- [Эксплуатация уязвимостей межсайтового скриптинга](https://portswigger.net/web-security/cross-site-scripting/exploiting)


# Сохраненные XSS в разных контекстах

Существует множество различных разновидностей хранимых межсайтовых скриптов. Расположение хранимых данных в ответе приложения определяет, какой тип полезной нагрузки требуется для их эксплуатации, а также может повлиять на воздействие уязвимости.

Кроме того, если приложение выполняет какую-либо проверку или другую обработку данных перед их сохранением или в момент включения сохраненных данных в ответы, это, как правило, влияет на то, какой тип полезной нагрузки XSS необходим.

- #### XSS между тегами HTML
- #### XSS в атрибутах тега HTML
- #### XSS в JavaScript
	Завершение существующего скрипта
	Вырывание строки JavaScript
	Использование HTML-кодирования
	XSS в литералах шаблонов JavaScript
- #### XSS через внедрение шаблона на стороне клиента

### [[Контексты межсайтового скриптинга]]

# Как найти и протестировать сохраненные уязвимости XSS

Множество сохраненных XSS-уязвимостей можно обнаружить с помощью веб-сканеров уязвимостей.

Тестирование на наличие уязвимостей XSS вручную может быть сложным. Необходимо протестировать все соответствующие «точки входа», через которые контролируемые злоумышленником данные могут попасть в обработку приложения, и все «точки выхода», в которых эти данные могут появиться в ответах приложения.

**Точки входа в обработку заявки включают в себя:**
- Параметры или другие данные в строке запроса URL и теле сообщения.
- Путь к файлу URL.
- Заголовки HTTP-запросов, которые могут не поддаваться эксплуатации в отношении отраженного XSS.
- Любые внеполосные маршруты, по которым злоумышленник может доставить данные в приложение. Существующие маршруты полностью зависят от функциональности, реализованной приложением: приложение веб-почты будет обрабатывать данные, полученные в электронных письмах; приложение, отображающее ленту Twitter, может обрабатывать данные, содержащиеся в сторонних твитах; а агрегатор новостей будет включать данные, происходящие с других веб-сайтов.

**Точками выхода для сохраненных XSS-атак являются все возможные HTTP-ответы, которые возвращаются любому пользователю приложения в любой ситуации**.

Первым шагом в тестировании на наличие уязвимостей XSS, хранимых в памяти, является ==обнаружение связей между точками входа и выхода, посредством которых данные, отправленные в точку входа, выдаются из точки выхода==. Причины, по которым это может быть сложным, следующие:
- Данные, отправленные в любую точку входа, в принципе могут быть выданы из любой точки выхода. Например, отображаемые имена, предоставленные пользователем, могут появляться в скрытом журнале аудита, который виден только некоторым пользователям приложения.
- Данные, которые в настоящее время хранятся в приложении, часто уязвимы для перезаписи из-за других действий, выполняемых в приложении. Например, функция поиска может отображать список последних поисков, которые быстро заменяются, когда пользователи выполняют другие поиски.

Для всестороннего определения связей между точками входа и выхода потребуется отдельное тестирование каждой перестановки, отправка определенного значения в точку входа, переход непосредственно к точке выхода и определение того, появляется ли там значение. Однако этот подход непрактичен в приложении с более чем несколькими страницами.

Вместо этого более реалистичным подходом является систематическая работа через точки ввода данных, отправка определенного значения в каждую из них и мониторинг ответов приложения для обнаружения случаев, когда появляется отправленное значение. Особое внимание можно уделить соответствующим функциям приложения, таким как комментарии к сообщениям в блоге. Когда отправленное значение наблюдается в ответе, нужно определить, **действительно ли данные хранятся в разных запросах, а не просто отражаются в немедленном ответе**.

Когда мы определили связи между точками входа и выхода в обработке приложения, каждая связь должна быть специально протестирована, чтобы обнаружить наличие сохраненной уязвимости XSS. Это включает определение контекста в ответе, где появляются сохраненные данные, и тестирование подходящих потенциальных полезных нагрузок XSS, которые применимы к этому контексту. На этом этапе методология тестирования в целом такая же, как и для поиска [[Отраженный XSS|отраженных уязвимостей XSS]].




## XSS-полиглоты
**XSS-полиглотов** это специальные пейлоады, которые могут выполняться в различных контекстах HTML и JavaScript. Они предназначены для обхода фильтров и защиты, которые могут быть установлены на веб-приложении.
```
javascript:/*--></marquee></script></title></textarea></noscript></style></xmp>">[img=1]<img -/style=-=expression&#40&#47;&#42;’/-/*&#39;,/**/eval(name)//&#41;;width:100%;height:100%;position:absolute;behavior:url(#default#VML);-o-link:javascript:eval(title);-o-link-source:current name=alert(1) onerror=eval(name) src=1 autofocus onfocus=eval(name) onclick=eval(name) onmouseover=eval(name) background=javascript:eval(name)//>
```
Существуют множество пейлоадов-полиглотов, которые можно найти в репозиториях, таких как SecLists или [fuzzdb](https://github.com/fuzzdb-project/fuzzdb/blob/master/attack/xss/XSSPolyglot.txt)

## От сигнатурного анализа XSS

вместо `<script>alert('XSS')</script>` использовать конструкцию `\<a onmouseover="alert('XSS')">xss link\</a>` для создания ссылки, при наведении на которую сработает обработчик событий `onmouseover`, выполнив скрипт. Если фильтруется ввод закрывающих тегов, то можно перейти на теги, которые не требуется закрывать, например **<img>**. Если WAF блокирует и закрывающие теги, и теги типа **<img>**, то можно попробовать тег `body`: `<BODY ONLOAD=alert('XSS')>`

Еще один вариант обхода блокировки WAF – методы обфускации пейлоада. Например, используя URL-Encode стандартный пейлоад `<script>alert(XSS)</script>`, можно превратить в `%3Cscript%3Ealert%28XSS%29%3C%2Fscript%3E`.



