Современные веб-приложения обычно создаются с использованием ряда сторонних библиотек и фреймворков, которые часто предоставляют дополнительные функции и возможности для разработчиков. Важно помнить, что некоторые из них также являются потенциальными источниками и стоками для DOM XSS.

### DOM XSS в jQuery
Если используется библиотека JavaScript, например jQuery, нужно обратить внимание на приемники, которые могут изменять элементы DOM на странице. 
Например, `attr()`функция jQuery может изменять атрибуты элементов DOM. Если данные считываются из источника, контролируемого пользователем, например URL, а затем передаются в `attr()`функцию, то может быть возможным манипулировать отправленным значением, чтобы вызвать XSS. Например, здесь у нас есть некоторый JavaScript, который изменяет атрибут элемента привязки, `href`используя данные из URL:
```
$(function() { 
	$('#backLink').attr("href",(new RLSearchParams(window.location.search)).get('returnUrl')); });
```
Можем воспользоваться этим, изменив URL так, чтобы `location.search`источник содержал вредоносный URL JavaScript. После того, как JavaScript страницы применит этот вредоносный URL к обратной ссылке `href`, нажатие на обратную ссылку выполнит ее: `?returnUrl=javascript:alert(document.domain)`

#### Лаба
[[DOM XSS в якорном href атрибуте jQuery, принимающем с использованием location.search]]

Еще одним **потенциальным приемником, на который следует обратить внимание, является селекторная функция jQuery `$()`**, которая может использоваться для внедрения вредоносных объектов в DOM.

jQuery раньше был чрезвычайно популярен, и классическая уязвимость DOM XSS была вызвана веб-сайтами, использующими этот селектор в сочетании с `location.hash`источником для анимации или автоматической прокрутки к определенному элементу на странице. Такое поведение часто реализовывалось с помощью уязвимого `hashchange` обработчика событий, похожего на следующий:

```
// Обработчик события изменения хэша в URL
$(window).on('hashchange', function() {
	var element = $(location.hash); 
	element[0].scrollIntoView(); 
});
```

Так как это `hash`контролируется пользователем, злоумышленник может использовать это для внедрения вектора XSS в `$()`селектор-приемник. Более поздние версии jQuery исправили эту конкретную уязвимость, не позволяя вам внедрять HTML в селектор, когда ввод начинается с символа решетки `#`. 


Чтобы фактически эксплуатировать эту классическую уязвимость, вам нужно найти способ вызвать `hashchange`событие без взаимодействия с пользователем. Один из самых простых способов сделать это — доставить ваш эксплойт через `iframe`:

`<iframe src="https://vulnerable-website.com#" onload="this.src+='<img src=1 onerror=alert(1)>'">`

В этом примере `src`атрибут указывает на уязвимую страницу с пустым значением хеша. Когда `iframe`загружается, к хешу добавляется вектор XSS, что приводит `hashchange`к срабатыванию события.

#### Объяснение

##### Что такое iframe?
iframe (inline frame) — это HTML-элемент, который позволяет вставлять один HTML-документ внутрь другого. Это означает, что вы можете отображать содержимое другого веб-сайта или страницы внутри вашего веб-приложения. Например, вы можете использовать iframe, чтобы встроить видео с YouTube, показать другую страницу вашего сайта или даже загрузить сторонний контент.

Пример использования iframe:
`<iframe src="https://example.com" width="600" height="400"></iframe>`


##### Уязвимость location.hash
location.hash — это часть URL, которая начинается с символа #. Она обычно используется для навигации по страницам (например, для прокрутки к определенному разделу на странице). Однако, так как содержимое hash контролируется пользователем, это может быть уязвимым местом для атак типа XSS (Cross-Site Scripting).

##### Почему важно использовать #?

1. Часть URL: Символ # обозначает начало фрагмента идентификатора (hash) в URL. Все, что после #, не отправляется на сервер, и браузер использует это значение для обработки навигации по странице.
`<iframe src="https://vulnerable-website.com#"` **`onload="this.src+='<img src=1 onerror=alert(1)>'">`**

2. Контекст выполнения: Если веб-приложение использует значение location.hash для выполнения каких-либо действий (например, для выбора элемента на странице или для выполнения JavaScript-кода), злоумышленник может подставить вредоносный код в это значение.

##### Как работает инъекция 

Исходный код инъекции
`<iframe src="https://vulnerable-website.com#" onload="this.src += '<img src=x onerror=alert(1)>'"></iframe>`

**Шаг 1: Загрузка iframe**

- Когда браузер загружает этот iframe, он обращается к URL `https://vulnerable-website.com#`. На этом этапе `#` в URL просто указывает на хэш, который будет обработан на стороне клиента.

**Шаг 2: Обработка события onload**

После того как страница внутри `iframe` загружена, срабатывает событие onload. В результате выполняется следующий код:
`this.src += '<img src=x onerror=alert(1)>'`


**Шаг 3: Изменение src**

Изначально src был `https://vulnerable-website.com#`

После выполнения кода `this.src += '<img src=x onerror=alert(1)>'`, значение `src` становится:
`https://vulnerable-website.com#<img src=x onerror=alert(1)>`

Однако важно отметить, что браузер не обрабатывает этот фрагмент как часть URL. Вместо этого он интерпретирует его как HTML-код, который будет добавлен на страницу.

**Шаг 4: Обработка location.hash**

На стороне страницы `https://vulnerable-website.com`, JavaScript может выглядеть следующим образом:
```
const hash = location.hash.substring(1); // Убираем символ #
if (hash) {
    document.getElementById('content').innerHTML = hash;
}
```


Здесь location.hash будет равно:
`<img src=x onerror=alert(1)>`


После вызова substring(1) мы получаем:
`<img src=x onerror=alert(1)>` 

**Шаг 5: Вставка в HTML**

Теперь этот код вставляется в элемент с id content:
`document.getElementById('content').innerHTML = hash;`

Это приводит к тому, что HTML-код внутри элемента content становится:
`<img src=x onerror=alert(1)>`

**Шаг 6: Срабатывание события onerror**

Когда браузер пытается загрузить изображение по адресу x, оно не существует, и происходит ошибка. Это вызывает срабатывание обработчика события onerror, который выполняет код:
`alert(1)`


#### Лаба
[[Лаборатория dom xss в приёмнике селектора jQuery с использованием хэш -оболочки]]

### DOM XSS в AngularJS

AngularJS, может выполнить JavaScript без угловых скобок или событий. Когда сайт **использует `ng-app`атрибут** в элементе HTML, он будет обработан AngularJS. В этом случае AngularJS выполнит JavaScript внутри двойных фигурных скобок, которые могут встречаться непосредственно в HTML или внутри атрибутов.

##### Атрибуты
Атрибут в HTML — это дополнительная информация, которая добавляется к элементам HTML для определения их свойств или поведения. Атрибуты состоят из имени и значения и обычно записываются в открывающем теге элемента. Например, в следующем коде атрибут src определяет источник изображения:
`<img src="image.jpg" alt="Описание изображения">`

В данном примере:
- src — это имя атрибута, указывающее на путь к изображению.
- alt — это еще один атрибут, который предоставляет текстовое описание изображения, если оно не может быть загружено.

##### AngularJS и атрибуты

В контексте AngularJS атрибуты играют важную роль в связывании данных и управлении поведением приложения. Когда вы используете атрибут ng-app, он указывает AngularJS, что этот элемент и все его дочерние элементы должны быть обработаны AngularJS. Например:
```
<div ng-app="myApp">
    <h1>{{ title }}</h1>
</div>
```

В этом примере ng-app обозначает, что AngularJS должен инициализировать приложение с именем myApp. Внутри двойных фигурных скобок {{ title }} происходит связывание данных, и значение переменной title будет отображено в заголовке.

#### Лаба
[[Лабораторная работа DOM XSS в выражении AngularJS с угловыми скобками и двойными кавычками, закодированными в HTML]]
