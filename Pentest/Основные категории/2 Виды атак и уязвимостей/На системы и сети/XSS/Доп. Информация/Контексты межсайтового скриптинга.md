При тестировании [[Отраженный XSS|отражённые]] и [[Сохранённые XSS|сохранённые]] XSS-атак ключевой задачей является определение контекста XSS:

- Место в ответе, где появляются данные, контролируемые злоумышленником.
- Любая проверка входных данных или другая обработка, выполняемая приложением над этими данными.

На основе этих данных мы можем выбрать один или несколько потенциальных вариантов полезной нагрузки XSS и проверить их эффективность.


**Теги** 
	это строительные блоки HTML-документа. Каждый тег обозначает определенный элемент на странице. Например:
**Атрибуты**
	предоставляют дополнительную информацию о тегах и изменяют их поведение или внешний вид. Атрибуты указываются внутри открывающего тега и имеют следующую структуру: имя="значение". Примеры атрибутов:
**Обработчики событий в веб-разработке**
	это функции, которые выполняются в ответ на определенные события, происходящие на странице, такие как клики мыши, нажатия клавиш, перемещения курсора и другие действия пользователя

#### Примечание
Portswigger создали исчерпывающую [шпаргалку XSS](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet) для помощи в тестировании веб-приложений и фильтров. Мы можем фильтровать по событиям и тегам и видеть, какие векторы требуют взаимодействия с пользователем. Шпаргалка также содержит побеги из песочницы AngularJS и множество других разделов для помощи в исследовании XSS.

# XSS между тегами HTML

Если контекст XSS представляет собой текст между тегами HTML, вам необходимо ввести несколько новых тегов HTML, предназначенных для запуска выполнения JavaScript.

Вот некоторые полезные способы выполнения JavaScript:
```
<script>alert(document.domain)</script>
```
или
```
<img src=1 onerror=alert(1)>
```

#### Лаба
[[Лабораторная работа отражение XSS в HTML-контексте с блокировкой большинства тегов и атрибутов]]

#### Лаба
[[Лабораторная работа отражение XSS в HTML-контексте со всеми заблокированными тегами, кроме пользовательских]]

#### Лаба
[[Лабораторная работа Отраженный XSS с некоторой разрешенной разметкой SVG]]


#### Лаба
[[Лабораторная работа Отражённая XSS с заблокированными обработчиками событий и атрибутами href]]

----
# XSS в атрибутах тега HTML

Когда контекст XSS находится в значении атрибута тега HTML, иногда мы можем завершить значение атрибута, закрыть тег и ввести новый. Например:
```
"><script>alert(document.domain)</script>
```

Чаще всего в этой ситуации угловые скобки блокируются или кодируются, поэтому наш ввод не может выйти за пределы тега, в котором он появляется. При условии, что мы можем завершить значение атрибута, мы обычно можем ввести новый атрибут, который создает контекст для скриптования, например обработчик событий. Например:
```
" autofocus onfocus=alert(document.domain) x="
```
Как это работает
1. Завершение значения атрибута: Символ `"` (двойная кавычка) завершает текущее значение атрибута. Таким образом, если мы можем вставить этот символ, мы можем "выйти" из контекста текущего атрибута.
2. Создание нового атрибута: После завершения текущего значения мы можем добавить новый атрибут, например `onfocus`. Этот атрибут будет содержать JavaScript-код, который выполнится при получении фокуса элементом.
3. Автоматическое срабатывание: Атрибут `autofocus` заставляет элемент автоматически получать фокус при загрузке страницы. Это вызывает событие onfocus, что приводит к выполнению JavaScript-кода (в данном случае `alert(document.domain)`).
4. Корректировка разметки: В конце добавляется `x=`, чтобы "закрыть" элегантно текущий тег корректно и не нарушить структуру HTML.

Иногда контекст XSS находится в типе атрибута тега HTML, который сам по себе может создавать контекст для скриптов. Здесь можно выполнить JavaScript без необходимости завершать значение атрибута. Например, если контекст XSS находится в атрибуте `href`тега-якоря, мы можем использовать `javascript`псевдопротокол для выполнения скрипта. Например:
```
<a href="javascript:alert(document.domain)">
```

Можем также столкнуться с веб-сайтами, которые кодируют угловые скобки, но все равно позволяют внедрять атрибуты. Иногда эти внедрения возможны даже в тегах, которые обычно не запускают события автоматически, таких как канонический тег. Мы можем использовать это поведение, используя клавиши доступа и взаимодействие с пользователем в Chrome. Клавиши доступа позволяют нам предоставлять сочетания клавиш, которые ссылаются на определенный элемент. Атрибут позволяет нам `accesskey`определить букву, которая при нажатии в сочетании с другими клавишами (они различаются на разных платформах) будет вызывать события. [Можем использовать XSS в скрытых полях ввода, используя технику, изобретенную PortSwigger Research](https://portswigger.net/research/xss-in-hidden-input-fields).

#### Лаба
[[Лаборатория: отраженная xss в канонической теге ссылки]]

----
# XSS в JavaScript

Когда контекст XSS представляет собой некоторый существующий JavaScript в ответе, может возникнуть множество ситуаций, для успешного выполнения которых потребуются различные методы.

### Завершение существующего скрипта

В простейшем случае можно просто закрыть тег скрипта, который заключает в себе существующий JavaScript, и ввести несколько новых тегов HTML, которые вызовут выполнение JavaScript. Например, если контекст XSS выглядит следующим образом:
`<script> ... var input = 'controllable data here'; ... </script>`

то мы можем использовать следующую полезную нагрузку, чтобы выйти за рамки существующего JavaScript и выполнить свой собственный:
`</script><img src=1 onerror=alert(document.domain)>`

Причина, по которой это работает, заключается в том, что браузер сначала выполняет парсинг HTML для идентификации элементов страницы, включая блоки скрипта, и только потом выполняет парсинг JavaScript для понимания и выполнения встроенных скриптов. Вышеуказанная полезная нагрузка оставляет исходный скрипт сломанным, с незавершенным строковым литералом. Но это не мешает последующему скрипту парситься и выполняться обычным образом.

### Вырывание строки JavaScript

В случаях, когда контекст XSS находится внутри заключенного в кавычки строкового литерала, часто можно вырваться из строки и выполнить JavaScript напрямую. Важно исправить скрипт, следующий за контекстом XSS, поскольку любые синтаксические ошибки там не позволят выполнить весь скрипт.

Вот несколько полезных способов выхода из строкового литерала:
```
'-alert(document.domain)-' 
';alert(document.domain)//
```

Некоторые приложения пытаются предотвратить выход ввода за пределы строки JavaScript, экранируя любые символы одинарных кавычек обратной косой чертой. Обратная косая черта перед символом сообщает парсеру JavaScript, что символ следует интерпретировать буквально, а не как специальный символ, такой как терминатор строки. В этой ситуации приложения часто совершают ошибку, не экранируя сам символ обратной косой черты. Это означает, что злоумышленник может использовать свой собственный символ обратной косой черты, чтобы нейтрализовать обратную косую черту, добавленную приложением.

Например, предположим, что входные данные:
`';alert(document.domain)//`
преобразуется в:
`\';alert(document.domain)//`

Теперь вы можете использовать альтернативную полезную нагрузку:
`\';alert(document.domain)//`
который преобразуется в:
`\\';alert(document.domain)//`

Здесь первый обратный слеш означает, что второй обратный слеш интерпретируется буквально, а не как специальный символ. Это означает, что кавычка теперь интерпретируется как терминатор строки, и поэтому атака успешна.

Некоторые веб-сайты затрудняют XSS, ограничивая символы, которые нам разрешено использовать. Это может быть на уровне веб-сайта или путем развертывания WAF, который предотвращает попадание наших запросов на веб-сайт. В таких ситуациях нужно поэкспериментировать с другими способами вызова функций, которые обходят эти меры безопасности. Один из способов сделать это — использовать `throw`оператор с обработчиком исключений. Это позволяет передавать аргументы функции без использования скобок. Следующий код назначает функцию `alert()`глобальному обработчику исключений, а `throw`оператор передает `1`обработчику исключений (в данном случае `alert`). Конечным результатом является то, что `alert()`функция вызывается с `1`аргументом.

`onerror=alert;throw 1`

Существует несколько способов использования этой техники для вызова [функций без скобок](https://portswigger.net/research/xss-without-parentheses-and-semi-colons) .

### Использование HTML-кодирования
Когда контекст XSS представляет собой некоторый существующий JavaScript внутри атрибута тега в кавычках, например обработчик событий, можно использовать HTML-кодирование для обхода некоторых входных фильтров.

Когда браузер проанализировал теги и атрибуты HTML в ответе, он выполнит HTML-декодирование значений атрибутов тегов, прежде чем они будут обработаны дальше. Если серверное приложение блокирует или очищает определенные символы, необходимые для успешного использования XSS, вы часто можете обойти проверку ввода, закодировав эти символы в HTML.

Например, если контекст XSS выглядит следующим образом:
`<a href="#" onclick="... var input='controllable data here'; ...">`

и приложение блокирует или экранирует символы одинарных кавычек, вы можете использовать следующую полезную нагрузку, чтобы вырваться из строки JavaScript и выполнить свой собственный скрипт:
`&apos;-alert(document.domain)-&apos;`

Последовательность `&apos;`представляет собой HTML-сущность, представляющую апостроф или одинарную кавычку. Поскольку браузер HTML-декодирует значение атрибута `onclick`до того, как интерпретируется JavaScript, сущности декодируются как кавычки, которые становятся разделителями строк, и поэтому атака оказывается успешной.
`'-alert(document.domain)-'`

### XSS в литералах шаблонов JavaScript
Шаблонные литералы JavaScript — это строковые литералы, которые позволяют встраивать выражения JavaScript. Встроенные выражения оцениваются и обычно объединяются в окружающий текст. Шаблонные литералы заключаются в обратные кавычки вместо обычных кавычек, а встроенные выражения идентифицируются с помощью синтаксиса `${...}`.

Например, следующий скрипт выведет приветственное сообщение, включающее отображаемое имя пользователя:
``document.getElementById('message').innerText = `Welcome, ${user.displayName}.`;``

Когда контекст XSS находится в литерале шаблона JavaScript, нет необходимости завершать литерал. Вместо этого нам просто нужно использовать `${...}`синтаксис для встраивания выражения JavaScript, которое будет выполнено при обработке литерала. Например, если контекст XSS выглядит следующим образом:
``<script> ... var input = `controllable data here`; ... </script>``

то можно использовать следующую полезную нагрузку для выполнения JavaScript без завершения литерала шаблона:
`${alert(document.domain)}`

# XSS через внедрение шаблона на стороне клиента

Некоторые веб-сайты используют клиентскую шаблонную инфраструктуру, например AngularJS, для динамического рендеринга веб-страниц. Если они встраивают пользовательский ввод в эти шаблоны небезопасным образом, злоумышленник может внедрить свои собственные вредоносные шаблонные выражения, которые запускают атаку XSS.

- [Внедрение шаблона на стороне клиента](https://portswigger.net/web-security/cross-site-scripting/contexts/client-side-template-injection)