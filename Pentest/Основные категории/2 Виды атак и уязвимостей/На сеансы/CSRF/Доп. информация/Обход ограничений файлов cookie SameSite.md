SameSite — это механизм безопасности браузера, который определяет, когда файлы cookie веб-сайта включаются в запросы, исходящие с других веб-сайтов. Ограничения файлов cookie SameSite обеспечивают частичную защиту от различных межсайтовых атак, включая CSRF, межсайтовые утечки и некоторые эксплойты CORS.

С 2021 года Chrome применяется `Lax` Ограничения SameSite по умолчанию, если веб-сайт, выдающий файлы cookie, явно не устанавливает собственный уровень ограничений. Это означает, что куки будут отправляться только в тех случаях, когда запросы происходят с того же сайта (первичного источника) или в некоторых безопасных условиях, таких как переход по ссылке.

## Что такое сайт в контексте файлов cookie SameSite?

В контексте ограничений файлов cookie SameSite сайт определяется как домен верхнего уровня ([[Служба имён доменов DNS#5.1 **Сервер TLD (Top-Level Domain) имеет разновидности generic Top Level Domain, gTLD и country code Top Level Doman, ccTLD.**|TLD]]), обычно что-то вроде `.com` или `.net`, плюс один дополнительный уровень доменного имени. Его часто называют TLD+1.

При определении того, относится ли запрос к тому же сайту, также учитывается схема URL-адресов. Это означает, что ссылка с `http://app.example.com` к `https://app.example.com` большинством браузеров рассматривается как межсайтовый.
![[Pasted image 20250122164041.png]]

## В чем разница между сайтом и источником?

Разница между сайтом и источником заключается в их сфере действия; сайт включает в себя несколько доменных имен, тогда как источник включает только одно. Хотя они тесно связаны, важно не использовать эти термины как взаимозаменяемые, поскольку их объединение может иметь серьезные последствия для безопасности.

Считается, что два URL-адреса имеют одно и то же происхождение, если они имеют одну и ту же схему, имя домена и порт. Хотя порт часто выводится из схемы.
![[Pasted image 20250122164429.png]]


Как видно из этого примера, термин «сайт» гораздо менее конкретен, поскольку он учитывает только схему и последнюю часть доменного имени. Важно отметить, что это означает, что запрос между источниками может по-прежнему относиться к одному и тому же сайту, но не наоборот.

|   |   |   |   |
|---|---|---|---|
|**Запрос от**|**Запрос на**|**Тот же сайт?**|**Одного происхождения?**|
|`https://example.com`|`https://example.com`|Да|Да|
|`https://app.example.com`|`https://intranet.example.com`|Да|Нет: несовпадающее доменное имя.|
|`https://example.com`|`https://example.com:8080`|Да|Нет: несовпадающий порт|
|`https://example.com`|`https://example.co.uk`|Нет: несовпадающий eTLD|Нет: несовпадающее доменное имя.|
|`https://example.com`|`http://example.com`|Нет: несовпадающая схема|Нет: несовпадающая схема|

Это важное различие, поскольку оно означает, что любая уязвимость, позволяющая произвольное выполнение JavaScript, может быть использована для обхода защиты сайта на других доменах, принадлежащих тому же сайту.

## Как работает SameSite?

До того, как был введен механизм SameSite, браузеры отправляли файлы cookie при каждом запросе к домену, который их выдал, даже если запрос был инициирован несвязанным сторонним веб-сайтом. SameSite позволяет браузерам и владельцам веб-сайтов ограничивать те межсайтовые запросы, если таковые имеются, которые должны включать определенные файлы cookie. Это может помочь снизить подверженность пользователей атакам CSRF, которые побуждают браузер жертвы выдавать запрос, который запускает вредоносное действие на уязвимом веб-сайте. Поскольку для этих запросов обычно требуется файл cookie, связанный с сеансом аутентификации жертвы, атака потерпит неудачу, если браузер не включит его.

Все основные браузеры в настоящее время поддерживают следующие уровни ограничений SameSite:

- `Strict` - Полное ограничение на кросс-доменные запросы

- `Lax` - Ограничение на кросс-доменные запросы, но разрешает их при переходе по ссылкам

- `None` - Полное разрешение на кросс-доменные запросы, требует HTTPS

Разработчики могут вручную настроить уровень ограничения для каждого установленного ими файла cookie, что дает им больше контроля над использованием этих файлов cookie. Для этого им просто нужно включить `SameSite` атрибут в `Set-Cookie` заголовок ответа вместе с предпочтительным значением:

`Set-Cookie: session=0F8tgdOhi9ynR1M9wa3ODa; SameSite=Strict`

Хотя это обеспечивает некоторую защиту от CSRF-атак, ни одно из этих ограничений не обеспечивает гарантированного иммунитета

#### Strict
Если файл cookie установлен с помощью `SameSite=Strict` атрибут, браузеры не будут отправлять его в межсайтовых запросах. Проще говоря, это означает, что если целевой сайт для запроса не соответствует сайту, отображаемому в данный момент в адресной строке браузера, он не будет включать файл cookie.

Это рекомендуется при установке файлов cookie, которые позволяют их носителю изменять данные или выполнять другие конфиденциальные действия, например, доступ к определенным страницам, которые доступны только аутентифицированным пользователям.

Хотя это наиболее безопасный вариант, он может негативно повлиять на взаимодействие с пользователем в тех случаях, когда желательна межсайтовая функциональность ([[Анализ API|API]] [[OAuth]] [[Всемирная паутина#**CORS**|CORS]]).

#### Lax
Ограничения SameSite означают, что браузеры будут отправлять файлы cookie в межсайтовых запросах, но только если выполняются оба следующих условия:

- В запросе используется `GET` метод.

- Запрос возник в результате навигации пользователя на верхнем уровне, например нажатия на ссылку.

Это означает, что файл cookie не включен в межсайтовый `POST` запросы, например. Как `POST` запросы обычно используются для выполнения действий, которые изменяют данные или состояние (по крайней мере, в соответствии с передовой практикой), они с гораздо большей вероятностью станут целью атак CSRF.

Аналогичным образом, файл cookie не включается в фоновые запросы, например, инициированные сценариями, iframe или ссылками на изображения и другие ресурсы.

#### None
Если файл cookie установлен с помощью `SameSite=None` атрибут, это фактически полностью отключает ограничения SameSite, независимо от браузера. В результате браузеры будут отправлять этот файл cookie во всех запросах к сайту, который его выдал, даже в тех, которые были инициированы совершенно несвязанными сторонними сайтами.

За исключением Chrome, это поведение по умолчанию, используемое большинством браузеров, если нет. `SameSite` Атрибут предоставляется при настройке файла cookie.

Существуют законные причины для отключения SameSite, например, когда файл cookie предназначен для использования из стороннего контекста и не предоставляет носителю доступ к каким-либо конфиденциальным данным или функциям. Типичным примером являются файлы cookie для отслеживания.

При установке файла cookie с `SameSite=None`, веб-сайт также должен включать `Secure` атрибут, который гарантирует, что файлы cookie отправляются только в зашифрованных сообщениях через HTTPS. В противном случае браузеры отклонят файл cookie, и он не будет установлен.

`Set-Cookie: trackingId=0F8tgdOhi9ynR1M9wa3ODa; SameSite=None; Secure`

## Обход ограничений SameSite Lax с помощью GET-запросов

На практике серверы не всегда заботятся о том, получают ли они `GET` или `POST` запросить данную конечную точку, даже те, которые ожидают отправки формы. Если они также используют `Lax` ограничения для своих файлов cookie сеанса, явные или из-за настроек браузера по умолчанию, вы все равно сможете выполнить CSRF-атаку, вызвав `GET` запрос из браузера жертвы.

Пока запрос включает в себя навигацию верхнего уровня, браузер все равно будет включать файл cookie сеанса жертвы. Ниже приведен один из самых простых подходов к запуску такой атаки:
```
<script> document.location = 'https://vulnerable-website.com/account/transfer-payment?recipient=hacker&amount=1000000'; </script>
```

Даже если обычный `GET` запрос не разрешен, некоторые платформы предоставляют способы переопределения метода, указанного в строке запроса. Например, Symfony поддерживает `_method` параметр в формах, который имеет приоритет над обычным методом для целей маршрутизации:

```
<form action="https://vulnerable-website.com/account/transfer-payment" method="POST"> 
	<input type="hidden" name="_method" value="GET"> 
	<input type="hidden" name="recipient" value="hacker"> 
	<input type="hidden" name="amount" value="1000000"> </form>
```

Другие платформы поддерживают множество подобных параметров.

#### Лаба
[[Лабораторная работа Обход SameSite Lax через переопределение метода]]