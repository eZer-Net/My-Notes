Некоторые уязвимости, которые могут возникнуть в механизмах многофакторной аутентификации. Многие веб-сайты полагаются исключительно на однофакторную аутентификацию с использованием пароля для аутентификации пользователей. Однако некоторые требуют, чтобы пользователи подтверждали свою личность, используя несколько факторов аутентификации.

Все чаще можно увидеть как обязательную, так и необязательную двухфакторную аутентификацию (2FA), основанную на **том, что вы знаете** и **что у вас есть** . Обычно для этого пользователям требуется ввести как традиционный пароль, так и временный код проверки с внешнего физического устройства, находящегося в их распоряжении.

Хотя иногда злоумышленник может получить один фактор, основанный на знаниях, например пароль, возможность одновременно получить другой фактор из внешнего источника значительно менее вероятна. По этой причине двухфакторная аутентификация явно более безопасна, чем однофакторная аутентификация. Однако, ==как и любая мера безопасности, она настолько безопасна, насколько безопасна ее реализация.== Плохо реализованную двухфакторную аутентификацию можно обойти или даже полностью обойти, как и однофакторную аутентификацию.

**Также стоит отметить, что все преимущества многофакторной аутентификации достигаются только за счет проверки нескольких различных факторов.** Проверка одного и того же фактора двумя разными способами не является настоящей двухфакторной аутентификацией. 
	2FA на основе электронной почты — один из таких примеров. Хотя пользователь должен предоставить пароль и код подтверждения, доступ к коду зависит только от того, что он знает учетные данные для входа в свою учетную запись электронной почты. Таким образом, фактор аутентификации знаний просто проверяется дважды.

## Токены двухфакторной аутентификации

Коды проверки обычно считываются пользователем с какого-либо физического устройства. Многие веб-сайты с высоким уровнем безопасности теперь предоставляют пользователям специальное устройство для этой цели, такое как токен RSA или клавиатурное устройство, которое вы можете использовать для доступа к своему онлайн-банкингу или рабочему ноутбуку. Эти специализированные устройства не только созданы специально для обеспечения безопасности, но и имеют то преимущество, что они напрямую генерируют код проверки. По той же причине веб-сайты также часто используют специальное мобильное приложение, такое как **Google Authenticator.**

С другой стороны, некоторые веб-сайты отправляют коды подтверждения на мобильный телефон пользователя в виде текстового сообщения. Хотя технически это все еще проверка фактора «что-то, что у вас есть», он открыт для злоупотреблений. 
	Во-первых, код передается по SMS, а не генерируется самим устройством. Это создает вероятность перехвата кода. Также существует риск подмены SIM-карты, когда злоумышленник обманным путем получает SIM-карту с номером телефона жертвы. Затем злоумышленник получит все SMS-сообщения, отправленные жертве, включая сообщение, содержащее код подтверждения.

----
## Обход двухфакторной аутентификации

Иногда реализация двухфакторной аутентификации ошибочна до такой степени, что ее можно полностью обойти.

**Если пользователю сначала предлагается ввести пароль, а затем на отдельной странице предлагается ввести код подтверждения, пользователь фактически находится в состоянии «вошел в систему» ​​до того, как ввел код подтверждения.** В этом случае стоит проверить, можете ли вы сразу перейти на страницы «только для входа» после завершения первого шага аутентификации. Иногда вы обнаружите, что веб-сайт на самом деле не проверяет, выполнили ли вы второй шаг перед загрузкой страницы.

## Неверная логика двухфакторной проверки

Иногда ошибочная логика двухфакторной аутентификации означает, что после того, как пользователь выполнил начальный шаг входа в систему, веб-сайт не может должным образом проверить, что тот же пользователь выполняет второй шаг.

Например, пользователь входит в систему со своими обычными учетными данными на первом этапе следующим образом:
```
POST /login-steps/first HTTP/1.1 
Host: vulnerable-website.com ... 
username=carlos&password=qwerty
```

Затем им назначается файл cookie, относящийся к их учетной записи, прежде чем они переходят ко второму этапу процесса входа в систему:
```
HTTP/1.1 200 OK 
Set-Cookie: account=carlos 

GET /login-steps/second HTTP/1.1 
Cookie: account=carlos
```

При отправке кода подтверждения запрос использует этот файл cookie, чтобы определить, к какой учетной записи пользователь пытается получить доступ:
```
POST /login-steps/second HTTP/1.1 
Host: vulnerable-website.com 
Cookie: account=carlos ... 
verification-code=123456
```
В этом случае злоумышленник может войти в систему, используя свои учетные данные, но затем изменить значение `account` cookie на любое произвольное имя пользователя при отправке кода подтверждения.
```
POST /login-steps/second HTTP/1.1 
Host: vulnerable-website.com 
Cookie: account=victim-user ... 
verification-code=123456
```

Это чрезвычайно опасно, если злоумышленник затем сможет подобрать проверочный код, поскольку это позволит ему входить в произвольные учетные записи пользователей, полностью основываясь на их имени пользователя. Им даже не понадобится знать пароль пользователя.

## Коды проверки методом перебора 2FA

Как и в случае с паролями, веб-сайты должны принять меры для предотвращения перебора кода проверки 2FA. Это особенно важно, поскольку код часто представляет собой простое 4- или 6-значное число. Без адекватной защиты от перебора взломать такой код тривиально.

Некоторые веб-сайты пытаются предотвратить это, автоматически выходя из системы пользователя, если он вводит определенное количество неверных кодов подтверждения. На практике это неэффективно, поскольку продвинутый злоумышленник может даже автоматизировать этот многоэтапный процесс, создав макросы для Burp Intrumer. Для этой цели также можно использовать расширение Turbo Intrumer.

#### Лаба
[[Лабораторная работа Сломанная логика 2FA]]
