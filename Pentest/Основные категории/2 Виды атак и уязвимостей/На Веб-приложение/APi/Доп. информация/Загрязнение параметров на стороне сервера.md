
Некоторые системы содержат внутренние API, к которым нет прямого доступа из Интернета. Загрязнение параметров на стороне сервера происходит, когда веб-сайт встраивает пользовательский ввод в запрос на стороне сервера к внутреннему API без адекватного кодирования. Это означает, что злоумышленник может манипулировать параметрами или вводить их, что позволит им, например:

- Переопределить существующие параметры.
- Измените поведение приложения.
- Доступ к несанкционированным данным.

==Уязвимыми могут быть параметры запроса, поля формы, заголовки и параметры URL-адреса==

## Тестирование на загрязнение параметров на стороне сервера в строке запроса

Чтобы проверить наличие загрязнения параметров на стороне сервера в строке запроса, можно поместить символы синтаксиса запроса, например `#`, `&`, и `=` в своем вводе и наблюдать, как реагирует приложение.

Рассмотрим уязвимое приложение, позволяющее искать других пользователей по их имени. Когда мы ищем пользователя, наш браузер делает 
следующий запрос:  `GET /userSearch?name=peter&back=/home`

Чтобы получить информацию о пользователе, сервер запрашивает внутренний API со следующим запросом: `GET /users/search?name=peter&publicProfile=true`
#### Усечение строк запроса
Можно использовать [[ URL-кодировки|URL-кодированный]] ==символ `#` , чтобы закодировать его тем самым попытаться обрезать запрос на стороне сервера.==

Например, изменить строку запроса на следующую:
`GET /userSearch?name=peter`**`%23`**`foo&back=/home`

Интерфейсная часть попытается получить доступ к следующему URL-адресу:
`GET /users/search?name=peter#foo&publicProfile=true`
Всё что после # (%23) не обрабатывается

Просмотрите ответ, чтобы узнать, был ли запрос усечен. Например, если ответ возвращает пользователя `peter`, запрос на стороне сервера мог быть усечен.
	Если `Invalid name` возвращается сообщение об ошибке, возможно, приложение обработало `foo` как часть имени пользователя. Это говорит о том, что запрос на стороне сервера, возможно, не был усечен.

Если мы можем усечь запрос на стороне сервера, это устраняет необходимость в `publicProfile` поле должно быть установлено в значение true. Возможно, можно использовать это для возврата закрытых профилей пользователей.
#### Вставка недопустимых параметров
Можно использовать URL-кодированный ==`&`символ, чтобы попытаться добавить второй параметр к серверному запросу.==

Например, изменить строку запроса следующим образом:
`GET /userSearch?name=peter`**`%26`**`foo=xyz&back=/home`

Это приводит к следующему серверному запросу к внутреннему API:
`GET /users/search?name=peter&foo=xyz&publicProfile=true`

Просмотрите ответ на предмет подсказок о том, как анализируется дополнительный параметр. Например, если ответ не изменился, это может означать, что параметр был успешно внедрен, но проигнорирован приложением.

Чтобы составить более полную картину, нам необходимо провести дополнительные испытания.
#### Ввод допустимых параметров
Если нам удалось изменить строку запроса, то можно попытаться добавить второй допустимый параметр в запрос на стороне сервера.

Например, если мы определили `email`параметр, то можно добавить его в строку запроса следующим образом: `GET /userSearch?name=peter`**`%26`**`email=foo&back=/home`

Это приводит к следующему серверному запросу к внутреннему API:
`GET /users/search?name=peter&email=foo&publicProfile=true`

Просмотрите ответ на предмет подсказок о том, как анализируется дополнительный параметр.
#### Переопределение существующих параметров
Чтобы подтвердить, уязвимо ли приложение к загрязнению параметров на стороне сервера, мы можем попробовать переопределить исходный параметр. Внедрив второй параметр с тем же именем.

Например, можно изменить строку запроса следующим образом:
`GET /userSearch?name=peter%26name=carlos&back=/home`

Это приводит к следующему серверному запросу к внутреннему API:
`GET /users/search?name=peter&name=carlos&publicProfile=true`

Внутренний API интерпретирует два `name`параметра. ==Влияние этого зависит от того, как приложение обрабатывает второй параметр. Это различается в зависимости от различных веб-технологий. Например:==

- PHP анализирует только последний параметр. Это приведет к поиску пользователем `carlos`.

- ASP.NET объединяет оба параметра. Это приведет к поиску пользователем `peter,carlos`, что может привести к `Invalid username`сообщению об ошибке.

- Node.js / express анализирует только первый параметр. Это приведет к поиску пользователя `peter`, что даст неизменный результат.

Если мы можем переопределить исходный параметр, то можно провести эксплойт. Например, добавить `name=administrator`к запросу. Это может позволить войти в систему как администратор.

Аналогичный пример, но где пользовательский ввод на стороне клиента находится в данных JSON. Когда мы редактируете свое имя, ваш браузер отправляет следующий запрос:
```
POST /myaccount 
{"name": "peter"}
```

Это приводит к следующему запросу на стороне сервера:
```
PATCH /users/7312/update 
{"name":"peter"}
```

Мы можем попытаться добавить `access_level` параметр запроса следующим образом:
```
POST /myaccount 
{"name": "peter\",\"access_level\":\"administrator"}
```

Если пользовательский ввод декодируется, а затем добавляется к данным JSON на стороне сервера без адекватного кодирования, это приводит к следующему запросу на стороне сервера:
```
PATCH /users/7312/update 
{"name":"peter","access_level":"administrator"}
```
Опять же, это может привести к тому, что пользователь `peter` получить доступ администратора.

==В ответах также может происходить внедрение структурированного формата.== Например, это может произойти, если вводимые пользователем данные надежно хранятся в базе данных, а затем внедряются в ответ JSON от внутреннего API без адекватного кодирования. Обычно можно обнаружить и использовать внедрение структурированного формата в ответах так же, как и в запросах.

#### Лаба
[[Лабораторная работа Использование загрязнения параметров на стороне сервера в строке запроса]]

## Тестирование на предмет загрязнения параметров на стороне сервера в путях REST

RESTful API может размещать имена параметров и значения в пути URL, а не в строке запроса. Например, рассмотрим следующий путь:
`/api/users/123`

Путь URL можно разбить следующим образом:
- `/api`является корневой конечной точкой API.
- `/users`в данном случае представляет собой ресурс `users`.
- `/123`представляет собой параметр, в данном случае идентификатор конкретного пользователя.

Пример приложения, которое позволяет редактировать профили пользователей на основе их имени пользователя. Запросы отправляются на следующую конечную точку:
`GET /edit_profile.php?name=peter`

В результате на стороне сервера будет выполнен следующий запрос:
`GET /api/private/users/peter`

Злоумышленник может манипулировать параметрами пути URL на стороне сервера, чтобы эксплуатировать API. Чтобы проверить эту уязвимость, добавим последовательности обхода пути для изменения параметров и наблюдаем, как реагирует приложение.

Мы можем отправить URL-кодированное значение `peter/../admin`в качестве значения параметра `name`:
`GET /edit_profile.php?name=peter%2f..%2fadmin`

Это может привести к следующему запросу на стороне сервера:
`GET /api/private/users/peter/../admin`

Если серверный клиент или внутренний API нормализуют этот путь, он может быть разрешен как `/api/private/users/admin`.

## Тестирование на предмет загрязнения параметров на стороне сервера в структурированных форматах данных

Злоумышленник может манипулировать параметрами, чтобы использовать уязвимости в обработке сервером других структурированных форматов данных, таких как JSON или XML. Чтобы проверить это, введём неожиданные структурированные данные в пользовательские входные данные и посмотрим, как отреагирует сервер.

Рассмотрим приложение, которое позволяет пользователям редактировать свой профиль, а затем применяет свои изменения с помощью запроса к API на стороне сервера. Когда мы редактируем свое имя, наш браузер делает следующий запрос:
`POST /myaccount name=peter`

В результате на стороне сервера будет выполнен следующий запрос:
`PATCH /users/7312/update {"name":"peter"}`

Мы можем добавить `access_level`параметр в запрос следующим образом:
`POST /myaccount name=peter","access_level":"administrator`

Если пользовательский ввод добавляется к данным JSON на стороне сервера без адекватной проверки или очистки, это приводит к следующему запросу на стороне сервера:
`PATCH /users/7312/update {name="peter","access_level":"administrator"}`

В результате пользователю может `peter`быть предоставлен доступ администратора.

**О том, как определить параметры, которые можно вставить в строку запроса, см. в разделе [[Поиск скрытых параметров API|Поиск скрытых параметров]].**

Аналогичный пример, но где клиентский пользовательский ввод представлен в виде данных JSON. Когда мы редактируем свое имя, наш браузер делает следующий запрос:
```
POST /myaccount 

{"name": "peter"}
```

В результате на стороне сервера будет выполнен следующий запрос:
`PATCH /users/7312/update {"name":"peter"}`

Мы можем попытаться добавить `access_level`параметр в запрос следующим образом:

```
POST /myaccount 
{"name": "peter\",\"access_level\":\"administrator"}
```

Если пользовательский ввод декодируется, а затем добавляется к данным JSON на стороне сервера без адекватного кодирования, это приводит к следующему запросу на стороне сервера:
`PATCH /users/7312/update {"name":"peter","access_level":"administrator"}`

Опять же, это может привести к тому, что пользователю `peter`будут предоставлены права администратора.

В ответах также может происходить внедрение структурированного формата. Например, это может произойти, если пользовательский ввод надежно хранится в базе данных, а затем встраивается в ответ JSON из API бэкэнда без адекватного кодирования. Обычно вы можете обнаружить и использовать внедрение структурированного формата в ответах так же, как и в запросах.