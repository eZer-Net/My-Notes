
Уязвимости CSRF обычно возникают из-за неправильной проверки токенов CSRF.

Некоторые приложения правильно проверяют токен, когда запрос использует метод POST, но пропускают проверку, когда используется метод GET.

В этой ситуации злоумышленник может переключиться на метод GET, чтобы обойти проверку и провести CSRF-атаку:
```
GET /email/change?email=pwned@evil-user.net HTTP/1.1 

Host: vulnerable-website.com 
Cookie: session=2yQIDcpia41WrATfjPqvm9tOkDvkMvLm
```


## Проверка токена CSRF от наличия токена

Некоторые приложения правильно проверяют токен, когда он присутствует, но пропускают проверку, если токен опущен.

В этой ситуации можно удалить весь параметр, содержащий токен (а не только его значение), чтобы обойти проверку и провести CSRF-атаку:
```
POST /email/change HTTP/1.1 
Host: vulnerable-website.com 
Content-Type: application/x-www-form-urlencoded 
Content-Length: 25 
Cookie: session=2yQIDcpia41WrATfjPqvm9tOkDvkMvLm 

email=pwned@evil-user.net
```

## Токен CSRF не привязан к сеансу пользователя

Некоторые приложения не проверяют принадлежность токена тому же сеансу, что и пользователь, отправляющий запрос. Вместо этого приложение поддерживает глобальный пул выпущенных им токенов и принимает любой токен, который появляется в этом пуле.

В этой ситуации можно войти в приложение, используя свою собственную учетную запись, получить действительный токен, а затем передать этот токен пользователю-жертве в своей CSRF-атаке.
Пример атаки:
```
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://0add008d04f864ec80d308af00520073.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="test&#64;mail&#46;ru" />
      <input type="hidden" name="csrf" value="UioocFoaSEHrZLGKxKhTV1MjKniXlrd9" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      history.pushState('', '', '/');
      document.forms[0].submit();
    </script>
  </body>
</html>
```
## Токен CSRF привязан к внесеансовому файлу cookie.

Некоторые приложения привязывают токен CSRF к файлу cookie, но не к тому же файлу cookie, который используется для отслеживания сеансов.

Это может легко произойти, если приложение использует две разные платформы: одну для обработки сеансов и одну для защиты CSRF, которые не интегрированы друг с другом:
```
POST /email/change HTTP/1.1 
Host: vulnerable-website.com 
Content-Type: application/x-www-form-urlencoded Content-Length: 68 
Cookie: session=pSJYSScWKpmC60LpFOAHKixuFuM4uXWF; csrfKey=rZHCnSzEp8dbI6atzagGoSYyqJqTz5dv 

csrf=RhV7yQDO0xcq9gLEah2WVbmuFqyOq7tY&email=wiener@normal-user.com
```

Если веб-сайт содержит какое-либо поведение, позволяющее злоумышленнику установить файл cookie в браузере жертвы, то атака возможна. Злоумышленник может войти в приложение, используя свою собственную учетную запись, получить действительный токен и связанный с ним файл cookie, использовать поведение настройки файлов cookie для размещения своего файла cookie в браузере жертвы и передать свой токен жертве в ходе атаки CSRF.

##### Лаба
[[Лабораторная работа CSRF, где токен привязан к внесеансовому файлу cookie]]

## Токен CSRF просто дублируется в файле cookie.

Еще одна разновидность предыдущей уязвимости: некоторые приложения не ведут серверной записи выданных токенов, а вместо этого дублируют каждый токен в файле cookie и параметре запроса. Когда последующий запрос подтверждается, приложение просто проверяет, что токен, отправленный в параметре запроса, соответствует значению, отправленному в файле cookie. Иногда это называют защитой от CSRF «двойной отправки», и ее рекомендуют, поскольку ее легко реализовать и она позволяет избежать необходимости какого-либо состояния на стороне сервера:

```
POST /email/change HTTP/1.1 
Host: vulnerable-website.com 
Content-Type: application/x-www-form-urlencoded 
Content-Length: 68 Cookie: session=1DQGdzYbOJQzLP7460tfyiv3do7MjyPw; csrf=R8ov2YBfTYmzFyjit8o2hKBuoIjXXVpa 

csrf=R8ov2YBfTYmzFyjit8o2hKBuoIjXXVpa&email=wiener@normal-user.com
```

В этой ситуации злоумышленник может снова выполнить CSRF-атаку, если веб-сайт содержит какие-либо функции настройки файлов cookie. Здесь злоумышленнику не нужно получать собственный действительный токен. Они просто изобретают токен (возможно, в необходимом формате, если он проверяется), используют поведение настройки файлов cookie для размещения своего файла cookie в браузере жертвы и передают свой токен жертве в ходе атаки CSRF.

##### Лаба
[[Лабораторная работа CSRF, где токен дублируется в файле cookie]]