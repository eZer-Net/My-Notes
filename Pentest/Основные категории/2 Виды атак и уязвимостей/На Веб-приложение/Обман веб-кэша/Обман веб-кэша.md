Обман [[Pentest/Термины#Веб-кэш (веб-кеш, web cache)|веб-кэша]] — это уязвимость, которая позволяет злоумышленнику обмануть веб-кэш, заставив его хранить конфиденциальный, динамический контент. Это вызвано расхождениями между тем, как сервер кэша и исходный сервер обрабатывают запросы.

==Использовать расширения [[Создание атаки с использованием веб-кэша#Примечание Использование кэш-блокировщика|Param miner]].== 
Пример Poc: 
- `<script>document.location="https://sait.ru/my-account/wcd.js"</script>`

# [[Суть уязвимости веб-кэша]]

В атаке с обманом веб-кэша злоумышленник убеждает жертву посетить вредоносный URL-адрес, побуждая браузер жертвы сделать двусмысленный запрос на конфиденциальный контент. Кэш неверно интерпретирует это как запрос на статический ресурс и сохраняет ответ. Затем злоумышленник может запросить тот же URL-адрес, чтобы получить доступ к кэшированному ответу, получив несанкционированный доступ к личной информации.

#### Примечание
Важно различать обман веб-кэша и отравление веб-кэша. Хотя оба используют механизмы кэширования, они делают это по-разному:
- **Отравление веб-кэша манипулирует ключами кэша**, чтобы внедрить вредоносный контент в кэшированный ответ, который затем передается другим пользователям.
- **Обман веб-кэша использует правила кэширования**, чтобы обмануть кэш и заставить его хранить конфиденциальную или личную информацию, к которой злоумышленник затем может получить доступ.


### Веб-кэши
Веб-кэш — это система, которая находится между исходным сервером и пользователем. Когда клиент запрашивает статический ресурс, запрос сначала направляется в кэш. ==Если кэш не содержит копии ресурса (это называется промахом кэша)==, запрос пересылается на исходный сервер, который обрабатывает запрос и отвечает на него. Затем ответ отправляется в кэш перед отправкой пользователю. ==Кэш использует предварительно настроенный набор правил для определения того, следует ли сохранять ответ.==

### Кэш-ключи
Когда кэш получает HTTP-запрос, он должен решить, есть ли кэшированный ответ, который он может обслужить напрямую, или он должен переслать запрос на исходный сервер. ==Кэш принимает это решение, генерируя «ключ кэша» из элементов HTTP-запроса. Обычно это включает в себя путь URL и параметры запроса, но он также может включать в себя множество других элементов, таких как заголовки и тип контента.==

Если ключ кэша входящего запроса совпадает с ключом предыдущего запроса, кэш считает их эквивалентными и выдает копию кэшированного ответа.

### Правила кэширования
Правила кэширования определяют, что может кэшироваться и как долго. Правила кэширования часто настраиваются для хранения статических ресурсов, которые обычно не меняются часто и повторно используются на нескольких страницах. **Динамический контент не кэшируется, поскольку он, скорее всего, содержит конфиденциальную информацию, гарантируя, что пользователи получат последние данные напрямую с сервера.**

Атаки с обманом веб-кэша используют то, как применяются правила кэширования, поэтому важно знать о некоторых различных типах правил, особенно тех, которые основаны на определенных строках в URL-пути запроса. Например:

- ==Правила расширения статических файлов==. Эти правила соответствуют расширению файла запрошенного ресурса, например, `.css`для таблиц стилей или `.js`для файлов JavaScript.
- ==Правила статических каталогов== — эти правила соответствуют всем URL-путям, которые начинаются с определенного префикса. Они часто используются для нацеливания на определенные каталоги, которые содержат только статические ресурсы, например `/static`или `/assets`.
- ==Правила имен файлов==. Эти правила сопоставляют определенные имена файлов с целевыми файлами, которые повсеместно требуются для веб-операций и редко меняются, например `robots.txt`и `favicon.ico`.

Кэши также могут реализовывать пользовательские правила на основе других критериев, таких как параметры URL или динамический анализ.

# [[Создание атаки с использованием веб-кэша]]

В общем случае построение базовой атаки с использованием веб-кэша включает в себя следующие этапы:

1. **[[Создание атаки с использованием веб-кэша#1. Определение целевой конечной точки|Определим целевую конечную точку, которая возвращает динамический ответ, содержащий конфиденциальную информацию]]**. Сосредоточимся на конечных точках, которые поддерживают ==методы `GET`, `HEAD`или , `OPTIONS`==.
2. **[[Создание атаки с использованием веб-кэша#2. Определение несоответствия в обработке URL|Определим несоответствие в том, как кэш и исходный сервер анализируют путь URL]]**. Это может быть несоответствие в том, как они:
    - Сопоставьте URL-адреса с ресурсами.
    - Обработка символов-разделителей.
    - Нормализовать пути.
3. **Создать вредоносный URL, который использует несоответствие, чтобы обмануть кэш и сохранить динамический ответ**. Когда жертва обращается к URL, ее ответ сохраняется в кэше. Используя Burp, ==мы сможем затем отправить запрос на тот же URL, чтобы получить кэшированный ответ, содержащий данные жертвы.== Избегайте делать это напрямую в браузере, так как некоторые приложения перенаправляют пользователей без сеанса или делают локальные данные недействительными, что может скрыть уязвимость.

Мы рассмотрим несколько различных подходов к построению атаки с использованием веб-кэша.

#### Примечание Использование кэш-блокировщика
При тестировании на несоответствия и создании эксплойта обмана веб-кэша убедиться, что каждый отправляемый нами запрос имеет другой ключ кэша. В противном случае могут быть предоставлены кэшированные ответы, что повлияет на результаты теста.

### Обнаружение кэшированных ответов
Во время тестирования определить кэшированные ответ можно по заголовкам.
Различные заголовки ответа могут указывать на то, что он кэширован. Например:

- Заголовок `X-Cache`содержит информацию о том, был ли ответ подан из кэша. Типичные значения включают:
    - **`X-Cache: hit`- Ответ был получен из кэша.**
    - `X-Cache: miss`- Кэш не содержал ответа на ключ запроса, поэтому он был извлечен с исходного сервера. В большинстве случаев ответ затем кэшируется. Чтобы подтвердить это, нужно отправить запрос повторно, чтобы посмотреть, обновилось ли значение до попадания.
    - `X-Cache: dynamic`- Исходный сервер динамически сгенерировал контент. Обычно это означает, что ответ не подходит для кэширования.
    - `X-Cache: refresh`- Кэшированный контент устарел и его необходимо обновить или повторно проверить.
- Заголовок `Cache-Control`(отвечает за время хранения кэша) может включать директиву, которая указывает на кэширование, например, `public`с `max-age` более высоким значением, чем `0`. 
	Обратить внимание, что это только предполагает, что ресурс кэшируется. Это не всегда указывает на кэширование, так как кэш может иногда переопределять этот заголовок.

Если мы заметили большую разницу во времени ответа на один и тот же запрос, это также может указывать на то, что более быстрый ответ подается из кэша.


# [[Использование статических правил кэширования расширений]]

==Правила кэширования часто нацелены на статические ресурсы, сопоставляя общие расширения файлов, такие как `.css`или `.js`.== Это поведение по умолчанию в большинстве CDN.

- [[Использование статических правил кэширования расширений#Расхождения в отображении пути|Расхождения в отображении пути]]
- [[Использование статических правил кэширования расширений#Использование несоответствий в отображении пути|Использование несоответствий в отображении пути]]
- [[Использование статических правил кэширования расширений#Несоответствия разделителей|Несоответствия разделителей]]

### Использование несоответствий разделителей
Можно использовать несоответствие разделителя, чтобы добавить статическое расширение к пути, который просматривается кэшем, но не исходным сервером. ==Для этого нужно будет определить символ, который используется в качестве разделителя исходным сервером, но не кэшем==.

##### **Шаг 1. Выбор целевой конечной точки**
- Ищем URL, возвращающий конфиденциальные данные:
```
/profile
/settings
/account
```
- Проверяем, что поддерживаются "безопасные" методы: `GET`, `HEAD`.

##### **Шаг 2. Поиск разделителей, игнорируемых сервером**
1. **Добавляем произвольную строку** к URL:
```
/profile/random123
```
- Если ответ **совпадает** с оригиналом (`/profile`), сервер игнорирует `random123` → возможен перенаправление.
- Если ответ **отличается** (например, 404), пробуем другой разделитель.

2. **Тестируем символы-разделители**:  
	Добавляем символ между путем и строкой:
```
/profile;random123
/profile?random123
/profile#random123
```
- Если ответ идентичен `/profile` → символ (`;`, `?`, `#`) **игнорируется сервером**.
- Протестировать так же url кодировку для расхождения в декодировании разделителей
- Если ответ 404 → символ **не является разделителем**.

##### **Шаг 3. Проверка обработки разделителя кэшем**
- Добавляем **статическое расширение** после разделителя:
```
/profile;fake.css
```
1. Анализируем поведение:
    - **Сервер**: видит `/profile` → отдаёт личные данные.
    - **Кэш**: видит `fake.css` → сохраняет ответ как CSS-файл.
2. Если кэш отдаёт сохранённые данные при повторном запросе → уязвимость подтверждена.


Обязательно протестировать все символы ASCII и ряд распространенных расширений, включая `.css`, `.ico`и `.exe`. [Список потенциальных символов-разделителей](https://portswigger.net/web-security/web-cache-deception/wcd-lab-delimiter-list)
	Использовать Burp Intruder для быстрой проверки этих символов. Чтобы запретить Burp Intruder кодировать символы-разделители, нужно отключить автоматическое кодирование символов Burp Intruder в разделе **Кодирование** полезных данных на боковой панели **Полезные данные** .

#### Примечание
Некоторые символы-разделители могут быть обработаны браузером жертвы до того, как он перенаправит запрос в кэш. Это означает, что некоторые разделители не могут быть использованы в эксплойте. Например, браузеры кодируют URL-кодом символы, такие как `{`, `}`, `<`, и `>`, и используют `#` для усечения пути.
	Если кэш или исходный сервер декодируют эти символы, то можно использовать закодированную версию в эксплойте.


# Использование статических правил кэширования каталогов

Обычной практикой для веб-серверов является хранение статических ресурсов в определенных каталогах. Правила кэширования часто нацелены на эти каталоги, сопоставляя определенные префиксы пути URL, например `/static`, , `/assets`, `/scripts`, или `/images`. Эти правила также могут быть уязвимы для обмана веб-кэша.


### 1. Суть уязвимости
Веб-серверы часто кэшируют содержимое **статических каталогов** (`/static`, `/assets`, `/images`). Если кэш и сервер по-разному обрабатывают **нормализацию путей** (особенно `../` и кодированные символы), можно заставить кэш сохранить динамический контент как статический файл.

**Условия эксплуатации**:
- Кэш имеет правило для префикса пути (например, `/static/`).
- Сервер и кэш по-разному интерпретируют `..%2f` (кодированный `/../`).
- ==URL coding `%2f` -> `/`==

### 2. Пошаговая методика атаки

##### **Шаг 1. Обнаружение статических каталогов**
- В Burp Suite (`Proxy > HTTP history`) ищем запросы к:
```
/static/style.css  
/assets/logo.png  
/scripts/app.js  
```

##### **Шаг 2. Проверка нормализации путей на сервере**
1. Отправляем запрос с `..%2f` (кодированный `/../`) к некэшируемому URL:
```
POST /aaa/..%2fprofile HTTP/1.1  
```
- Если сервер возвращает данные `profile` → он **декодирует `%2f` и разрешает `../`**.
- Если 404 → сервер не нормализует путь.

2. Варианты тестирования:
    - Кодировать только второй слеш: `..%2f`
    - Кодировать всю последовательность: `%2e%2e%2f`
    - Кодировать точку: `.%2e/`

##### **Шаг 3. Проверка нормализации в кэше**
1. Модифицируем путь в статическом каталоге:
```
GET /static/..%2fprofile HTTP/1.1  
```
- Если ответ **не кэшируется** → кэш не обрабатывает `..%2f`.
- Если ответ кэшируется → кэш нормализует путь (редко).

##### **Шаг 4. Эксплуатация**
1. Если сервер нормализует `..%2f`, а кэш — нет:
```
GET /static/..%2fprofile HTTP/1.1  
```
- **Сервер**: видит `/profile` → отдаёт личные данные.
- **Кэш**: видит `/static/..%2fprofile` → сохраняет ответ по правилу для `/static/`.

2. Если кэш нормализует, а сервер — нет:
```
GET /profile%2f%2e%2e%2fstatic/fake.css  
```
- **Кэш**: видит `/static/fake.css` → кэширует.
- **Сервер**: видит `/profile%2f%2e%2e%2fstatic/fake.css` → 404 (но если есть разделитель `;`, см. ниже).

3. Комбинирование с разделителями:
```
GET /profile;%2f%2e%2e%2fstatic/fake.css  
```
- **Сервер** (Spring): игнорирует всё после `;` → отдаёт `/profile`.
- **Кэш**: видит `/static/fake.css` → кэширует.


# [[Предотвращение уязвимостей веб-кэширования]]

Ряд мер для предотвращения уязвимостей, связанных с обманом веб-кэша:

- Всегда использовать `Cache-Control`заголовки для обозначения динамических ресурсов, заданных с помощью директив `no-store` и `private`.
- Настроить параметры CDN так, чтобы правила кэширования не переопределяли `Cache-Control`заголовок.
- Активировать любую защиту, которую имеет CDN против атак обмана веб-кэша. Многие CDN позволяют установить правило кэширования, которое проверяет, что ответ `Content-Type` соответствует расширению файла URL запроса. Например, Cloudflare's Cache Deception Armor.
- Убедится, что нет никаких расхождений между тем, как исходный сервер и кэш интерпретируют пути URL.