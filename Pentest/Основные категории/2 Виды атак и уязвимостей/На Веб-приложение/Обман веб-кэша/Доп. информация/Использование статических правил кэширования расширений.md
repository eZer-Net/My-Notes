==Правила кэширования часто нацелены на статические ресурсы, сопоставляя общие расширения файлов, такие как `.css`или `.js`.== Это поведение по умолчанию в большинстве CDN.

Если существуют расхождения в том, как кэш и исходный сервер сопоставляют путь URL с ресурсами или используют разделители, злоумышленник может создать запрос на динамический ресурс со статическим расширением, который игнорируется исходным сервером, но просматривается кэшем.

### Расхождения в отображении пути
Сопоставление URL-путей — это процесс связывания URL-путей с ресурсами на сервере, такими как файлы, скрипты или выполнение команд. Существует ряд различных стилей сопоставления, используемых различными фреймворками и технологиями. Два распространенных стиля — это 
- традиционное сопоставление URL
- сопоставление URL RESTful.

Традиционное сопоставление URL представляет собой прямой путь к ресурсу, расположенному в файловой системе. Вот типичный пример:
`http://example.com/path/in/filesystem/resource.html`
- `http://example.com`указывает на сервер.
- `/path/in/filesystem/`представляет собой путь к каталогу в файловой системе сервера.
- `resource.html`— это конкретный файл, к которому осуществляется доступ.

Напротив, URL-адреса в стиле REST напрямую не соответствуют физической структуре файла. Они абстрагируют пути файлов в логические части API:
`http://example.com/path/resource/param1/param2`
- `http://example.com`указывает на сервер.
- `/path/resource/`конечная точка, представляющая ресурс.
- `param1`и `param2`— параметры пути, используемые сервером для обработки запроса.

==Различия в том, как кэш и исходный сервер сопоставляют путь URL с ресурсами, могут привести к уязвимостям обмана веб-кэша==. Рассмотрим следующий пример:
`http://example.com/user/123/profile/wcd.css`
- Исходный сервер, использующий сопоставление URL-адресов в стиле REST, может интерпретировать это как запрос к `/user/123/profile`конечной точке и вернуть информацию о профиле для пользователя `123`, игнорируя ее `wcd.css`как несущественный параметр.
- Кэш, использующий традиционное сопоставление URL, может рассматривать это как запрос на файл с именем, `wcd.css`расположенный в `/profile`каталоге под `/user/123`. Он интерпретирует путь URL как `/user/123/profile/wcd.css`. Если кэш настроен на хранение ответов на запросы, где путь заканчивается на `.css`, он будет кэшировать и обслуживать информацию профиля, как если бы это был файл CSS. 


### Использование несоответствий в отображении пути
Чтобы проверить, как исходный сервер сопоставляет путь URL с ресурсами, нужно добавить произвольный сегмент пути к URL целевой конечной точки. Если ответ по-прежнему содержит те же конфиденциальные данные, что и базовый ответ, это означает, что исходный сервер абстрагирует путь URL и игнорирует добавленный сегмент. Пример `/api/orders/123`на `/api/orders/123/foo` и мы видим по-прежнему ответ тот же.

Чтобы проверить, как кэш сопоставляет путь URL с ресурсами, нужно изменить путь, чтобы попытаться сопоставить его с правилом кэширования, добавив статическое расширение. Например, обновить `/api/orders/123/foo`до `/api/orders/123/foo.js`. Если ответ кэширован, это означает:
- Кэш интерпретирует полный путь URL со статическим расширением.
- Что существует правило кэширования для хранения ответов на запросы, заканчивающиеся на `.js`.

==Кэши могут иметь правила, основанные на определенных статических расширениях. Попробуйте ряд расширений, включая `.css`, `.ico`, и `.exe`.==

Затем мы можем создать URL, который возвращает динамический ответ, сохраненный в кэше. Обратить внимание, что эта **атака ограничена конкретной конечной точкой**, которую вы протестировали, поскольку исходный сервер часто имеет разные правила абстракции для разных конечных точек.

#### Примечание
Burp Scanner автоматически обнаруживает уязвимости обмана веб-кэша, вызванные несоответствиями в отображении путей во время аудита. Мы также можем использовать [Web Cache Deception Scanner](https://portswigger.net/bappstore/7c1ca94a61474d9e897d307c858d52f0) BApp для обнаружения неправильно настроенных веб-кэшей.


### Несоответствия разделителей
Разделители определяют границы между различными элементами в URL. Использование символов и строк в качестве разделителей обычно стандартизировано. Например, `?`обычно используется для отделения пути URL от строки запроса. Однако, поскольку URI RFC является достаточно разрешительным, различия все еще возникают между различными фреймворками или технологиями.

Различия в том, как кэш и исходный сервер используют символы и строки в качестве разделителей, могут привести к уязвимостям обмана веб-кэша. Рассмотрим пример `/profile;foo.css`:
- **Фреймворк Java Spring** использует этот `;`символ для добавления параметров, известных как матричные переменные. Исходный сервер, использующий Java Spring, поэтому интерпретировал бы его `;`как разделитель. Он обрезает путь после `/profile`и возвращает информацию о профиле.
- Большинство других фреймворков не используют `;`в качестве разделителя. Поэтому кэш, который не использует Java Spring, скорее всего, будет интерпретировать `;`и все, что находится после него, как часть пути, то есть не сработает. 

То же самое относится и к другим символам, которые используются непоследовательно между фреймворками или технологиями. Рассмотрим эти запросы к исходному серверу, на котором запущен фреймворк Ruby on Rails, который использует `.`в качестве разделителя для указания формата ответа:

- `/profile`- Этот запрос обрабатывается HTML-форматером по умолчанию, который возвращает информацию профиля пользователя.
- `/profile.css`- Этот запрос распознается как расширение CSS. Форматировщика CSS нет, поэтому запрос не принимается и возвращается ошибка.
- `/profile.ico`- Этот запрос использует `.ico`расширение, которое ==не распознается Ruby on Rails==. Форматировщик HTML по умолчанию обрабатывает запрос и возвращает информацию о профиле пользователя. В этой ситуации, если кэш настроен на хранение ответов для запросов, заканчивающихся на `.ico`, он будет кэшировать и обслуживать информацию о профиле, как если бы это был статический файл.

Закодированные символы также иногда могут использоваться в качестве разделителей. Например, рассмотрим запрос `/profile%00foo.js`:

- Сервер OpenLiteSpeed ​​использует закодированный нулевой `%00`символ в качестве разделителя. Исходный сервер, использующий OpenLiteSpeed, поэтому интерпретировал бы путь как `/profile`.
- Большинство других фреймворков отвечают ошибкой, если `%00`в URL-адресе. Однако, если кэш использует Akamai или Fastly, он будет интерпретировать `%00`и все после него как путь.

### Использование несоответствий разделителей
Можно использовать несоответствие разделителя, чтобы добавить статическое расширение к пути, который просматривается кэшем, но не исходным сервером. ==Для этого нужно будет определить символ, который используется в качестве разделителя исходным сервером, но не кэшем==.

##### **Шаг 1. Выбор целевой конечной точки**
- Ищем URL, возвращающий конфиденциальные данные:
```
/profile
/settings
/account
```
- Проверяем, что поддерживаются "безопасные" методы: `GET`, `HEAD`.

##### **Шаг 2. Поиск разделителей, игнорируемых сервером**
1. **Добавляем произвольную строку** к URL:
```
/profile/random123
```
- Если ответ **совпадает** с оригиналом (`/profile`), сервер игнорирует `random123` → возможен перенаправление.
- Если ответ **отличается** (например, 404), пробуем другой разделитель.

2. **Тестируем символы-разделители**:  
	Добавляем символ между путем и строкой:
```
/profile;random123
/profile?random123
/profile#random123
```
- Если ответ идентичен `/profile` → символ (`;`, `?`, `#`) **игнорируется сервером**.
- Протестировать так же url кодировку для расхождения в декодировании разделителей
- Если ответ 404 → символ **не является разделителем**.

##### **Шаг 3. Проверка обработки разделителя кэшем**
- Добавляем **статическое расширение** после разделителя:
```
/profile;fake.css
```
1. Анализируем поведение:
    - **Сервер**: видит `/profile` → отдаёт личные данные.
    - **Кэш**: видит `fake.css` → сохраняет ответ как CSS-файл.
2. Если кэш отдаёт сохранённые данные при повторном запросе → уязвимость подтверждена.


Обязательно протестировать все символы ASCII и ряд распространенных расширений, включая `.css`, `.ico`и `.exe`. [Список потенциальных символов-разделителей](https://portswigger.net/web-security/web-cache-deception/wcd-lab-delimiter-list)
	Использовать Burp Intruder для быстрой проверки этих символов. Чтобы запретить Burp Intruder кодировать символы-разделители, нужно отключить автоматическое кодирование символов Burp Intruder в разделе **Кодирование** полезных данных на боковой панели **Полезные данные** .

#### Примечание
Некоторые символы-разделители могут быть обработаны браузером жертвы до того, как он перенаправит запрос в кэш. Это означает, что некоторые разделители не могут быть использованы в эксплойте. Например, браузеры кодируют URL-кодом символы, такие как `{`, `}`, `<`, и `>`, и используют `#` для усечения пути.
	Если кэш или исходный сервер декодируют эти символы, то можно использовать закодированную версию в эксплойте.

