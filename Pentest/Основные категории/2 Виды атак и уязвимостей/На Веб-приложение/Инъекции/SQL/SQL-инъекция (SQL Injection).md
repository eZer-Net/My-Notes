
# Что такое SQL-инъекция (SQLi)?

SQL-инъекция (SQLi) — это уязвимость веб-безопасности, которая позволяет злоумышленнику вмешиваться в запросы, которые приложение отправляет в свою базу данных. Это может позволить злоумышленнику просмотреть данные, которые он обычно не может получить.

# Как обнаружить уязвимости SQL-инъекций

Обнаружить SQL-инъекцию вручную, используя систематический набор тестов для каждой точки входа в приложении. Для этого вы обычно отправляете:

- Символ одинарной кавычки `'` и искать ошибки или другие аномалии.

- Некоторый синтаксис, специфичный для SQL, который оценивает базовое (исходное) значение точки входа и другое значение и ищет систематические различия в ответах приложения.

- Булевы условия, такие как `OR 1=1` и `OR 1=2`и найдите различия в ответах приложения.

- Полезные нагрузки, предназначенные для запуска временных задержек при выполнении SQL-запроса и поиска различий во времени, необходимом для ответа.

- Полезные нагрузки [[Основные категории тестирования безопасности OAST, SAST, SCA, DAST ...|OAST]], предназначенные для запуска внеполосного сетевого взаимодействия при выполнении в рамках SQL-запроса и отслеживания любых результирующих взаимодействий.

## SQL-инъекция в разные части запроса

Большинство уязвимостей SQL-инъекций возникают внутри `WHERE` пункт `SELECT` запрос. Большинство опытных тестировщиков знакомы с этим типом SQL-инъекции.

Однако уязвимости, связанные с внедрением [[SQL#Язык SQL|SQL-кода]], могут возникать в любом месте запроса и в различных типах запросов. Некоторые другие распространенные места, где возникает SQL-инъекция:

- В `UPDATE` операторов, в пределах обновленных значений или `WHERE` пункт.
- В `INSERT` операторы внутри вставленных значений.
- В `SELECT` операторы в имени таблицы или столбца.
- В `SELECT` заявления, в рамках `ORDER BY` пункт.

## [[Простые примеры работы SQL инъекции]]

----
# [[SQL-инъекция UNION-атак|SQL-инъекция UNION-атак]] 

Атака при которой мы добавляем полезную нагрузку в свой запрос такие как достать столбец пользователей, паролей и тп...
UNION - объединение запросов

----
# Получение нескольких значений в одном столбце

В некоторых случаях запрос может возвращать только один столбец.

Мы можем получить несколько значений вместе в одном столбце, объединив их. Можно включить разделитель, чтобы различать объединенные значения. Например, в Oracle можно отправить входные данные:
`' UNION SELECT username || '~' || password FROM users--`

Здесь используется последовательность двух труб. `||` который является оператором конкатенации строк в Oracle. Внедренный запрос объединяет значения `username` и `password` поля, разделенные `~` характер.

Результаты запроса содержат все имена пользователей и пароли, например:
`... administrator~s3cure wiener~peter carlos~montoya ...`

Разные базы данных используют разный синтаксис для объединения строк. Более подробную информацию можно найти [в шпаргалке по SQL-инъекциям](https://portswigger.net/web-security/sql-injection/cheat-sheet) .

----
# Синтаксис, специфичный для базы данных

В Oracle каждый `SELECT` запрос должен использовать `FROM` ключевое слово и укажите действительную таблицу. В Oracle есть встроенная таблица под названием `dual` который можно использовать для этой цели. Таким образом, внедренные запросы в Oracle должны выглядеть так:
`' UNION SELECT NULL FROM DUAL--`

Описанные полезные данные используют последовательность комментариев в виде двойного тире. `--` чтобы закомментировать оставшуюся часть исходного запроса после точки внедрения. 
- В MySQL за последовательностью двойного тире должен следовать пробел. Альтернативно, хэш-символ `#` может использоваться для идентификации комментария уже без пробела.

##### ==[Шпаргалка по инъекциям](https://portswigger.net/web-security/sql-injection/cheat-sheet)==

----
# [[Исследование базы данных при атаках с использованием SQL-инъекций]]

Чтобы использовать уязвимости SQL-инъекций, часто необходимо найти информацию о базе данных. Это включает в себя:

- Тип и версия программного обеспечения базы данных.
- Таблицы и столбцы, содержащиеся в базе данных.


----
# [[Слепая SQL-инъекция|Слепая SQL-инъекция]]

Слепая SQL-инъекция происходит, когда приложение уязвимо для SQL-инъекции, но его HTTP-ответы не содержат результатов соответствующего SQL-запроса или сведений об ошибках базы данных.


### [[SQL-инъекция на основе ошибок]]

SQL-инъекция на основе ошибок относится к случаям, когда вы можете использовать сообщения об ошибках для извлечения или вывода конфиденциальных данных из базы данных, даже в слепом контексте.

### [[Использование слепых инъекций SQL за счет задержек времени]]

Уязвимость слепого инъекции SQL, запуская время задержки в зависимости от того, является ли инъецированное состояние истинным или ложным. 
### [[Использование слепого внедрения SQL с использованием внеполосных методов (OAST)]]

Приложение выполняет SQL-запрос, но делая это асинхронно. 

----
# SQL-инъекция в разных контекстах

Атаки с помощью SQL-инъекций, используя любые контролируемые входные данные, которые обрабатываются приложением как SQL-запрос. Например, некоторые веб-сайты принимают входные данные в формате JSON или XML и используют их для запроса к базе данных.

Эти разные форматы могут предоставлять вам разные способы скрыть атаки, которые в противном случае блокируются с помощью WAF и других защитных механизмов. **Слабые реализации часто ищут в запросе общие ключевые слова внедрения SQL, поэтому вы можете обойти эти фильтры, закодировав или экранировав символы в запрещенных ключевых словах.** Например, следующая SQL-инъекция на основе XML использует escape-последовательность XML для кодирования `S` персонаж в `SELECT`:

```
<stockCheck> 
	<productId>123</productId> 
	<storeId>999 &#x53;ELECT * FROM information_schema.tables</storeId> 
</stockCheck>
```
• &#x53; — это escape-последовательность в XML, которая соответствует символу "S" в шестнадцатеричном формате. 

Это будет декодирована на стороне сервера, прежде чем будет передаваться в интерпретатор SQL.

----
# Инъекция SQL второго порядка

Инъекция SQL первого порядка происходит, когда приложение обрабатывает ввод пользователя из HTTP-запроса и небезопасно включает ввод в SQL-запрос.

Инъекция SQL второго порядка происходит, когда приложение получает пользовательский ввод из HTTP-запроса и хранит его для будущего использования. Обычно это делается путем размещения ввода в базу данных, но уязвимости не происходит в точке, где данные хранятся. Позже, при обработке другого HTTP -запроса, приложение извлекает хранимые данные и небезопасно включает в себя в SQL -запрос. По этой причине инъекция SQL второго порядка также известна как хранимая инъекция SQL.

----
# [[Защита от SQL-инъекций]]

----
# Инструменты

[[Инструмент Burp Suite]]
[[Инструмент SQLmap]]

----
# Дополнительная информация

[[Методика поиска и развития уязвимости SQL]]