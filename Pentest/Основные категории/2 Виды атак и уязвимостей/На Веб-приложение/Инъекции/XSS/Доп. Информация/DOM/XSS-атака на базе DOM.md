
## Что такое межсайтовый скриптинг на основе DOM?

Уязвимости XSS на основе [[Уязвимости, основанные на DOM|DOM]] обычно возникают, когда JavaScript берет данные из контролируемого злоумышленником источника, например URL, и передает их в приемник, поддерживающий динамическое выполнение кода, например `eval()`или `innerHTML`. Это позволяет злоумышленникам выполнять вредоносный JavaScript, что обычно позволяет им захватывать учетные записи других пользователей.

Чтобы осуществить атаку XSS на основе DOM, необходимо поместить данные в источник так, чтобы они распространились на приемник и вызвали выполнение произвольного JavaScript.

Наиболее распространенным источником DOM XSS является URL, доступ к которому обычно осуществляется с помощью `window.location`объекта. Злоумышленник может создать ссылку, чтобы отправить жертву на уязвимую страницу с полезной нагрузкой в ​​строке запроса и фрагментных частях URL. В определенных обстоятельствах, например, при нацеливании на страницу 404 или веб-сайт, работающий на PHP, полезная нагрузка также может быть размещена в пути.

- #### [[Уязвимости, основанные на DOM|Подробное описание потока зараженных данных между источниками и приемниками]].

----
# Как проверить наличие межсайтового скриптинга на основе DOM

Большинство уязвимостей DOM XSS можно быстро и надежно обнаружить с помощью веб-сканеров уязвимостей. Для ручного тестирования межсайтового скриптинга на основе DOM обычно требуется браузер с инструментами разработчика, например Chrome, Firefox... . Нужно по очереди работать с каждым доступным источником и тестировать каждый из них по отдельности.

### Тестирование HTML-приемников

Чтобы проверить наличие DOM XSS в HTML-приемнике, поместить случайную буквенно-цифровую строку в источник (например, `location.search`), затем использовать инструмент разработчика, чтобы проверить HTML и найти, где появляется строка. Обратить внимание, что опция браузера «Просмотреть исходный код» не будет работать для тестирования DOM XSS, поскольку она не учитывает изменения, которые были выполнены в HTML с помощью JavaScript. В инструментах разработчика Chrome можно использовать `Control+F`(или `Command+F`в MacOS) для поиска строки в DOM.

==Для каждого места, где строка появляется в DOM, нужно определить контекст. На основе этого контекста нужно уточнить свой ввод, чтобы увидеть, как он обрабатывается.== Например, если строка появляется в атрибуте, заключенном в двойные кавычки, попробуйте ввести двойные кавычки в строку, чтобы посмотреть, сможете ли выйти за пределы атрибута.

Обратить внимание, что браузеры ведут себя по-разному в отношении URL-кодирования: Chrome, Firefox и Safari будут URL-кодировать `location.search`и `location.hash`, тогда как ==IE11 и Microsoft Edge (до Chromium) не будут URL-кодировать эти источники. Если ваши данные будут URL-кодироваться до обработки, то атака XSS вряд ли сработает.==

### Тестирование приемников выполнения JavaScript

Тестирование приемников выполнения JavaScript для XSS на основе DOM немного сложнее. С этими приемниками ввод не обязательно появляется где-либо в DOM, поэтому мы не можем его искать. Вместо этого нужно будет **использовать отладчик JavaScript, чтобы определить, отправляется ли наш ввод в приемник и как это происходит.**

Для каждого потенциального источника, например `location`, сначала нужно найти случаи в коде JavaScript страницы, где ссылаются на источник. В инструментах разработчика Chrome можно использовать `Control+Shift+F`для поиска источника по всему коду JavaScript страницы.

После того, как нашли, где считывается источник, можем использовать отладчик JavaScript, чтобы добавить точку останова и проследить, как используется значение источника. Мы можем обнаружить, что источник назначается другим переменным. Если это так, то нужно будет снова использовать функцию поиска, чтобы отслеживать эти переменные и смотреть, передаются ли они в приемник. Когда мы найдем приемник, которому назначаются данные, полученные из источника, мы можем использовать отладчик, чтобы проверить значение, наведя курсор на переменную, чтобы увидеть ее значение до того, как оно будет отправлено в приемник. Затем, как и в случае с приемниками HTML, нужно будет уточнить свой ввод, чтобы увидеть, сможем ли мы провести успешную атаку XSS.

### Тестирование на DOM XSS с использованием DOM Invader

Выявление и эксплуатация DOM XSS в реальных условиях может быть утомительным процессом, часто требующим ручного прочесывания сложного, минимизированного JavaScript. Однако, если использовать браузер Burp, можно воспользоваться его встроенным расширением DOM Invader, которое делает большую часть тяжелой работы за нас.

- [Документация DOM Invader](https://portswigger.net/burp/documentation/desktop/tools/dom-invader)

----
# Эксплуатация DOM XSS с различными источниками и приемниками

В принципе, веб-сайт уязвим для межсайтового скриптинга на основе DOM, если есть исполняемый путь, по которому данные могут распространяться от источника к приемнику. На практике разные источники и приемники имеют разные свойства и поведение, которые могут влиять на эксплуатируемость и определять, какие методы необходимы. Кроме того, скрипты веб-сайта могут выполнять проверку или другую обработку данных, которые должны быть учтены при попытке эксплуатации уязвимости. Существует множество приемников, которые имеют отношение к уязвимостям на основе DOM. Подробности см. в [[XSS-атака на базе DOM#Какие приёмники могут привести к уязвимостям DOM-XSS?|списке ниже]].


Приемник `document.write`работает с `script`элементами, поэтому можно использовать простую полезную нагрузку, например, такую, как показано ниже:
```
document.write('... <script>alert(document.domain)</script> ...');
```

Обратить внимание, однако, что **в некоторых ситуациях контент, который записывается, `document.write`включает некоторый окружающий контекст, который нужно учитывать в эксплойте**. Например, может потребоваться закрыть некоторые существующие элементы перед использованием полезной нагрузки JavaScript.

Приемник `innerHTML`не принимает `script`элементы ни в одном современном браузере, и `svg onload`события не будут срабатывать. Это означает, что нужно будет использовать альтернативные элементы, такие как `img`или `iframe`. Обработчики событий, такие как `onload` и, `onerror`могут использоваться вместе с этими элементами. Например:
```
element.innerHTML='... <img src=1 onerror=alert(document.domain)> ...'
```

### Источники и приемники в сторонних зависимостях

Современные веб-приложения обычно создаются с использованием ряда сторонних библиотек и фреймворков, которые часто предоставляют дополнительные функции и возможности для разработчиков. Важно помнить, что некоторые из них также являются потенциальными источниками и стоками для DOM XSS.

#### DOM XSS в jQuery
Если используется библиотека JavaScript, например jQuery, обратите внимание на приемники, которые могут изменять элементы DOM на странице. Например, `attr()`функция jQuery может изменять атрибуты элементов DOM. Если данные считываются из источника, контролируемого пользователем, например URL, а затем передаются в `attr()`функцию, то может быть возможным манипулировать отправленным значением, чтобы вызвать XSS.

Например, здесь у нас есть некоторый JavaScript, который изменяет атрибут элемента привязки, `href`используя данные из URL:
```
$(function() { 
$('#backLink').attr("href",(new URLSearchParams(window.location.search)).get('returnUrl')); 
});
```
Мы можем воспользоваться этим, изменив URL так, чтобы `location.search`источник содержал вредоносный URL JavaScript. После того, как JavaScript страницы применит этот вредоносный URL к обратной ссылке `href`, нажатие на обратную ссылку выполнит ее:
`?returnUrl=javascript:alert(document.domain)`


Еще одним потенциальным приемником, на который следует обратить внимание, является селекторная функция jQuery `$()`, которая может использоваться для внедрения вредоносных объектов в DOM.

jQuery раньше был чрезвычайно популярен, и классическая уязвимость DOM XSS была вызвана веб-сайтами, использующими этот селектор в сочетании с `location.hash`источником для анимации или автоматической прокрутки к определенному элементу на странице. Такое поведение часто реализовывалось с помощью уязвимого `hashchange`обработчика событий, похожего на следующий:
```
$(window).on('hashchange', function() { 
	var element = $(location.hash); 
	element[0].scrollIntoView(); 
});
```

Так как это `hash`контролируется пользователем, злоумышленник может использовать это для внедрения вектора XSS в `$()`селектор-приемник. Более поздние версии jQuery исправили эту конкретную уязвимость, не позволяя вам внедрять HTML в селектор, когда ввод начинается с символа решетки ( `#`). Тем не менее, есть те кто не обновил jquery и можно найти уязвимый код на практики.

Чтобы фактически эксплуатировать эту классическую уязвимость, нужно найти способ вызвать `hashchange`событие без взаимодействия с пользователем. Один из самых простых способов сделать это — доставить эксплойт через `iframe`:
```
<iframe src="https://vulnerable-website.com#" onload="this.src+='<img src=1 onerror=alert(1)>'">
```
В этом примере `src`атрибут указывает на уязвимую страницу с пустым значением хеша. Когда `iframe`загружается, к хешу добавляется вектор XSS, что приводит `hashchange`к срабатыванию события.

##### Примечание
Даже более новые версии jQuery могут быть уязвимы через `$()`селектор-приемник, при условии, что у нас есть полный контроль над его входными данными из источника, не требующего `#`префикса.


#### DOM XSS в AngularJS
Если используется фреймворк вроде AngularJS, то можно выполнить JavaScript без угловых скобок или событий. Когда сайт использует `ng-app`атрибут в элементе HTML, он будет обработан AngularJS. В этом случае AngularJS выполнит JavaScript внутри двойных фигурных скобок `{{ }}`, которые могут встречаться непосредственно в HTML или внутри атрибутов.

# DOM XSS в сочетании с отраженными и сохраненными данными

Некоторые уязвимости, основанные на чистом DOM, замкнуты в пределах одной страницы. Если скрипт считывает некоторые данные из URL и записывает их в опасный сток, то уязвимость полностью клиентская.

Однако источники не ограничиваются данными, которые напрямую предоставляются браузерами — они также могут исходить с веб-сайта. Например, веб-сайты часто отражают параметры URL в HTML-ответе сервера. Это обычно связано с обычным XSS, но также может привести к отраженным уязвимостям DOM XSS.

В отраженной уязвимости DOM XSS сервер обрабатывает данные из запроса и выводит их в ответ. Отраженные данные могут быть помещены в строковый литерал JavaScript или элемент данных в DOM, например, поле формы. Затем скрипт на странице обрабатывает отраженные данные небезопасным способом, в конечном итоге записывая их в опасный приемник.
```
eval('var data = "reflected string"');
```

Веб-сайты также могут хранить данные на сервере и отражать их в другом месте. В уязвимости DOM XSS, хранимой в сохраненном состоянии, сервер получает данные из одного запроса, сохраняет их, а затем включает данные в более поздний ответ. Скрипт в более позднем ответе содержит приемник, который затем обрабатывает данные небезопасным способом.
```
element.innerHTML = comment.author
```

# Какие приёмники могут привести к уязвимостям DOM-XSS?

#### **1. Нативные JavaScript-функции:**

- **`document.write()`**: Вставляет HTML напрямую в DOM.
- **`document.writeln()`**: Аналогично `document.write()`, но добавляет новую строку.
- **`element.innerHTML`**: Устанавливает HTML-содержимое элемента.
- **`element.outerHTML`**: Заменяет весь элемент, включая его HTML.
- **`element.insertAdjacentHTML()`**: Вставляет HTML в определенное место относительно элемента.
- **`element.onevent`**: Обработчики событий, такие как `onclick`, `onload`, `onerror`.
#### **2. jQuery-функции:**

- **`add()`**, **`after()`**, **`append()`**, **`animate()`**: Манипуляции с DOM.
- **`insertAfter()`**, **`insertBefore()`**, **`before()`**: Вставка элементов.
- **`html()`**: Устанавливает HTML-содержимое элемента.
- **`prepend()`**, **`replaceAll()`**, **`replaceWith()`**: Манипуляции с DOM.
- **`wrap()`**, **`wrapInner()`**, **`wrapAll()`**: Обертывание элементов.
- **`has()`**, **`constructor()`**, **`init()`**, **`index()`**: Опасные методы.
- **`jQuery.parseHTML()`**, **`$.parseHTML()`**: Парсинг HTML из строки.
#### **3.React-функции**

- Основная опасность: `dangerouslySetInnerHTML`, `ref`, `eval`.

#### **4.AngularJS:**

- Основная опасность: `ng-bind-html`, `$eval`, `$interpolate`, `element.html()`.

# Как предотвратить уязвимости DOM-XSS

В дополнение к общим мерам, описанным на странице [[Уязвимости, основанные на DOM|уязвимостей на основе DOM]] , следует избегать динамической записи данных из любого ненадежного источника в HTML-документ.

- ### [[Защита от уязвимости на основе DOM-потока]]