
## Что такое обход пути?

Обход пути также известен как обход каталога. Эти уязвимости **позволяют читать произвольные файлы на сервере, на котором запущено приложение**. Это может включать:
- Код приложения и данные.
- Учетные данные для внутренних систем.
- Конфиденциальные файлы операционной системы.

В некоторых случаях злоумышленник может иметь возможность записывать данные в произвольные файлы на сервере, что позволяет ему изменять данные или поведение приложения и в конечном итоге получить полный контроль над сервером.

## Чтение произвольных файлов путем обхода пути

Представим себе приложение для покупок, которое отображает изображения товаров для продажи. Оно может загружать изображение с помощью следующего HTML:
```
<img src="/loadImage?filename=218.png">
```

URL `loadImage`принимает `filename`параметр и возвращает содержимое указанного файла. Файлы изображений хранятся на диске в расположении `/var/www/images/`. Чтобы вернуть изображение, приложение добавляет запрошенное имя файла к этому базовому каталогу и использует API файловой системы для чтения содержимого файла. Другими словами, приложение считывает из следующего пути файла:
```
/var/www/images/218.png
```

Это приложение не реализует никакой защиты от атак обхода пути. В результате злоумышленник может запросить следующий URL для извлечения `/etc/passwd`файла из файловой системы сервера:
```
https://insecure-website.com/loadImage?filename=../../../etc/passwd
```

Это заставляет приложение считывать данные из следующего пути файла:
```
/var/www/images/../../../etc/passwd
```

Последовательность `../`действительна в пределах пути к файлу и означает переход на один уровень вверх в структуре каталогов. Три последовательные `../`последовательности ведут `/var/www/images/`к корню файловой системы, и поэтому файл, который фактически считывается, это:
```
/etc/passwd
```

В операционных системах на базе Unix это стандартный файл, содержащий сведения о пользователях, зарегистрированных на сервере, но злоумышленник может получить другие произвольные файлы, используя ту же технику.

В Windows и то, и другое `../`являются `..\`допустимыми последовательностями обхода каталогов. Ниже приведен пример эквивалентной атаки на сервер на базе Windows:
`https://insecure-website.com/loadImage?filename=..\..\..\windows\win.ini`

## Распространенные препятствия для эксплуатации уязвимостей обхода пути

Многие приложения, которые помещают пользовательский ввод в пути к файлам, реализуют защиту от атак обхода пути. Их часто можно обойти.

1. **Использование абсолютных путей**
    - Пример: `filename=/etc/passwd`
    - Позволяет напрямую ссылаться на файл без использования последовательностей обхода.

2. **Вложенные последовательности обхода**
    - Примеры: `....//` или `....\/`
    - После удаления внутренних последовательностей они превращаются в простые последовательности обхода (например, `../`).

3. **Обход очистки URL или параметров запроса**    
    - Веб-серверы могут удалять последовательности обхода до передачи данных приложению.
    
    - Методы обхода:
        - Кодирование URL: `../` → `%2e%2e%2f`
        - Двойное кодирование URL: `../` → `%252e%252e%252f`
        - Нестандартные кодировки: `..%c0%af`, `..%ef%bc%8f`

4. **Использование инструментов**    
    - В Burp Suite Professional есть предопределенный список полезной нагрузки **Fuzzing - path traversal**, содержащий закодированные последовательности обхода.
        
5. **Обход требований к базовой папке**
    - Если приложение требует, чтобы путь начинался с определенной папки (например, `/var/www/images`), можно включить эту папку, а затем добавить последовательности обхода.
    - Пример: `filename=/var/www/images/../../../etc/passwd`

6. **Обход требований к расширению файла**
    - Если приложение требует, чтобы имя файла заканчивалось определенным расширением (например, `.png`), можно использовать нулевой байт для завершения пути до расширения.
    - Пример: `filename=../../../etc/passwd%00.png`

## Как предотвратить атаку обхода пути

Самый эффективный способ предотвратить уязвимости обхода пути — вообще избегать передачи пользовательского ввода в API файловой системы. Многие функции приложения, которые это делают, можно переписать, чтобы обеспечить то же поведение более безопасным способом.

Если вы не можете избежать передачи пользовательских данных в API файловой системы, мы рекомендуем использовать два уровня защиты для предотвращения атак:

- Проверьте пользовательский ввод перед его обработкой. В идеале сравните пользовательский ввод с белым списком разрешенных значений. Если это невозможно, проверьте, что ввод содержит только разрешенный контент, например только буквенно-цифровые символы.
- После проверки предоставленного ввода добавьте ввод в базовый каталог и используйте API файловой системы платформы для канонизации пути. Убедитесь, что канонизированный путь начинается с ожидаемого базового каталога.

Ниже приведен пример простого кода Java для проверки канонического пути к файлу на основе введенных пользователем данных:

`File file = new File(BASE_DIRECTORY, userInput); if (file.getCanonicalPath().startsWith(BASE_DIRECTORY)) { // process file }`

# Дополнительная информация

[[Методика поиска по эксплуатации уязвимостей обхода пути (Path Traversal)]]
