Обман [[Pentest/Термины#Веб-кэш (веб-кеш, web cache)|веб-кэша]] — это уязвимость, которая позволяет злоумышленнику обмануть веб-кэш, заставив его хранить конфиденциальный, динамический контент. Это вызвано расхождениями между тем, как сервер кэша и исходный сервер обрабатывают запросы.

## Суть уязвимости

В атаке с обманом веб-кэша ==злоумышленник убеждает жертву посетить вредоносный URL-адрес, побуждая браузер жертвы сделать двусмысленный запрос на конфиденциальный контент. Кэш неверно интерпретирует это как запрос на статический ресурс и сохраняет ответ. Затем злоумышленник может запросить тот же URL-адрес, чтобы получить доступ к кэшированному ответу, получив несанкционированный доступ к личной информации==.

#### Примечание
Важно различать обман веб-кэша и отравление веб-кэша. Хотя оба используют механизмы кэширования, они делают это по-разному:
- **Отравление веб-кэша манипулирует ключами кэша**, чтобы внедрить вредоносный контент в кэшированный ответ, который затем передается другим пользователям.
- **Обман веб-кэша использует правила кэширования**, чтобы обмануть кэш и заставить его хранить конфиденциальную или личную информацию, к которой злоумышленник затем может получить доступ.


## Веб-кэши

Веб-кэш — это система, которая находится между исходным сервером и пользователем. Когда клиент запрашивает статический ресурс, запрос сначала направляется в кэш. ==Если кэш не содержит копии ресурса (это называется промахом кэша)==, запрос пересылается на исходный сервер, который обрабатывает запрос и отвечает на него. Затем ответ отправляется в кэш перед отправкой пользователю. ==Кэш использует предварительно настроенный набор правил для определения того, следует ли сохранять ответ.==

При последующем запросе того же статического ресурса кэш передает сохраненную копию ответа непосредственно пользователю (это называется попаданием в кэш).
![[Pasted image 20250512113555.png]]Кэширование стало обычным и важным аспектом доставки веб-контента, особенно с широким распространением сетей доставки контента (CDN), которые используют кэширование для хранения копий контента на распределенных серверах по всему миру. CDN ускоряют доставку, обслуживая контент с ближайшего к пользователю сервера, сокращая время загрузки за счет минимизации расстояния передачи данных.

### Кэш-ключи
Когда кэш получает HTTP-запрос, он должен решить, есть ли кэшированный ответ, который он может обслужить напрямую, или он должен переслать запрос на исходный сервер. ==Кэш принимает это решение, генерируя «ключ кэша» из элементов HTTP-запроса. Обычно это включает в себя путь URL и параметры запроса, но он также может включать в себя множество других элементов, таких как заголовки и тип контента.==

Если ключ кэша входящего запроса совпадает с ключом предыдущего запроса, кэш считает их эквивалентными и выдает копию кэшированного ответа.

#### Как работает веб-кэш?
1. **Первый запрос**:
    - Пользователь запрашивает страницу `example.com/page.html`.
    - Сервер обрабатывает запрос и отправляет ответ.
    - Кэш (например, прокси-сервер или CDN) сохраняет копию этого ответа.
2. **Повторный запрос**:
    - Если другой пользователь запрашивает ту же страницу, кэш может отдать сохранённую копию, не обращаясь к исходному серверу.
    - Это экономит время и ресурсы.

#### Где находится веб-кэш?
- **Браузерный кэш** (на стороне клиента) — сохраняет файлы локально, чтобы не загружать их повторно.
- **Прокси-кэш** (например, корпоративный прокси или ISP-кэш) — кэширует контент для множества пользователей.
- **CDN-кэш** (Cloudflare, Akamai и др.) — распределённые серверы, ускоряющие доставку контента глобально.
- **Серверный кэш** (например, Nginx, Varnish) — кэширует ответы бэкенда.



### Правила кэширования
Правила кэширования определяют, что может кэшироваться и как долго. Правила кэширования часто настраиваются для хранения статических ресурсов, которые обычно не меняются часто и повторно используются на нескольких страницах. **Динамический контент не кэшируется, поскольку он, скорее всего, содержит конфиденциальную информацию, гарантируя, что пользователи получат последние данные напрямую с сервера.**

Атаки с обманом веб-кэша используют то, как применяются правила кэширования, поэтому важно знать о некоторых различных типах правил, особенно тех, которые основаны на определенных строках в URL-пути запроса. Например:

- ==Правила расширения статических файлов==. Эти правила соответствуют расширению файла запрошенного ресурса, например, `.css`для таблиц стилей или `.js`для файлов JavaScript.
- ==Правила статических каталогов== — эти правила соответствуют всем URL-путям, которые начинаются с определенного префикса. Они часто используются для нацеливания на определенные каталоги, которые содержат только статические ресурсы, например `/static`или `/assets`.
- ==Правила имен файлов==. Эти правила сопоставляют определенные имена файлов с целевыми файлами, которые повсеместно требуются для веб-операций и редко меняются, например `robots.txt`и `favicon.ico`.

Кэши также могут реализовывать пользовательские правила на основе других критериев, таких как параметры URL или динамический анализ.

# Создание атаки с использованием веб-кэша

В общем случае построение базовой атаки с использованием веб-кэша включает в себя следующие этапы:

1. **Определим целевую конечную точку, которая возвращает динамический ответ, содержащий конфиденциальную информацию**. Сосредоточимся на конечных точках, которые поддерживают ==методы `GET`, `HEAD`или , `OPTIONS`==.
2. **Определим несоответствие в том, как кэш и исходный сервер анализируют путь URL**. Это может быть несоответствие в том, как они:
    - Сопоставьте URL-адреса с ресурсами.
    - Обработка символов-разделителей.
    - Нормализовать пути.

3. **Создать вредоносный URL, который использует несоответствие, чтобы обмануть кэш и сохранить динамический ответ**. Когда жертва обращается к URL, ее ответ сохраняется в кэше. Используя Burp, ==мы сможем затем отправить запрос на тот же URL, чтобы получить кэшированный ответ, содержащий данные жертвы.== Избегайте делать это напрямую в браузере, так как некоторые приложения перенаправляют пользователей без сеанса или делают локальные данные недействительными, что может скрыть уязвимость.

Мы рассмотрим несколько различных подходов к построению атаки с использованием веб-кэша.

#### 1. Определение целевой конечной точки
##### Что это значит?
Нужно найти URL (например, `/account.php`, `/settings.php`, `/profile`), который:
- Возвращает **динамический контент** (например, личные данные пользователя).
- Поддерживает HTTP-методы `GET`, `HEAD` или `OPTIONS` (так как они обычно не изменяют состояние сервера и могут кэшироваться).

##### Зачем это нужно?
- Атака работает только если сервер отдаёт **конфиденциальные данные** в ответ на "безопасные" методы (`GET`/`HEAD`/`OPTIONS`).
- Если конечная точка требует `POST` или `PUT`, она обычно не кэшируется, и атака не сработает.

#### 2. Определение несоответствия в обработке URL

##### Что это значит?
Нужно найти разницу в том, как:
- **Сервер** обрабатывает URL (например, игнорирует часть пути).
- **Кэш** обрабатывает URL (например, считает его статическим файлом).

##### Типичные несоответствия:
1. **Сопоставление URL с ресурсами**
    - Сервер может отдавать `/profile.php/anything` как `/profile.php`, а кэш — считать это отдельным ресурсом.
2. **Обработка символов-разделителей**
    - Например, `/profile.php%3Ffake.css` может интерпретироваться сервером как `/profile.php`, а кэш его как CSS-файл.
3. **Нормализация пути**
    - Сервер может нормализовать `/profile.php/../index.php` в `/index.php`, а кэш — нет.

##### **Зачем это нужно?**
Чтобы заставить кэш сохранить **чужие личные данные** под ключом, который атакующий сможет запросить.

##### Пример:
- Если сервер отдаёт `/account.php/nonexistent.css` как `account.php`, а кэш сохраняет это как `nonexistent.css`, то атакующий может запросить `nonexistent.css` и получить чужие данные.


#### Примечание Использование кэш-блокировщика
При тестировании на несоответствия и создании эксплойта обмана веб-кэша убедиться, что каждый отправляемый нами запрос имеет другой ключ кэша. В противном случае могут быть предоставлены кэшированные ответы, что повлияет на результаты теста.

Поскольку и URL-путь, и любые параметры запроса обычно включены в ключ кэша, мы можем изменить ключ. Автоматизировать этот процесс с помощью расширения Param Miner. Для этого после установки расширения нужно щелкнуть меню верхнего уровня **Param miner > Settings** , затем выберите **Add dynamic cachebuster** . Теперь Burp добавляет уникальную строку запроса к каждому сделанному нами запросу. Мы можем просмотреть добавленные строки запроса на вкладке **Logger**.

