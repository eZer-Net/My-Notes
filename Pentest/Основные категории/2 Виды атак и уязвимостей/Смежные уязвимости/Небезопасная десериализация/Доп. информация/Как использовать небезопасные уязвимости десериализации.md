### Как определить небезопасную десериализацию
Выявление небезопасной десериализации относительно просто, независимо от того, проводим мы тестирование по методу белого или черного ящика.

#### Формат сериализации PHP
PHP использует в основном человекочитаемый формат строки, в котором буквы представляют тип данных, а числа представляют длину каждой записи. Например, рассмотрим `User`объект с атрибутами:
```
$user->name = "carlos"; 
$user->isLoggedIn = true;
```
После сериализации этот объект может выглядеть примерно так:
```
O:4:"User":2:{s:4:"name":s:6:"carlos"; s:10:"isLoggedIn":b:1;}
```
Это можно интерпретировать следующим образом:
- `O:4:"User"`- Объект с 4-х символьным именем класса`"User"`
- `2`- объект имеет 2 атрибута
- `s:4:"name"`- Ключ первого атрибута — это строка из 4 символов.`"name"`
- `s:6:"carlos"`- Значение первого атрибута — строка из 6 символов.`"carlos"`
- `s:10:"isLoggedIn"`- Ключ второго атрибута — строка из 10 символов.`"isLoggedIn"`
- `b:1`- Значение второго атрибута - логическое значение.`true`
==Собственные методы сериализации PHP — это `serialize()`и `unserialize()`.== Если у нас есть доступ к исходному коду, то следует начать с поиска `unserialize()`в любом месте кода и дальнейшего изучения.

#### Формат сериализации Java
Некоторые языки, такие как Java, используют двоичные форматы сериализации. 
	Это сложнее для чтения, но вы все равно можете идентифицировать сериализованные данные, если знаете, как распознать несколько контрольных признаков. 
Например, сериализованные объекты Java всегда начинаются с одних и тех же байтов, которые кодируются как `ac ed` в шестнадцатеричном формате, так и `rO0`в Base64.

Любой класс, реализующий интерфейс, `java.io.Serializable`может быть сериализован и десериализован. Если у нас есть доступ к исходному коду, ==обратить внимание на любой код, который использует `readObject()`метод==, который используется для чтения и десериализации данных из `InputStream`.

### Манипулирование сериализованными объектами
Эксплуатация некоторых уязвимостей десериализации может быть такой же простой, как изменение атрибута в сериализованном объекте. Поскольку состояние объекта сохраняется, мы можем изучить сериализованные данные, чтобы определить и отредактировать интересные значения атрибутов. Затем мы можем передать вредоносный объект на веб-сайт через процесс его десериализации. Это начальный шаг для базового эксплойта десериализации.

В целом, есть два подхода, которые мы можем использовать при манипулировании сериализованными объектами. Мы можем либо 
- редактировать объект непосредственно в форме потока байтов
- либо написать короткий скрипт на соответствующем языке, чтобы создать и сериализовать новый объект самостоятельно. 
Последний подход часто проще при работе с двоичными форматами сериализации.

### Изменение атрибутов объекта
В качестве простого примера рассмотрим веб-сайт, который использует сериализованный `User`объект для хранения данных о сеансе пользователя в cookie. Если злоумышленник обнаружит этот сериализованный объект в HTTP-запросе, он может декодировать его, чтобы найти следующий поток байтов:
```
O:4:"User":2:{s:8:"username";s:6:"carlos";s:7:"isAdmin";b:0;}
```
- Атрибут `isAdmin`— очевидный интересный момент. 

Злоумышленник может просто изменить логическое значение атрибута на `1`(true), перекодировать объект и перезаписать свой текущий файл cookie этим измененным значением. В отрыве от всего этого это не имеет никакого эффекта. Однако предположим, что веб-сайт использует этот файл cookie для проверки того, имеет ли текущий пользователь доступ к определенным административным функциям:
```
$user = unserialize($_COOKIE); 

if ($user->isAdmin === true) { 
	// allow access to admin interface 
}
```
Этот уязвимый код создаст экземпляр `User`объекта на основе данных из cookie, включая атрибут, измененный злоумышленником `isAdmin`. **Ни в какой момент подлинность сериализованного объекта не проверяется**. Затем эти данные передаются в условный оператор и, в этом случае, допускают легкое повышение привилегий.

Этот простой сценарий не является распространенным в дикой природе.

### Изменение типов данных
Также возможно предоставлять неожиданные типы данных.

Логика на основе PHP особенно уязвима для такого рода манипуляций из-за поведения ее нестрогого оператора сравнения ( `==`) при сравнении различных типов данных.  Например, если мы выполняем нестрогое сравнение между целым числом и строкой, ==PHP попытается преобразовать строку в целое число, что означает, что оно `5 == "5"`оценивается как `true`.==

Необычно, но ==это также работает для любой буквенно-цифровой строки, которая начинается с числа==. В этом случае PHP фактически преобразует всю строку в целое значение на основе начального числа. Остальная часть строки полностью игнорируется. Поэтому `5 == "5 of something"` на практике рассматривается как `5 == 5`.

==Аналогично, в PHP 7.x и более ранних версиях== результатом сравнения `0 == "Example string"`будет `true`, поскольку ==PHP обрабатывает всю строку как целое число `0`.==

Рассмотрим случай, когда этот свободный оператор сравнения используется в сочетании с контролируемыми пользователем данными из десериализованного объекта. Это может потенциально привести к опасным логическим ошибкам.
```
$login = unserialize($_COOKIE) 

if ($login['password'] == $password) { 
	// log in successfully 
}
```
- Допустим, легитимный сериализованный объект выглядит так:
```
$user = [
    'username' => 'admin',
    'password' => 'strongpass123'
];
echo serialize($user);
```
- Атакующий модифицирует объект меняя `password` на `0` (int):
```
$malicious = [
    'username' => 'admin',
    'password' => 0
];
echo serialize($malicious);

a:2:{s:8:"username";s:5:"admin";s:8:"password";i:0;}
```
- Теперь, если передать эту строку в `$_COOKIE['auth']`, проверка:
```
if (0 == "strongpass123")  // true!
```

Если бы пароль приходил напрямую из `$_POST` или `$_GET`, PHP автоматически привёл бы его к строке:
```
$password = $_POST['password'];  // "0" (string)
if ("0" == "strongpass123")  // false (нормальная проверка)
```
- Но **десериализация сохраняет тип `int`**, поэтому `0` остаётся числом.

#### Примечание
==В PHP 8 и более поздних версиях `0 == "Example string"`сравнение оценивается как `false`, поскольку строки больше не преобразуются неявно в `0` во время сравнений.== В результате этот эксплойт невозможен в этих версиях PHP.
- Поведение при сравнении буквенно-цифровой строки, начинающейся с цифры, в PHP 8 остается прежним. Таким образом, `5 == "5 of something"`по-прежнему рассматривается как `5 == 5`.

Иметь в виду, что при изменении типов данных в любом формате сериализованных объектов важно не забыть обновить все метки типов и индикаторы длины в сериализованных данных. В противном случае сериализованный объект будет поврежден и не будет десериализован.
