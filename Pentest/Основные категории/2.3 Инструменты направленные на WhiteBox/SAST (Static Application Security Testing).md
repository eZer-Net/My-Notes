SAST — это **статический анализ кода** без его выполнения. Инструменты анализируют исходный код, бинарные файлы или конфигурации на наличие уязвимостей.

Для анализа кода SAST использует несколько ключевых структур данных:

#### **AST (Abstract Syntax Tree) — Абстрактное синтаксическое дерево**
AST — это дерево, которое отражает структуру кода. Оно строится на этапе компиляции/интерпретации.

**Пример:**  
Код:
```
int x = 10 + y;
```
AST для этого кода:
```
	=
  /   \
x      +
	  /  \
	10    y
```
- Позволяет понять, какие операции выполняются.
- Показывает связи между переменными и выражениями.
- Используется для поиска некорректных конструкций (например, небезопасных вызовов функций).

#### **CFG (Control Flow Graph) — Граф потока управления**
CFG показывает, как выполняется программа: какие блоки кода выполняются последовательно, а где есть ветвления (if, for, while и т. д.).

**Пример:**  
Код:
```
if (x > 0) {
    y = 10;
} else {
    y = 20;
}
z = y;
```
CFG:
```
      [x > 0?]
       /    \
 [y = 10]  [y = 20]
       \    /
       [z = y]
```
- Показывает все возможные пути выполнения программы.
- Позволяет находить недостижимый код или потенциальные бесконечные циклы.
- Используется для анализа условий, которые могут привести к уязвимостям (например, непроверенные условия перед опасными операциями).

#### **DFG (Data Flow Graph) — Граф потока данных**
DFG показывает, как данные перемещаются между переменными и операциями.

**Пример:**  
Код:
```
a = input(); // пользовательский ввод
b = a + 5;
print(b);
```
DFG:
```
input() → a → b → print()
```
- Позволяет отслеживать, откуда берутся данные (например, из пользовательского ввода) и куда передаются.
- Используется для поиска уязвимостей, связанных с некорректной обработкой данных (например, SQL-инъекции).

#### **Taint Analysis — Анализ "заражённых" данных**
Это расширенный анализ потока данных, который отслеживает **опасные данные** (например, пользовательский ввод) и проверяет, не используются ли они в опасных операциях (SQL-запросах, командах ОС и т. д.) без проверки.

**Пример уязвимости:**
```
userInput = request.getParameter("username"); // опасные данные!
query = "SELECT * FROM users WHERE name = '" + userInput + "'"; // SQL-инъекция!
```
**Как работает taint analysis**
1. Помечает `userInput` как "заражённый" (tainted).
2. Отслеживает, куда передаётся `userInput`.
3. Если `userInput` попадает в SQL-запрос без проверки — сообщает об уязвимости.
**Как помогает SAST?**
- Находит уязвимости, связанные с неправильной обработкой данных (SQL-инъекции, XSS, RCE).
- Показывает, где нужны проверки (санитизация, экранирование).

#### **Вывод: как SAST использует эти структуры**
1. **Строит AST** → понимает структуру кода.
2. **Строит CFG** → анализирует возможные пути выполнения.
3. **Строит DFG** → отслеживает передачу данных.
4. **Применяет taint analysis** → ищет опасные данные в уязвимых местах.

### **Примеры инструментов:**

##### **[[SonarQube]]**: Многоязычный анализатор кода.

- **Основные структуры:** AST + CFG + частично DFG.
- **Как работает:**
    - Строит AST и CFG для поиска ошибок в структуре кода.
    - Использует простой анализ потока данных (но не такой глубокий, как Checkmarx).

- **Плюсы:**
    - Находит баги, code smells, уязвимости.
    - Поддерживает много языков.
- **Минусы:**
    - Менее точен в сложных security-уязвимостях (например, SQL-инъекциях с кастомными фильтрами).
##### **Checkmarx**: Enterprise-решение для анализа кода.

- **Основные структуры:** AST + CFG + DFG + taint analysis.
- **Как работает:**
    - Строит полный граф потока данных (DFG).
    - Применяет taint analysis для отслеживания опасных данных.
    - Может найти уязвимость, даже если данные прошли через несколько функций.

- **Плюсы:**
    - Находит сложные уязвимости (например, Second-Order SQLi).
    - Меньше ложных срабатываний.
- **Минусы:**
    - Медленнее Semgrep/SonarQube.
    - Сложнее в настройке.
##### **Bandit**: Специализирован на Python.

##### **[[Semgrep]]**: Универсальный инструмент для статического анализа.

- **Основная структура:** AST (синтаксическое дерево).
- **Как работает:** Ищет шаблоны в AST (например, «вызов `eval()` с аргументом из пользовательского ввода»).

- **Плюсы:**
	- Быстрый, не требует сложного анализа.
	- Хорош для простых правил (например, запрет `md5()`).
	- Не требует taint mode (Это не просто поиск паттерна небезопасного вызова но и определяем источник который подставляется в вызов небезопасный)
- **Минусы:**
	- Не отслеживает поток данных (DFG/taint), поэтому может пропустить сложные уязвимости.

### **Что ищут и как работают:**
- Уязвимости (SQLi, XSS, инъекции).
- Проблемы с безопасностью (жестко закодированные пароли, утечки данных).
- Нарушения стандартов кодирования.

**Пример кода:**
```
String userInput = request.getParameter("id"); // источник
String query = "SELECT * FROM users WHERE id = " + userInput; // уязвимость
```
- **Semgrep:** Найдёт по шаблону `"SELECT ..." + input`.
- **SonarQube:** Заметит конкатенацию SQL-запроса, но может пропустить, если код сложнее.
- **Checkmarx:** Отследит, что `userInput` идёт извне и попадает в SQL без проверки.