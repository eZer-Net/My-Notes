
Некоторые системы содержат внутренние API, к которым нет прямого доступа из Интернета. Загрязнение параметров на стороне сервера происходит, когда веб-сайт встраивает пользовательский ввод в запрос на стороне сервера к внутреннему API без адекватного кодирования. Это означает, что злоумышленник может манипулировать параметрами или вводить их, что позволит им, например:

- Переопределить существующие параметры.
- Измените поведение приложения.
- Доступ к несанкционированным данным.

Уязвимыми могут быть параметры запроса, поля формы, заголовки и параметры URL-адреса

## Тестирование на загрязнение параметров на стороне сервера в строке запроса

Чтобы проверить наличие загрязнения параметров на стороне сервера в строке запроса, можно поместить символы синтаксиса запроса, например `#`, `&`, и `=` в своем вводе и наблюдать, как реагирует приложение.

Рассмотрим уязвимое приложение, позволяющее искать других пользователей по их имени. Когда мы ищем пользователя, наш браузер делает 
следующий запрос:  `GET /userSearch?name=peter&back=/home`

Чтобы получить информацию о пользователе, сервер запрашивает внутренний API со следующим запросом: `GET /users/search?name=peter&publicProfile=true`
#### Усечение строк запроса
Можно использовать [[ URL-кодировки|URL-кодированный]] ==`#` символ, чтобы попытаться обрезать запрос на стороне сервера.== Чтобы облегчить интерпретацию ответа, также можно добавить строку после `#` характер.

Например, изменить строку запроса на следующую:
`GET /userSearch?name=peter%23foo&back=/home`

Интерфейсная часть попытается получить доступ к следующему URL-адресу:
`GET /users/search?name=peter#foo&publicProfile=true`
Всё что после # (%23) не обрабатывается

Просмотрите ответ, чтобы узнать, был ли запрос усечен. Например, если ответ возвращает пользователя `peter`, запрос на стороне сервера мог быть усечен. Если `Invalid name` возвращается сообщение об ошибке, возможно, приложение обработало `foo` как часть имени пользователя. Это говорит о том, что запрос на стороне сервера, возможно, не был усечен.

Если мы можем усечь запрос на стороне сервера, это устраняет необходимость в `publicProfile` поле должно быть установлено в значение true. Возможно, можно использовать это для возврата закрытых профилей пользователей.
#### Вставка недопустимых параметров
Можно использовать URL-кодированный ==`&`символ, чтобы попытаться добавить второй параметр к серверному запросу.==

Например, изменить строку запроса следующим образом:
`GET /userSearch?name=peter%26foo=xyz&back=/home`

Это приводит к следующему серверному запросу к внутреннему API:
`GET /users/search?name=peter&foo=xyz&publicProfile=true`

Просмотрите ответ на предмет подсказок о том, как анализируется дополнительный параметр. Например, если ответ не изменился, это может означать, что параметр был успешно внедрен, но проигнорирован приложением.

Чтобы составить более полную картину, нам необходимо провести дополнительные испытания.
#### Ввод допустимых параметров
Если нам удалось изменить строку запроса, то можно попытаться добавить второй допустимый параметр в запрос на стороне сервера.

Например, если мы определили `email`параметр, то можно добавить его в строку запроса следующим образом: `GET /userSearch?name=peter%26email=foo&back=/home`

Это приводит к следующему серверному запросу к внутреннему API:
`GET /users/search?name=peter&email=foo&publicProfile=true`

Просмотрите ответ на предмет подсказок о том, как анализируется дополнительный параметр.
#### Переопределение существующих параметров
Чтобы подтвердить, уязвимо ли приложение к загрязнению параметров на стороне сервера, мы можем попробовать переопределить исходный параметр. Внедрив второй параметр с тем же именем.

Например, можно изменить строку запроса следующим образом:
`GET /userSearch?name=peter%26name=carlos&back=/home`

Это приводит к следующему серверному запросу к внутреннему API:
`GET /users/search?name=peter&name=carlos&publicProfile=true`

Внутренний API интерпретирует два `name`параметра. ==Влияние этого зависит от того, как приложение обрабатывает второй параметр. Это различается в зависимости от различных веб-технологий. Например:==

- PHP анализирует только последний параметр. Это приведет к поиску пользователем `carlos`.

- ASP.NET объединяет оба параметра. Это приведет к поиску пользователем `peter,carlos`, что может привести к `Invalid username`сообщению об ошибке.

- Node.js / express анализирует только первый параметр. Это приведет к поиску пользователя `peter`, что даст неизменный результат.

Если мы можем переопределить исходный параметр, то можно провести эксплойт. Например, добавить `name=administrator`к запросу. Это может позволить войти в систему как администратор.

Аналогичный пример, но где пользовательский ввод на стороне клиента находится в данных JSON. Когда мы редактируете свое имя, ваш браузер отправляет следующий запрос:
```
POST /myaccount 
{"name": "peter"}
```

Это приводит к следующему запросу на стороне сервера:
```
PATCH /users/7312/update 
{"name":"peter"}
```

Мы можем попытаться добавить `access_level` параметр запроса следующим образом:
```
POST /myaccount 
{"name": "peter\",\"access_level\":\"administrator"}
```

Если пользовательский ввод декодируется, а затем добавляется к данным JSON на стороне сервера без адекватного кодирования, это приводит к следующему запросу на стороне сервера:
```
PATCH /users/7312/update 
{"name":"peter","access_level":"administrator"}
```
Опять же, это может привести к тому, что пользователь `peter` получить доступ администратора.

==В ответах также может происходить внедрение структурированного формата.== Например, это может произойти, если вводимые пользователем данные надежно хранятся в базе данных, а затем внедряются в ответ JSON от внутреннего API без адекватного кодирования. Обычно можно обнаружить и использовать внедрение структурированного формата в ответах так же, как и в запросах.

