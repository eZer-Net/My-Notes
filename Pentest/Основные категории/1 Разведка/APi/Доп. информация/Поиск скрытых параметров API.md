
Когда мы выполняем разведку API, то можем обнаружить недокументированные параметры, которые поддерживает API. Мы можем попытаться эксплуатировать их, чтобы изменить поведение приложения. 
[[Инструмент Burp Suite|Burp]] включает в себя множество инструментов, которые помогут вам выявить скрытые параметры:
- Burp Intruder позволяет автоматически обнаруживать скрытые параметры, используя список слов с общими именами параметров для замены существующих параметров или добавления новых параметров. Убедитесь, что вы также включили имена, которые имеют отношение к приложению, исходя из ваших первоначальных данных.
- BApp [Param Miner](https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943) позволяет автоматически угадывать до 65 536 имен параметров за запрос. Param Miner автоматически угадывает имена, относящиеся к приложению, на основе информации, полученной из области видимости.
- Инструмент [обнаружения контента](https://portswigger.net/burp/documentation/desktop/tools/engagement-tools/content-discovery) позволяет обнаруживать контент, не связанный с видимым контентом, который вы можете просмотреть, включая параметры.

#### Уязвимости массового присвоения
Массовое присвоение — это техника, используемая в программировании, когда данные из внешнего источника (например, формы на веб-сайте или API-запроса) автоматически связываются с полями объекта в коде. Это позволяет разработчикам быстро и удобно обрабатывать данные.
##### Пример кода
Вот как это может выглядеть на языке программирования JavaScript (с использованием Node.js и Express):
```
app.post('/register', (req, res) => {
    const user = new User(req.body); // Здесь происходит массовое присвоение
    user.save();
    res.send('Пользователь зарегистрирован');
});
```
В этом примере req.body содержит данные, отправленные из формы. Если форма содержит поля name, email и password, то они автоматически присваиваются соответствующим свойствам объекта User.

**Проблема с массовым присвоением**

Если не контролировать, какие данные могут быть переданы, злоумышленник может попытаться отправить дополнительные параметры, которые не должны быть доступны. Например:
```
{
    "name": "John",
    "email": "john@example.com",
    "password": "securepassword",
    "isAdmin": true // Это поле не должно быть доступно для обычных пользователей
}
```
Если приложение не проверяет, что переданное поле isAdmin не должно быть установлено пользователем, то обычный пользователь может стать администратором.
##### Определение скрытых параметров
Поскольку массовое назначение создает параметры из полей объекта, мы часто можем идентифицировать эти скрытые параметры, вручную исследуя объекты, возвращаемые API.

Например, рассмотрим `PATCH /api/users/` запрос, который позволяет пользователям обновлять свое имя пользователя и адрес электронной почты и включает следующий JSON: `{ "username": "wiener", "email": "wiener@example.com", }`

Параллельный `GET /api/users/123` запрос возвращает следующий JSON:
`{ "id": 123, "name": "John Doe", "email": "john@example.com", "isAdmin": "false" }`

Это может указывать на то, что скрытый `id` и `isAdmin` параметры привязаны к внутреннему объекту пользователя наряду с обновленными параметрами имени пользователя и электронной почты.
##### Тестирование уязвимостей массового назначения
Чтобы проверить, можем ли мы изменить перечисленные `isAdmin` значение параметра, добавим его в `PATCH` запрос:
`{ "username": "wiener", "email": "wiener@example.com", "isAdmin": false, }`

Кроме того, отправим `PATCH` запрос с недействительным `isAdmin` значение параметра:
`{ "username": "wiener", "email": "wiener@example.com", "isAdmin": "foo", }`

==Если приложение ведет себя по-другому, это может означать, что недопустимое значение влияет на логику запроса, а допустимое значение — нет.== Это может указывать на то, что параметр может быть успешно обновлен пользователем.
