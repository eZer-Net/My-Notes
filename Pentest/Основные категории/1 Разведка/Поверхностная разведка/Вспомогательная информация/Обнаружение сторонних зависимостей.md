**Большинство современных веб-приложений представляет собой комбинацию внутреннего и внешнего кода**, ==объединенного с помощью какого-либо метода интеграции==. Внешние фрагменты приложения могут быть чьей-либо собственностью (в этом случае интеграция осуществляется в рамках определенной модели лицензирования) или бесплатными (как правило, из сообществ разработчиков ПО с открытым исходным кодом). Их использование не всегда безопасно, ведь зачастую интегрированные фрагменты не проверяются так же строго, как и внутренний код.

В процессе предварительного сбора данных, скорее всего, встретятся **множество сторонних фрагментов, и крайне желательно внимательно изучить как сам код, так и метод его интеграции. Часто это может подсказать вектор атаки**. Иногда уязвимость стороннего кода хорошо известна, и тогда, возможно, даже не придется готовить атаку самостоятельно. Ее можно будет просто скопировать из базы данных общеизвестных уязвимостей **(Common Vulnerabilities and Exposures, CVE)**.

## Клиентские фреймворки

Часто вместо самостоятельного построения сложной инфраструктуры пользовательского интерфейса разработчики берут хорошо поддерживаемые и тщательно протестированные готовые решения. **Это может быть:** 
- Библиотека [[Pentest/Термины#SPA (Single-page application)|SPA]] для обработки сложных состояний
- Фреймворк, добавляющий недостающую функциональность в JSc (Lodash, JQuery)
- Фреймворк CSS для улучшения внешнего вида сайта (Bootstrap, Bulma)

==Все три вида фреймворков легко распознаются. И если вы сможете определить номер версии, в Сети часто получится обнаружить сведения о существующих уязвимостях ReDoS, Prototype Pollution и XSS.== В частности, это касается старых версий, оставленных без обновлений.


**Одни из крупнейших фреймворки для SPA:**
- EmberJS (LinkedIn, Netflix);
- AngularJS (Google);
- React (Facebook);
- VueJS (Adobe, GitLab).

Каждый из них имеет особый синтаксис и порядок управления элементами DOM и взаимодействия разработчика с платформой. Не все фреймворки легко обнаруживаются. Иногда требуется процедура идентификации (fingerprinting). **Узнав версию фреймворка, обязательно записать!**

#### EmberJS

Обнаружить фреймворк EmberJS довольно легко, потому что при начальной загрузке он устанавливает глобальную переменную Ember, видимую в консоли браузера
![[Pasted image 20250104190035.png]]

**Кроме того, ко всем элементам DOM этот фреймворк добавляет ember-id для внутреннего использования. Это означает, что если открыть дерево DOM любой веб-страницы на вкладке Elements «Инструментов разработчика», вы увидите блоки div с id = ember1, id = ember2, id = ember3 и т. д.** Каждый из них заключен в родительский элемент class = "ember-application", в свою очередь входящий в элемент body.

**Определить запущенную версию фреймворка Ember** легко. Просто посмотрите
значение константы, прикрепленной к глобальному объекту Ember:
`console.log(Ember.VERSION);`

#### AngularJS

**Более старые версии фреймворка Angular дают глобальный объект**, аналогичный объекту EmberJS . Он называется angular , а узнать версию помогает свойство angular.version. 
**В версии AngularJS 4.0+ этого глобального объекта уже нет**, что немного усложняет ситуацию. Вы можете определить, запущено ли приложение AngularJS 4.0+, проверив через консоль существование глобального объекта ng.

Для определения версии придется постараться чуть больше. Для начала возьмите все корневые элементы приложения AngularJS и проверьте атрибуты первого из них. У него должен быть атрибут ng-version, который и покажет версию исследуемого приложения:
```
	// возвращает массив корневых элементов
	const elements = getAllAngularRootElements();
	const version = elements[0].attributes['ng-version'];
	// ng-version="6.1.2"
	console.log(version);
```

#### React

Библиотеку с открытым исходным кодом для разработки пользовательских интерфейсов React можно идентифицировать по глобальному объекту React, а узнать версию позволяет соответствующая константа:
```
	const version = React.version;
	// 0.13.3
	console.log(version);
```

**Кроме того, в сценарии можно заметить теги text/jsx, ссылающиеся на файлы специального формата, в которых одновременно содержится JavaScript, CSS и HTML**. Они однозначно указывают на то, что вы работаете с приложением React. Знание того, что все части компонентов находятся в одном файле .jsx, может значительно упростить их исследование.

#### VueJS

Фреймворк VueJS тоже предоставляет глобальный объект Vue и константу для определения версии:
```
	
	const version = Vue.version;
	// 2.6.10
	console.log(version);
	
```
Если вы не можете проверить элементы приложения VueJS, скорее всего, оно настроено игнорировать «Инструменты разработчика». Это делается с помощью свойства глобального объекта Vue. Если установить для него значение true, проверка компонентов VueJS в консоли браузера снова станет доступной:
```
	// Теперь компоненты Vue можно проверять
	Vue.config.devtools = true;
```

#### Библиотеки JavaScript

Существует множество вспомогательных библиотек JavaScript. Глобальные объекты некоторых из них открыты, а другие никак себя не проявляют. Многие библиотеки JavaScript используют глобальные объекты верхнего уровня для пространства имен своих функций. Такие библиотеки очень легко обнаружить и просмотреть
![[Pasted image 20250104190934.png]]

Библиотеки Underscore и Lodash открывают глобальные объекты с помощью символа $, а JQuery использует пространство имен $, но за пределами основных библиотек лучше выполнить запрос, чтобы увидеть все внешние сценарии, загруженные на страницу.

Для быстрого поиска всех импортированных в документ сценариев применяется метод querySelectorAll:
```
	/*
	* Функция обхода DOM используется для быстрой генерации
	* списка тегов <script>, импортированных на текущую страницу
	*/
	const getScripts = function() {
		/*
		* Селектор может начинаться с "." при поиске класса CSS,
		* с "#" при поиске атрибута `id` или не иметь префикса,
		* если ищется HTML-элемент.
		*
		* Сейчас 'script' ищет все экземпляры тега <script>.
		*/
		const scripts = document.querySelectorAll('script');
		
		/*
		* Просматриваем все элементы `<script>`, проверяя,
		* содержат ли они непустой атрибут src.
		*/
		scripts.forEach((script) => {
			if (script.src) {
				console.log(`i: ${script.src}`);
			}
		});
	};

```
Вызов этой функции даст вот такой результат:
```
getScripts();
VM183:5 i: https://www.google-analytics.com/analytics.js
VM183:5 i: https://www.googletagmanager.com/gtag/js?id=UA-1234
VM183:5 i: https://js.stripe.com/v3/
VM183:5 i: https://code.jquery.com/jquery-3.4.1.min.js
VM183:5 i: https://cdnjs.cloudflare.com/ajax/libs/d3/5.9.7/d3.min.js
VM183:5 i: /assets/main.js

```
После этого остается по очереди изучить все сценарии, чтобы определить порядок, конфигурации и т. п.

#### Библиотеки CSS

Для поиска библиотек CSS алгоритм обнаружения сценариев слегка изменяется:
```
	/*
	* Используем встроенную в браузер функцию обхода DOM
	* для быстрого сбора всех элементов `<link>`, содержащих
	* атрибут `rel` со значением `stylesheet`.
	*/
	const getStyles = function() {
		const scripts = document.querySelectorAll('link');
		
		/*
		* По очереди просматриваем все сценарии, проверяя наличие у
		* элемента `link` атрибута `rel` со значением `stylesheet`.
		*
		* Link — элемент, чаще всего используемый для загрузки таблиц
		* стилей CSS, но также для предварительной загрузки, иконок
		* или поиска
		*/
		scripts.forEach((link) => {
			if (link.rel === 'stylesheet') {
				console.log(`i: ${link.getAttribute('href')}`);
			}
		});
	};
```
Эта функция даст список импортированных файлов CSS:
```
getStyles();
VM213:5 i: /assets/jquery-ui.css
VM213:5 i: /assets/boostrap.css
VM213:5 i: /assets/main.css
VM213:5 i: /assets/components.css
VM213:5 i: /assets/reset.css
```

## Фреймворки на стороне сервера

Определить, какой софт работает на стороне клиента (в браузере), намного проще, чем узнать, что работает на сервере.

В большинстве случаев необходимый для клиента код загружается и сохраняется в памяти, доступной через DOM. Некоторые сценарии могут загружаться сразу или асинхронно после загрузки страницы, но доступ к ним осуществляется только при выполнении определенных условий.

Определить зависимости на стороне сервера намного сложнее, но зачастую возможно и это. **Иногда остаются отчетливые следы в HTTP-трафике (заголовки, необязательные поля), иногда — незащищенные конечные точки.** Для обнаружения серверных фреймворков требуется хорошо в них разбираться, но, к счастью, как и в случае с клиентскими фреймворками, **чаще всего используется небольшой набор пакетов**. И если запомнить, как распознать самые популярные из них, это поможет во многих случаях.

#### Заголовки

Иногда из-за небезопасных настроек серверного фреймворка заголовки содержат слишком много данных. Например, заголовок X-Powered-By открыто сообщает имя и версию веб-сервера. Причем в более старых версиях [[Веб-сервера#IIS от Microsoft|Microsoft IIS]] эта настройка включена по умолчанию.

Сделав любой запрос к одному из таких уязвимых веб-серверов, и в ответе увидите такое значение:
`X-Powered-By: ASP.NET`
Если повезет, веб-сервер может даже предоставить дополнительную информацию:
```
	Server: Microsoft-IIS/4.5
	X-AspNet-Version: 4.0.25
```
Умные администраторы серверов отключают эти заголовки, а дальновидные группы разработчиков удаляют эти настройки из конфигурации по умолчанию. Тем не менее до сих пор существует множество сайтов, показывающих эти заголовки кому угодно.

#### Стандартные сообщения об ошибке и страницы 404

Некоторые популярные фреймворки не позволяют легко определять номер используемой версии. Тогда можно попробовать определить версию с помощью цифрового отпечатка.

Большинство веб-серверов предоставляют сообщения об ошибках и страницы 404, которые показываются пользователям до тех пор, пока владелец веб-приложения не заменит их собственным вариантом. Они могут дать довольно много информации о настройках сервера. Например, не только о серверном ПО, но и о его версии или диапазоне. 

Ruby on Rails — один из крупнейших фреймворков с открытым исходным кодом.
Например, у полнофункциональной платформы веб-приложений Ruby on Rails есть страница 404 в виде HTML-страницы с полем The page you were looking for doesn’t exist («Страницы, которую вы искали, не существует»)
![[Pasted image 20250104194035.png]]

Код HTML этой страницы находится в репозитории GitHub для Ruby on Rails (https://github.com/rails/rails ) по ссылке rails/railties/lib/rails/generators/rails/app/templates/public/404.html
Скачав репозиторий командой и проанализируем изменения, вносившиеся в эту страницу, воспользовавшись командой `git log | grep 404.` Это даст интересные фрагменты информации, например:
- Апрель 20, 2017 — CSS-селекторы ограничили только элементами, принадлежащими к конкретному пространству имен.
- Ноябрь 21, 2013 — Символ U+00A0 заменен обычным пробелом.
- Апрель 5, 2012 — Удален атрибут type, который в версии HTML5 стал необязательным.

Теперь, если при тестировании приложения вы наткнетесь на страницу 404, **можно выполнить поиск атрибута type = "text/css". Если поиск окажется успешным, значит, вы имеете дело с версией Ruby on Rails, появившейся до 5 апреля 2012 года.**

Обнаружение символа U+00A0 означает, что перед вами версия, появившаяся
до 21 ноября 2013 года.

Можно поискать CSS-селекторы, ограниченные конкретным пространством имен, .rails-default-error-page. Если их нет, значит, вы имеете дело с версией, выпущенной до 20 апреля 2017 года.

**Пример расследования** 
	Предположим, на странице 404 тестируемого приложения уже нет атрибута type, неразрывные пробелы заменены обычными, но CSS-селекторы еще не ограничены пространством имен. Теперь на сайте системы управления пакетами для языка Ruby https://rubygems.org/gems/rails/versions можно посмотреть, какие версии выходили в этом временном диапазоне. В указанный период попадают версии Ruby on Rails от 3.2.16 до 4.2.8. При этом известно, что в версиях с 3.2.x до 4.2.7 была хорошо документированная XSS-уязвимость, фигурирующая в базе уязвимостей под идентификатором CVE-2016-6316.


Разумеется, описанные методы применимы не только к Ruby on Rails, но и к любым сторонним зависимостям. **Главное, определить, что это за софт и какая его версия интегрирована в приложение.**

#### Базы данных

Большинство веб-приложений для хранения состояний пользователей, объектов и других данных использует серверные базы (например, MySQL или MongoDB).

Если сообщения об ошибках отправляются клиенту напрямую, для определения базы данных можно воспользоваться методом, описанным в предыдущем разделе. Но такая удача выпадает нечасто, поэтому необходимы альтернативные пути поиска информации.

Альтернативный путь это сканированием ==первичного ключа==. **Так называют ключ в таблице ([[SQL|SQL]]) или документе ([[NoSQL|NoSQL]]), который автоматически генерируется при создании объекта и используется для быстрого поиска по БД.**

Метод генерации этих ключей свой для каждой базы, а иногда и настраивается под особые запросы (например, более короткие ключи для использования в URL-адресах).

Примеры:
- **MongoDB**, которая считается классическим примером NoSQL-системы. 
	По умолчанию в ней для каждого созданного документа генерируется поле _id. Для этого применяется алгоритм хеширования с низким уровнем коллизий, который всегда дает 12-байтовую шестнадцатеричную строку.
	**Пример идентификатора** ObjectId: 507f1f77bcf86cd799439011

- **PostgreSQL** — реляционная СУБД, которая поддерживает автоматическую генерацию первичных ключей с помощью последовательностей (sequences).
	При создании таблицы можно использовать тип данных SERIAL, который автоматически генерирует уникальные целочисленные значения для каждого нового ряда. Например, при добавлении новой записи в таблицу с полем id SERIAL будет создан уникальный идентификатор, например, 1, 2, 3 и так далее.

- **Cassandra** — распределенная NoSQL база данных, использующая концепцию кластерных ключей для генерации уникальных идентификаторов. 
	В Cassandra можно использовать тип данных UUID, который генерируется с помощью встроенной функции uuid(). 
	**Пример может выглядеть так** 550e8400-e29b-41d4-a716-446655440000.

- **Firebase Firestore** — облачная NoSQL база данных от Google, которая автоматически создает уникальные идентификаторы для документов. 
	При добавлении нового документа без явного указания идентификатора Firestore генерирует строку длиной 20 символов, состоящую из букв и цифр.
	**Пример такого идентификатора**: j8VnmLQjY9DJ9WcK7Z6A.

- **Redis** — in-memory NoSQL база данных, которая позволяет использовать различные структуры данных. 
	Для генерации уникальных идентификаторов можно воспользоваться командой INCR, которая увеличивает значение указанного ключа на единицу и возвращает новое значение. **Например, если ключ user:id имеет значение 5, то выполнение команды INCR user:id вернет 6, который можно использовать как уникальный идентификатор.**

- **DynamoDB** — NoSQL база данных от Amazon, которая позволяет пользователю самостоятельно задавать схему ключей. 
	Обычно используется комбинация из Partition Key и Sort Key, где Partition Key может быть строковым или числовым значением, а Sort Key обеспечивает уникальность. 
	**Например, идентификатор может выглядеть так**: user123#2023-01-01.

Иногда идентификаторы встречаются там, где вы меньше всего ожидаете их
увидеть: например, в метаданных или в ответе, касающемся объекта user:
```
	_id: '507f1f77bcf86cd799439011',
	username: 'joe123',
	email: 'joe123@my-email.com',
	role: 'moderator',
	biography: '
```


Где бы не обнаружился первичный ключ, если его можно определить, что это действительно он, можно попытаться найти совпадение с алгоритмами генерации ключей различных БД. Часто этого достаточно, чтобы определить, какую базу данных использует веб-приложение. Иногда может потребоваться комбинация с другим методом (например, с принудительным отображением сообщений об ошибках). Обычно это нужно, когда несколько БД используют один и тот же алгоритм генерации первичных ключей (например, последовательные целые числа или другие простые шаблоны).