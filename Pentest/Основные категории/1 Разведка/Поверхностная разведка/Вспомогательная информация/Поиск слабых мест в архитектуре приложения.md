**Большинства уязвимостей веб-приложения кроется в неправильной архитектуре, а не в плохо прописанных методах.** Несомненно, метод, записывающий пользовательский HTML-код непосредственно в DOM, позволяет при отсутствии надлежащей очистки загрузить сценарий и запустить его на машине другого пользователя ([[Инъекции#Cross-Site Scripting (XSS)|XSS-атака]]).

## Признаки безопасной и небезопасной архитектуры

==Единственная XSS-уязвимость может быть следствием плохо написанного метода. Но множественные уязвимости, скорее всего, указывают на слабую архитектуру приложения.==

**Небезопасное приложение не отклонит сценарий при поступлении в конечную точку API** запроса на сохранение комментария. Не сделает этого и база данных, которая не выполняет надлежащую фильтрацию и очистку строки, представляющей сообщение. В конечном итоге текст загружается в DOM и расценивается как тестовое сообщение test message`<script>alert('hacked');</script>`, в результате чего происходит выполнение сценария.

**Безопасное приложение имеет один или несколько методов защиты**. Но реализация их набора требует слишком много времени, а значит, ее легко упустить из виду. Даже приложение, написанное инженерами с опытом в области защиты приложений, в конечном итоге все равно будет иметь дыры в безопасности, если в его основе лежит изначально небезопасная архитектура.

## Уровни безопасности

Рассматривая архитектуру службы обмена сообщениями, выделили несколько уровней, на которых может возникнуть риск межсайтового скриптинга. Это:
- запрос POST к API;
- запись в базу данных;
- чтение из базы данных;
- запрос GET к API;
- чтение клиентов.

Аналогично обстоят дела с уязвимостями других типов, таких как XXE или CSRF. Недостаточные механизмы защиты приводят к тому, что любая уязвимость может возникать более чем на одном уровне. 

Представим, что гипотетическое **приложение для обмена мгновенными сообщениями добавило механизмы защиты на уровень запросов POST к API**. Очистка получаемых от пользователей сообщений сделает невозможным внедрение стороннего кода. Но позднее может быть разработан и внедрен другой метод отправки сообщений. И **появится новая конечная точка API, принимающая сообщения списком для их массовой рассылки. И если не снабдить ее таким же мощным защитным механизмом, как предыдущую, злоумышленники смогут загружать** сообщения, содержащие сценарии, в базу данных, минуя изначально запланированный разработчиками путь.

## Заимствование и перекрой

Фактором риска становится и желание разработчиков заново «изобрести» существующие технологии. Как правило, это уже проблема не архитектуры, а организации, которая становится заметна в архитектуре.

Подход практикуется множеством компаний, поскольку переделывание инструментов или функциональности дает такие преимущества, как:
- возможность избежать сложного лицензирования;
- возможность добавить дополнительный функционал;
- возможность привлечь внимание пользователей через рекламу нового инструмента или функции.

Кроме того, создавать функциональность с нуля обычно гораздо интереснее и сложнее, чем переделывать существующий бесплатный или платный инструмент.
 «Изобретать велосипед» не всегда плохо, поэтому каждый случай нужно рассматривать индивидуально.


Но с точки зрения безопасности повторное изобретение — не самая лучшая тактика. Разумеется, степень риска зависит от того, какая функциональность разрабатывается с нуля, и может быть как умеренной, так и чрезмерной.
В частности, опытные инженеры по безопасности советуют никогда не использовать собственную криптографию. 

Так как алгоритм хеширования [[Хеши#3. SHA-3|SHA-3]] с открытым исходным кодом разрабатывался почти 20 лет и прошел надежное тестирование Внедрение алгоритма с таким же уровнем тестирования, как SHA-3, обойдется организации в десятки миллионов долларов. При этом проект OpenJDK бесплатно предоставляет реализацию SHA-3, протестированную NIST и сообществом.

Вряд ли одиночка, решивший развернуть собственный алгоритм хеширования, сможет соответствовать таким же стандартам и провести надежное тестирование. 

**Разработчикам веб-приложений не стоит самостоятельно писать функции, требующие глубоких знаний математики, операционных систем или аппаратного обеспечения.**

==Приложения, напичканные самостоятельно написанными базами данных, самодельной криптографией и оптимизацией на аппаратном уровне, зачастую взламываются легче всего.==