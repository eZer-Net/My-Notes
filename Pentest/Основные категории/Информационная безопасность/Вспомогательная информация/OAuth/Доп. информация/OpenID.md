
## Что такое OpenID Connect?

OpenID Connect расширяет протокол OAuth, предоставляя выделенный уровень идентификации и аутентификации, который располагается поверх [[OAuth#Как работает OAuth 2.0?|базовой реализации OAuth]] . Он добавляет некоторые простые функции, которые обеспечивают лучшую поддержку для варианта использования аутентификации OAuth.

  Простые механизмы [[OAuth#OAuth-аутентификация|аутентификации OAuth]] были далеки от идеала. 
  - Для начала, клиентское приложение не имело возможности узнать, когда, где или как пользователь был аутентифицирован. Поскольку каждая из этих реализаций была своего рода индивидуальным обходным путем, не было также стандартного способа запроса пользовательских данных для этой цели. 
  - Для надлежащей поддержки OAuth клиентским приложениям пришлось бы настраивать отдельные механизмы OAuth для каждого провайдера, каждый с разными конечными точками, уникальными наборами областей и т. д.

OpenID Connect решает многие из этих проблем, добавляя стандартизированные функции, связанные с идентификацией, чтобы сделать аутентификацию через OAuth более надежной и единообразной.

## Как работает OpenID Connect?

OpenID Connect аккуратно встраивается в обычные [[Типы грантов OAuth 2.0|потоки OAuth]] С точки зрения клиентского приложения, ключевым отличием является наличие дополнительного стандартизированного набора областей, которые одинаковы для всех поставщиков, и дополнительного типа ответа: `id_token`.

#### Роли OpenID Connect

Роли для OpenID Connect по сути такие же, как и для стандартного OAuth. Главное отличие в том, что спецификация использует немного другую терминологию.

- **Relying party** - Приложение, которое запрашивает аутентификацию пользователя. Это синоним клиентского приложения OAuth.
- **Конечный пользователь** - Пользователь, который проходит аутентификацию. Это синоним владельца ресурса OAuth.
- **Поставщик OpenID** — служба OAuth, настроенная для поддержки OpenID Connect.


### Требования и области действия OpenID Connect

Термин «заявки» относится к `key:value`парам, которые представляют информацию о пользователе на сервере ресурсов. Одним из примеров заявки может быть `"family_name":"Montoya"`.

В отличие от базового OAuth, [[Типы грантов OAuth 2.0#Области действия OAuth|области действия которого уникальны для каждого провайдера]], все службы OpenID Connect используют идентичный набор областей действия. Чтобы использовать OpenID Connect, клиентское приложение должно указать область действия `openid`в запросе на авторизацию. Затем они могут включать одну или несколько других стандартных областей действия:
- `profile`
- `email`
- `address`
- `phone`
Каждая из этих областей соответствует доступу на чтение для подмножества утверждений о пользователе, которые определены в спецификации OpenID. Например, запрос области `openid profile`предоставит клиентскому приложению доступ на чтение для ряда утверждений, связанных с личностью пользователя, таких как `family_name`, `given_name`, `birth_date`, и т. д.


#### Идентификационный токен

Другое важное дополнение, предоставляемое OpenID Connect, — это `id_token`тип ответа. Он возвращает веб-токен JSON (JWT), подписанный веб-подписью JSON (JWS). Полезная нагрузка **JWT содержит список утверждений на основе изначально запрошенной области**. Она также содержит информацию о том, как и когда пользователь был в последний раз аутентифицирован службой OAuth. Клиентское приложение может использовать это, чтобы решить, был ли пользователь достаточно аутентифицирован.

Главным преимуществом использования `id_token`является сокращение количества запросов, которые необходимо отправлять между клиентским приложением и службой OAuth, что может обеспечить лучшую производительность в целом. Вместо того, чтобы получать токен доступа и затем запрашивать данные пользователя отдельно, токен ID, содержащий эти данные, отправляется клиентскому приложению сразу после того, как пользователь прошел аутентификацию.

Вместо того, чтобы просто полагаться на доверенный канал, как это происходит в базовом OAuth, целостность данных, передаваемых в токене ID, основана на криптографической подписи JWT. По этой причине использование токенов ID может помочь защитить от некоторых атак типа «человек посередине». Однако, учитывая, что **криптографические ключи для проверки подписи передаются по тому же сетевому каналу** (обычно представленному на `/.well-known/jwks.json`), некоторые атаки все еще возможны.


## Идентификация OpenID Connect

Если OpenID connect активно используется клиентским приложением, это должно быть очевидно из запроса на авторизацию. Самый надежный способ проверки — посмотреть на обязательную `openid`область действия.
Пример запроса на авторизацию с использованием области openid:
```
GET /authorize?response_type=code
&client_id=YOUR_CLIENT_ID
&redirect_uri=YOUR_REDIRECT_URI
&scope=openid
&state=YOUR_STATE
```

Даже если изначально процесс входа не использует OpenID Connect, все равно стоит проверить, поддерживает ли его служба OAuth. Вы можете просто попробовать добавить `openid`область действия или изменить тип ответа на `id_token`и понаблюдать, приведет ли это к ошибке.

Как и в случае с базовым OAuth, также неплохо было бы взглянуть на документацию провайдера OAuth, чтобы узнать, есть ли там какая-либо полезная информация о поддержке OpenID Connect. Вы также можете получить доступ к файлу конфигурации из стандартной конечной точки 
`https://<your-auth-provider>/.well-known/openid-configuration`.

## Уязвимости OpenID Connect

Спецификация OpenID Connect намного строже, чем у базового OAuth, что означает, что в целом меньше возможностей для причудливых реализаций с вопиющими уязвимостями. Тем не менее, поскольку это всего лишь слой, который находится поверх OAuth, клиентское приложение или служба OAuth все еще могут быть уязвимы для некоторых атак на основе OAuth

#### Незащищенная динамическая регистрация клиента

Спецификация OpenID описывает стандартизированный способ, позволяющий клиентским приложениям регистрироваться у поставщика OpenID. Если поддерживается динамическая регистрация клиента, клиентское приложение может зарегистрироваться, отправив запрос `POST`на выделенную `/registration`конечную точку. Имя этой конечной точки обычно указывается в файле конфигурации и документации.

В теле запроса клиентское приложение отправляет ключевую информацию о себе в формате JSON. Например, часто требуется включить массив URI перенаправления, внесенных в белый список. Оно также может отправить ряд дополнительных сведений, таких как имена конечных точек, которые оно хочет раскрыть, имя своего приложения и т. д. Типичный запрос на регистрацию может выглядеть примерно так:
```
POST /openid/register HTTP/1.1 
Content-Type: application/json 
Accept: application/json 
Host: oauth-authorization-server.com 
Authorization: Bearer ab12cd34ef56gh89 

{ 
	"application_type": "web", 
	"redirect_uris": [ 
		"https://client-app.com/callback", 
		"https://client-app.com/callback2" 
		], 
	"client_name": "My Application", 
	"logo_uri": "https://client-app.com/logo.png", 
	"token_endpoint_auth_method": "client_secret_basic", 
	"jwks_uri": "https://client-app.com/my_public_keys.jwks",
	"userinfo_encrypted_response_alg": "RSA1_5", 
	"userinfo_encrypted_response_enc": "A128CBC-HS256",
	… 
}
```
Поставщик OpenID должен потребовать от клиентского приложения пройти аутентификацию. В приведенном выше примере они используют токен HTTP-носителя. Однако некоторые поставщики разрешают динамическую регистрацию клиентов без какой-либо аутентификации, что позволяет злоумышленнику регистрировать собственное вредоносное клиентское приложение. Это может иметь различные последствия в зависимости от того, как используются значения этих контролируемых злоумышленником свойств.

Например, вы могли заметить, что некоторые из этих свойств могут быть предоставлены как URI. Если к любому из них обращается поставщик OpenID, это может потенциально привести к уязвимостям SSRF второго порядка, если не будут приняты дополнительные меры безопасности.


#### Разрешение запросов на авторизацию по ссылке

Некоторые поставщики OpenID предоставляют возможность передать их в виде веб-токена JSON (JWT). Если эта функция поддерживается, мы можем отправить один `request_uri`параметр, указывающий на веб-токен JSON, содержащий остальные параметры OAuth и их значения. В зависимости от конфигурации службы OAuth этот `request_uri`параметр является еще одним потенциальным вектором для SSRF.

Также можно использовать эту функцию для обхода проверки этих значений параметров. Некоторые серверы могут эффективно проверять строку запроса в запросе авторизации, но могут не применять адекватно ту же проверку к параметрам в JWT, включая `redirect_uri`.

Чтобы проверить, поддерживается ли эта опция, следует поискать `request_uri_parameter_supported`опцию в файле конфигурации и документации. В качестве альтернативы можно просто попробовать добавить `request_uri`параметр, чтобы посмотреть, работает ли он. Мы можем обнаружить, что некоторые серверы поддерживают эту функцию, даже если они явно не упоминают ее в своей документации.
