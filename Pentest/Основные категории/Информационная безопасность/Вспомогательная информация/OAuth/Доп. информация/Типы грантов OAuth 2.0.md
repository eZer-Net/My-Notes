
## Что такое тип гранта OAuth?

[Тип гранта (или поток)](https://portswigger.net/web-security/oauth/grant-types) — это набор шагов, которые определяют, как приложение получает доступ к защищенным ресурсам (например, данным пользователя). Каждый тип гранта имеет свои особенности и используется в разных ситуациях.

Служба OAuth должна быть настроена для поддержки определенного типа гранта, прежде чем клиентское приложение сможет инициировать соответствующий поток. Клиентское приложение указывает, какой тип гранта оно хочет использовать в первоначальном запросе авторизации, который оно отправляет службе OAuth.

Существует несколько различных типов грантов, каждый из которых имеет различные уровни сложности и соображения безопасности.

## Области действия OAuth

Для любого типа гранта OAuth клиентское приложение должно указать, к каким данным оно хочет получить доступ и какие операции оно хочет выполнить. Оно делает это с помощью `scope`параметра запроса на авторизацию, который оно отправляет в службу OAuth.

Некоторые даже используют полный URI в качестве имени области, аналогично конечной точке REST API. Например, при запросе доступа на чтение к списку контактов пользователя имя области может принимать любую из следующих форм в зависимости от используемой службы OAuth:
```
scope=contacts 
scope=contacts.read 
scope=contact-list-r 
scope=https://oauth-authorization-server.com/auth/scopes/user/contacts.readonly
```

Однако, когда для аутентификации используется OAuth, вместо этого часто используются стандартизированные области OpenID Connect. Например, область предоставит клиентскому приложению доступ на чтение к предопределенному набору базовой информации о пользователе, такой как адрес электронной почты, имя пользователя и т. д. [[OpenID|OpenID]]

## Тип предоставления кода авторизации

1. **Инициация потока**
   - Клиентское приложение отправляет пользователя на страницу авторизации службы OAuth.
   - Запрос включает параметры, такие как идентификатор клиента, запрашиваемые разрешения и URL для перенаправления после авторизации.

2. **Авторизация пользователя**
   - Пользователь видит страницу авторизации и получает запрос на предоставление доступа к своим данным.
   - Служба OAuth задает пользователю вопрос: "Согласны ли вы предоставить доступ этому приложению?"

3. **Получение кода авторизации**
   - Если пользователь соглашается, служба OAuth перенаправляет его обратно в клиентское приложение по указанному URL.
   - В URL добавляется параметр с «кодом авторизации», который используется для дальнейших запросов.

4. **Обмен кода на токен доступа**
   - Клиентское приложение отправляет запрос на сервер службы OAuth, передавая полученный код авторизации.
   - Запрос также включает идентификатор клиента, секрет клиента и URL для перенаправления.

5. **Получение токена доступа**
   - Служба OAuth проверяет код авторизации и, если все данные корректны, возвращает «токен доступа» (и, возможно, «токен обновления»).
   - Токен доступа используется клиентским приложением для выполнения API-вызовов и получения данных пользователя.

6. **Доступ к защищенным ресурсам**
   - Клиентское приложение использует токен доступа для выполнения запросов к API службы, чтобы получить соответствующие пользовательские данные.


## Authorization Code Grant (грант кода авторизации)
#### 1. Запрос на авторизацию

Клиентское приложение отправляет запрос в конечную точку сервиса OAuth `/authorization`с просьбой разрешить доступ к определенным данным пользователя. 
У каждого веб сайта может быть своя [[Анализ API#Определение конечных точек API|конечная точка]], поэтому надо ее при разведке идентифицировать на основе параметров, используемых в запросе.
```
GET /authorization?client_id=12345&redirect_uri=https://client-app.com/callback&response_type=code&scope=openid%20profile&state=ae13d489bd00e3c24 HTTP/1.1 
Host: oauth-authorization-server.com
```
**Этот запрос содержит следующие примечательные параметры**, обычно указанные в строке запроса:

- **`client_id`**
    
    Обязательный параметр, содержащий уникальный идентификатор клиентского приложения. Это значение генерируется при регистрации клиентского приложения в сервисе OAuth.
    
- **`redirect_uri`**
    
    URI, на который должен быть перенаправлен браузер пользователя при отправке кода авторизации клиентскому приложению. ==Также известен как "Callback URI" или "Callback Endpoint".== Многие атаки OAuth основаны на использовании недостатков в проверке этого параметра.
    
- **`response_type`**
    
    Определяет, какой тип ответа ожидает клиентское приложение и, следовательно, какой поток оно хочет инициировать. Для типа предоставления кода авторизации значение должно быть `code`.
    
- **`scope`**
    
    Используется для указания подмножества данных пользователя, к которому клиентское приложение хочет получить доступ. Обратите внимание, что это могут быть пользовательские области, заданные поставщиком OAuth, или стандартизированные области, определенные спецификацией [[OpenID|OpenID Connect]].
    
- **`state`**
    
    Сохраняет уникальное, не поддающееся угадыванию значение, привязанное к текущему сеансу в клиентском приложении. Служба OAuth должна возвращать это точное значение в ответе вместе с кодом авторизации. Этот параметр служит формой токена CSRF для клиентского приложения, гарантируя, что запрос к его `/callback`конечной точке исходит от того же человека, который инициировал поток OAuth.

#### 2. Вход пользователя и согласие

Когда сервер авторизации получает первоначальный запрос, он перенаправляет пользователя на страницу входа, где ему будет предложено войти в свою учетную запись у провайдера OAuth. Например, часто это его учетная запись в социальной сети.

Затем им будет представлен список данных, к которым клиентское приложение хочет получить доступ. Это основано на областях, определенных в запросе на авторизацию. Пользователь может выбрать, давать ли согласие на этот доступ или нет.

Важно отметить, что после того, как пользователь одобрил заданную область действия для клиентского приложения, этот шаг будет выполнен автоматически, пока у пользователя все еще есть действующий сеанс со службой OAuth.

#### 3. Предоставление кода авторизации

Если пользователь соглашается на запрошенный доступ, его браузер будет перенаправлен на `/callback`конечную точку, указанную в `redirect_uri`параметре запроса авторизации. 

Результирующий `GET`запрос будет содержать код авторизации в качестве параметра запроса. В зависимости от конфигурации он также может отправлять `state`параметр с тем же значением, что и в запросе авторизации.
```
GET /callback?code=a1b2c3d4e5f6g7h8&state=ae13d489bd00e3c24 HTTP/1.1 
Host: client-app.com
```

#### 4. Запрос токена доступа

После того, как клиентское приложение получает код авторизации, ему необходимо обменять его на токен доступа. Для этого оно отправляет `POST`запрос «сервер-сервер» на конечную точку сервиса OAuth `/token`. Все общение с этого момента происходит по защищенному обратному каналу и, следовательно, обычно не может быть отслежено или проконтролировано злоумышленником.
```
POST /token HTTP/1.1 
Host: oauth-authorization-server.com 
… 
client_id=12345&client_secret=SECRET&redirect_uri=https://client-app.com/callback&grant_type=authorization_code&code=a1b2c3d4e5f6g7h8
```
В дополнение к `client_id`и авторизации `code`вы заметите следующие новые параметры:

- **`client_secret`**
    
    Клиентское приложение должно аутентифицировать себя, включив секретный ключ, который был назначен ему при регистрации в службе OAuth.
    
- **`grant_type`**
    
    Используется для того, чтобы убедиться, что новая конечная точка знает, какой тип предоставления клиентское приложение хочет использовать. В этом случае это должно быть установлено на `authorization_code`.

#### 5. Предоставление токена доступа

Служба OAuth проверит запрос токена доступа. Если все соответствует ожиданиям, сервер отвечает, предоставляя клиентскому приложению токен доступа с запрошенной областью действия.
```
{ 
	"access_token": "z0y9x8w7v6u5", 
	"token_type": "Bearer", 
	"expires_in": 3600, 
	"scope": "openid profile", 
	… 
}
```

#### 6. API-вызов

Теперь, когда у клиентского приложения есть код доступа, оно наконец может получить данные пользователя с сервера ресурсов. Для этого оно делает вызов API к `/userinfo`конечной точке сервиса OAuth. Токен доступа отправляется в `Authorization: Bearer`заголовке, чтобы доказать, что клиентское приложение имеет разрешение на доступ к этим данным.
```
GET /userinfo HTTP/1.1 
Host: oauth-resource-server.com 
Authorization: Bearer z0y9x8w7v6u5
```

#### 7. Ресурсный грант

Сервер ресурсов должен проверить, что токен действителен и принадлежит текущему клиентскому приложению. Если это так, он ответит отправкой запрошенного ресурса, т.е. данных пользователя, на основе области действия токена доступа.

```
{ 
	"username":"carlos", 
	"email":"carlos@carlos-montoya.net", 
	… 
}
```
Клиентское приложение наконец может использовать эти данные по назначению. В случае аутентификации OAuth они обычно используются как идентификатор для предоставления пользователю аутентифицированного сеанса, фактически осуществляя его вход.

## Implicit Grant (неявный грант) 

Неявный тип предоставления гораздо проще. Вместо того, чтобы сначала получить код авторизации, а затем обменять его на токен доступа, клиентское приложение получает токен доступа сразу после того, как пользователь дает свое согласие. **Он гораздо менее безопасен.**

Неявный тип предоставления больше подходит для одностраничных приложений и собственных настольных приложений, которые не могут легко хранить данные `client_secret`на внутреннем сервере и, следовательно, не получают особой выгоды от использования типа предоставления кода авторизации.

#### 1. Запрос на авторизацию

Неявный поток начинается примерно так же, как поток кода авторизации. Единственное существенное отличие заключается в том, что `response_type`параметр должен быть установлен на `token`.
```
GET /authorization?client_id=12345&redirect_uri=https://client-app.com/callback&response_type=token&scope=openid%20profile&state=ae13d489bd00e3c24 HTTP/1.1 
Host: oauth-authorization-server.com
```

#### 2. Вход пользователя и согласие

Пользователь входит в систему и решает, соглашаться ли на запрашиваемые разрешения или нет. Этот процесс точно такой же, как и для потока кода авторизации.


#### 3. Предоставление токена доступа

Если пользователь дает свое согласие на запрошенный доступ, вот тут все начинает отличаться. Служба OAuth перенаправит браузер пользователя на `redirect_uri`указанный в запросе авторизации. Однако вместо отправки параметра запроса, содержащего код авторизации, она отправит токен доступа и другие данные, специфичные для токена, в виде фрагмента URL.
```
GET /callback#access_token=z0y9x8w7v6u5&token_type=Bearer&expires_in=5000&scope=openid%20profile&state=ae13d489bd00e3c24 HTTP/1.1 
Host: client-app.com
```

#### 4. API-вызов

После того, как клиентское приложение успешно извлекло токен доступа из фрагмента URL, оно может использовать его для выполнения вызовов API к `/userinfo`конечной точке сервиса OAuth. В отличие от потока кода авторизации, это также происходит через браузер.
```
GET /userinfo HTTP/1.1 
Host: oauth-resource-server.com Authorization: Bearer z0y9x8w7v6u5
```
#### 5. Ресурсный грант

Сервер ресурсов должен проверить, что токен действителен и принадлежит текущему клиентскому приложению. Если это так, он ответит отправкой запрошенного ресурса, т.е. данных пользователя, на основе области действия, связанной с токеном доступа.
```
{ 
	"username":"carlos", 
	"email":"carlos@carlos-montoya.net" 
}
```


## Сравнение двух гарантов

| Аспект                 | Implicit Grant                                                                                                                                                                                                                                  | Authorization Code Grant                                                                                                                                                                           |
| ---------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Цель использования     | Применяется в клиентских приложениях (например, SPA), где секреты не могут быть безопасно хранимы.                                                                                                                                              | Используется в серверных приложениях, где секреты могут храниться безопасно.                                                                                                                       |
| Процесс аутентификации | Получение токена доступа напрямую через URL.                                                                                                                                                                                                    | Получение временного кода, который затем обменивается на токен доступа.                                                                                                                            |
| Токены                 | Токен доступа возвращается непосредственно в URL.                                                                                                                                                                                               | Код авторизации возвращается, который затем обменивается на токен доступа.                                                                                                                         |
| Безопасность           | Менее безопасен, так как токен доступа передается через URL и может быть перехвачен.                                                                                                                                                            | Более безопасен, так как токен доступа никогда не передается через браузер; используется серверный обмен.                                                                                          |
| Срок действия токена   | Обычно имеет короткий срок действия.                                                                                                                                                                                                            | Может иметь более длительный срок действия, так как используется код.                                                                                                                              |
| Уязвимости             | - Уязвимость к XSS (кросс-сайтовый скриптинг): токены могут быть украдены через вредоносные скрипты. <br> - Уязвимость к CSRF (межсайтовая подделка запроса): злоумышленник может попытаться получить доступ к токену через подделанный запрос. | - Уязвимость к атакам с использованием открытого перенаправления, если не проверяются URI перенаправления. <br> - Уязвимость к перехвату кода, если не используется безопасное соединение (HTTPS). |
