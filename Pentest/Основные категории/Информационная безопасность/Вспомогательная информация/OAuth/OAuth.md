
# Вводная информация

OAuth — это широко используемая структура авторизации, которая позволяет веб-сайтам и веб-приложениям запрашивать ограниченный доступ к учетной записи пользователя в другом приложении.

OAuth позволяет пользователю предоставлять этот доступ, не раскрывая свои учетные данные для входа запрашивающему приложению. Это означает, что пользователи могут точно настроить, какими данными они хотят поделиться, вместо того, чтобы передавать полный контроль над своей учетной записью третьей стороне.

*OAuth 2.0 является текущим стандартом, некоторые веб-сайты все еще используют устаревшую версию 1a. OAuth 2.0 был написан с нуля, а не разработан непосредственно из OAuth 1.0. В результате эти два варианта очень разные.*

# Как работает OAuth 2.0?

OAuth 2.0 изначально был разработан как способ совместного доступа к определенным данным между приложениями. 

**Он работает, определяя ряд взаимодействий между тремя различными сторонами**, а именно: клиентским приложением, владельцем ресурса и поставщиком услуг OAuth.
- **Клиентское приложение** — веб-сайт или веб-приложение, которому требуется доступ к данным пользователя.
- **Владелец ресурса** — пользователь, к данным которого клиентское приложение хочет получить доступ.
- **Поставщик услуг OAuth** — веб-сайт или приложение, которые контролируют данные пользователя и доступ к ним. Они поддерживают OAuth, предоставляя API для взаимодействия как с сервером авторизации, так и с сервером ресурсов.

Существует множество различных способов реализации фактического процесса OAuth. Они известны как «потоки» или «типы грантов» OAuth.

**Наиболее распространенными** являются [[Типы грантов OAuth 2.0|типы грантов]] «[[Типы грантов OAuth 2.0#Authorization Code Grant (грант кода авторизации)|код авторизации]]» и «[[Типы грантов OAuth 2.0#Implicit Grant (неявный грант)|неявный]]»
В целом, оба этих типа грантов включают следующие этапы:
1. Клиентское приложение запрашивает доступ к подмножеству данных пользователя, указывая, какой тип предоставления он хочет использовать и какой вид доступа он хочет.
2. Пользователю предлагается войти в службу OAuth и явно дать свое согласие на запрашиваемый доступ.
3. Клиентское приложение получает уникальный токен доступа, который подтверждает, что у него есть разрешение от пользователя на доступ к запрошенным данным. То, как именно это происходит, существенно различается в зависимости от типа гранта.
4. Клиентское приложение использует этот токен доступа для выполнения вызовов API, извлекая соответствующие данные с сервера ресурсов.

### OAuth-аутентификация

Хотя изначально OAuth не предназначался для этой цели, он также превратился в средство аутентификации пользователей. Пример многие веб-сайты, чтобы войти в систему, используя существующую учетную запись в социальной сети, вместо того, чтобы регистрироваться на соответствующем веб-сайте.

Для механизмов аутентификации OAuth основные потоки OAuth остаются в основном теми же; главное отличие заключается в том, как клиентское приложение использует полученные данные. С точки зрения конечного пользователя, результат аутентификации OAuth в целом напоминает единый вход [[Pentest/Термины#SSO (Single Sign-On) и SAML (Security Assertion Markup Language)|(SSO) на основе SAML]].

Аутентификация OAuth обычно реализуется следующим образом:

1. **Пользователь выбирает вариант входа** с помощью своего аккаунта в социальной сети. Затем клиентское приложение использует службу OAuth сайта социальной сети, чтобы запросить доступ к некоторым данным, которые оно может использовать для идентификации пользователя. Это может быть, например, адрес электронной почты, зарегистрированный в его аккаунте.

2. **Получив токен доступа, клиентское приложение запрашивает эти данные у сервера ресурсов**, как правило, из выделенной `/userinfo`конечной точки.

3. **Получив данные, клиентское приложение использует их вместо имени пользователя для входа в систему**. Токен доступа, полученный от сервера авторизации, часто используется вместо традиционного пароля.


## Как возникают уязвимости аутентификации OAuth?

Уязвимости аутентификации OAuth возникают отчасти из-за того, что спецификация OAuth относительно неопределенная и гибкая по своей сути. Хотя для базовой функциональности каждого типа гранта требуется несколько обязательных компонентов, подавляющее большинство реализации полностью необязательно. Это включает в себя множество настроек конфигурации, необходимых для обеспечения безопасности данных пользователей. Короче говоря, существует множество возможностей для проникновения плохой практики.

Еще одной ключевой проблемой OAuth является общее отсутствие встроенных функций безопасности. Безопасность почти полностью зависит от разработчиков, использующих правильную комбинацию параметров конфигурации и реализующих свои собственные дополнительные меры безопасности поверх, такие как надежная проверка ввода.

## Определение аутентификации OAuth

Распознать, когда приложение использует аутентификацию OAuth, относительно просто. Если вы видите возможность войти в систему, используя свою учетную запись с другого веб-сайта, это явный признак того, что используется OAuth.

Самый надежный способ идентификации аутентификации OAuth — проксировать трафик через Burp и проверять соответствующие сообщения HTTP при использовании этой опции входа. ==Независимо от того, какой тип предоставления OAuth используется, первым запросом потока всегда будет запрос к `/authorization`конечной точке, содержащий ряд параметров запроса, которые используются специально для OAuth. В частности, обратите внимание на параметры `client_id`, `redirect_uri`и `response_type`.== Например, запрос на авторизацию обычно выглядит примерно так:
```
GET /authorization?client_id=12345&redirect_uri=https://client-app.com/callback&response_type=token&scope=openid%20profile&state=ae13d489bd00e3c24 HTTP/1.1 
Host: oauth-authorization-server.com
```

## Рекон

Проведение базового анализа используемой службы OAuth может указать правильное направление при выявлении уязвимостей.

Если используется внешняя служба OAuth, мы должны иметь возможность идентифицировать конкретного провайдера по имени хоста, на который отправляется запрос авторизации. Поскольку эти службы предоставляют публичный API, часто доступна подробная документация, которая сообщит всевозможную полезную информацию, такую ​​как точные имена конечных точек и используемые параметры конфигурации.

Узнав имя хоста сервера авторизации, нам следует всегда пробовать отправлять `GET`запросы на следующие стандартные конечные точки:
- `/.well-known/oauth-authorization-server`
- `/.well-known/openid-configuration`
Они часто возвращают файл конфигурации JSON, содержащий ключевую информацию, например, подробности дополнительных функций, которые могут поддерживаться. Иногда это подскажет вам о более широкой поверхности атаки и поддерживаемых функциях, которые могут не быть упомянуты в документации.

## Использование уязвимостей аутентификации OAuth

==Уязвимости могут возникнуть в реализации OAuth клиентского приложения, а также в конфигурации самой службы OAuth.==
- Уязвимости в клиентском приложении
    - Неправильная реализация неявного типа гранта
    - Неисправная защита от CSRF-атак
- Уязвимости в сервисе OAuth
    - Утечка кодов авторизации и токенов доступа
    - Неправильная проверка области действия
    - Непроверенная регистрация пользователя

### Уязвимости в клиентском приложении
#### Уязвимости в клиентском приложении OAuth

Клиентские приложения часто используют авторитетный, проверенный сервис OAuth, который хорошо защищен от широко известных эксплойтов. Однако их собственная сторона реализации может быть менее безопасной.

В потоке OAuth много подвижных частей, с большим количеством необязательных параметров и настроек конфигурации в каждом типе гранта, что означает, что есть много возможностей для неправильных конфигураций.

##### Неправильная реализация неявного типа предоставления
Из-за опасностей, возникающих при отправке токенов доступа через браузер, [[Типы грантов OAuth 2.0#Implicit Grant (неявный грант)|неявный тип предоставления]] рекомендуется в основном для одностраничных приложений. Однако он также часто используется в классических клиент-серверных веб-приложениях из-за своей относительной простоты. Затем клиентское приложение получает доступ к токену с помощью JavaScript. Проблема в том, что если приложение хочет сохранить сеанс после того, как пользователь закрывает страницу, ему нужно где-то сохранить текущие данные пользователя (обычно идентификатор пользователя и токен доступа).

Чтобы решить эту проблему, **клиентское приложение часто отправляет эти данные на сервер в `POST`запросе**, а затем назначает пользователю сеансовый cookie, фактически регистрируя его. Этот запрос примерно эквивалентен запросу на отправку формы, который может быть отправлен как часть классического входа на основе пароля.
Однако в этом сценарии сервер не имеет никаких секретов или паролей для сравнения с отправленными данными, что означает, что ==они неявно доверены.==

В неявном потоке этот `POST`запрос становится доступен злоумышленникам через их браузер. В результате такое поведение может привести к серьезной уязвимости, если клиентское приложение не проверит должным образом, что токен доступа соответствует другим данным в запросе. В этом случае злоумышленник может просто изменить параметры, отправленные на сервер, чтобы выдать себя за любого пользователя.

##### Недостаточная защита от [[Cross-Site Request Forgery, CSRF|CSRF-атак]]
Многие компоненты потоков OAuth являются необязательными, некоторые из них настоятельно рекомендуются, если только нет веской причины не использовать их. Одним из таких примеров является параметр `state`.

Параметр `state`в идеале должен содержать неугадываемое значение, например хэш чего-то, связанного с сеансом пользователя, когда он впервые инициирует поток OAuth. Затем это значение передается туда и обратно между клиентским приложением и службой OAuth как форма токена CSRF для клиентского приложения.


Поэтому, если мы заметили, что запрос на авторизацию не отправляет параметр `state`это чрезвычайно интересно с точки зрения злоумышленника. Это потенциально означает, что можно сами инициировать поток OAuth, прежде чем обмануть браузер пользователя и заставить его завершить его, подобно традиционной атаке CSRF.

### Уязвимости в сервисе OAuth
##### Утечка кодов авторизации и токенов доступа
Это когда конфигурация самой службы OAuth позволяет злоумышленникам красть коды авторизации или токены доступа, связанные с учетными записями других пользователей. 

`/callback`В зависимости от типа гранта, через браузер жертвы на конечную точку, указанную в параметре запроса авторизации, отправляется либо код, либо токен `redirect_uri`. Если служба OAuth не может должным образом проверить этот URI, злоумышленник может сконструировать атаку, подобную CSRF, обманом заставив браузер жертвы инициировать поток OAuth, который отправит код или токен на контролируемый злоумышленником `redirect_uri`.

В случае потока кода авторизации злоумышленник потенциально может украсть код жертвы до его использования. Затем он может отправить этот код на законную `/callback`конечную точку клиентского приложения (оригинал `redirect_uri`), чтобы получить доступ к учетной записи пользователя. В этом сценарии злоумышленнику даже не нужно знать секрет клиента или полученный токен доступа. Пока у жертвы есть действительный сеанс со службой OAuth, клиентское приложение просто завершит обмен кодом/токеном от имени злоумышленника, прежде чем войти в учетную запись жертвы.

Внимание, что использование `state`защиты `nonce`не обязательно предотвращает подобные атаки, поскольку можем генерировать новые значения из своего собственного браузера.

Более безопасные серверы авторизации также потребуют `redirect_uri`отправки параметра при обмене кодом. Затем сервер может проверить, совпадает ли это с тем, что он получил в первоначальном запросе авторизации, и отклонить обмен, если нет. Поскольку это происходит в запросах сервер-сервер через безопасный обратный канал, злоумышленник не может контролировать этот второй `redirect_uri`параметр.

##### Неправильная проверка redirect_uri
Из разбора прошлой ошибки вытекает решение её это для клиентских приложений лучше всего предоставлять белый список их подлинных URI обратного вызова при регистрации в службе OAuth. Таким образом, когда служба OAuth получает новый запрос, она может проверить параметр `redirect_uri`по этому белому списку. В этом случае предоставление внешнего URI, скорее всего, приведет к ошибке. Однако все еще могут быть способы обойти эту проверку. И это разбор такой уязвимости

При аудите потока OAuth вам ==следует попробовать поэкспериментировать с `redirect_uri`параметром, чтобы понять, как он проверяется.== Например:
- Некоторые реализации допускают диапазон подкаталогов, проверяя только то, что строка начинается с правильной последовательности символов, т. е. с одобренного домена. следует попробовать удалить или добавить произвольные пути, параметры запроса и фрагменты, чтобы посмотреть, что можно изменить, не вызывая ошибку.

- Если мы можем добавить дополнительные значения к `redirect_uri`параметру по умолчанию, вы можете использовать несоответствия между анализом URI различными компонентами службы OAuth. Например, вы можете попробовать такие методы, как:
    `https://default-host.com &@foo.evil-user.net#@bar.evil-user.net/`
    
     [обойти распространенные методы защиты SSRF](https://portswigger.net/web-security/ssrf#circumventing-common-ssrf-defenses) и [CORS](https://portswigger.net/web-security/cors#errors-parsing-origin-headers) .
    
- Иногда можем столкнуться с уязвимостями загрязнения параметров на стороне сервера. На всякий случай попробуйте отправить дублирующие `redirect_uri`параметры следующим образом:
    `https://oauth-authorization-server.com/?client_id=123&redirect_uri=client-app.com/callback&redirect_uri=evil-user.net`
    
- Некоторые серверы также предоставляют особую обработку `localhost`URI, поскольку они часто используются во время разработки. В некоторых случаях любой перенаправленный URI, начинающийся с , `localhost`может быть случайно разрешен в производственной среде. Это может позволить вам обойти проверку, зарегистрировав доменное имя, например `localhost.evil-user.net`.

Важно отметить, что мы не должны ограничивать свое тестирование только проверкой `redirect_uri`параметра в изоляции. В реальных условиях часто придется экспериментировать с различными комбинациями изменений нескольких параметров. Иногда изменение одного параметра может повлиять на проверку других. Например, изменение from `response_mode`на `query`иногда `fragment`может полностью изменить синтаксический анализ `redirect_uri`, позволяя отправлять URI, которые в противном случае были бы заблокированы. Аналогично, если заметили, что `web_message`поддерживается режим ответа, это часто позволяет использовать более широкий диапазон поддоменов в `redirect_uri`.


##### Кража кодов и токенов доступа через прокси-страницу
На этом этапе мы уже должны иметь относительно хорошее понимание того, какие части URI можем изменить.

Другими словами, попытаться выяснить, можем ли мы изменить `redirect_uri`параметр, чтобы он указывал на какие-либо другие страницы в домене из белого списка.

Найти способы, с помощью которых вы сможете успешно получить доступ к различным поддоменам или путям. Например, URI по умолчанию часто будет на пути, специфичном для OAuth, таком как `/oauth/callback`, который вряд ли будет иметь какие-либо интересные подкаталоги. Однако вы можете использовать трюки обхода каталогов, чтобы предоставить любой произвольный путь в домене. Что-то вроде этого:
`https://client-app.com/oauth/callback/../../example/path`
На внутреннем уровне может интерпретироваться как:
`https://client-app.com/example/path`

После того, как мы определили, какие другие страницы можем установить в качестве URI перенаправления, мы должны проверить их на наличие дополнительных уязвимостей, которые потенциально помогут использовать для утечки кода или токена. Для [[Типы грантов OAuth 2.0#Authorization Code Grant (грант кода авторизации)|потока кода авторизации]] нужно найти уязвимость, которая дает нам доступ к параметрам запроса, тогда как для [[Типы грантов OAuth 2.0#Implicit Grant (неявный грант)|типа неявного предоставления]] нужно извлечь фрагмент URL.

Одной из самых полезных уязвимостей для этой цели является открытое перенаправление. Мы можем использовать его как прокси для пересылки жертв вместе с их кодом или токеном на контролируемый злоумышленником домен, где вы можете разместить любой вредоносный скрипт, который вам нравится.

Обратить внимание, что для типа неявного предоставления кража токена доступа не просто позволяет войти в учетную запись жертвы в клиентском приложении. Поскольку весь неявный поток происходит через браузер, а также можем использовать токен для выполнения собственных вызовов API к ресурсному серверу службы OAuth. Это может позволить извлечь конфиденциальные пользовательские данные, к которым мы обычно не можем получить доступ из веб-интерфейса клиентского приложения.

уязвимости которые позволяют извлечь код или токен и отправить его на внешний домен. Вот несколько хороших примеров:

- **Опасный JavaScript, который обрабатывает параметры запроса и фрагменты URL**  
    Например, небезопасные скрипты веб-сообщений могут быть хороши для этого. В некоторых сценариях вам, возможно, придется определить более длинную цепочку гаджетов, которая позволяет вам передавать токен через ряд скриптов, прежде чем в конечном итоге передать его на ваш внешний домен.
- **Уязвимости XSS**  
    Хотя атаки XSS сами по себе могут иметь огромное влияние, обычно существует небольшой промежуток времени, в течение которого злоумышленник имеет доступ к сеансу пользователя, прежде чем он закроет вкладку или уйдет. Поскольку атрибут `HTTPOnly`обычно используется для сеансовых cookie-файлов, злоумышленник часто также не сможет получить к ним прямой доступ с помощью XSS. Однако, украв код или токен OAuth, злоумышленник может получить доступ к учетной записи пользователя в его собственном браузере. Это дает им гораздо больше времени для изучения данных пользователя и выполнения вредоносных действий, что значительно увеличивает серьезность уязвимости XSS.
- **Уязвимости HTML-инъекции**  
    В случаях, когда вы не можете внедрить JavaScript (например, из-за ограничений [[Информационная безопасность#Безопасность контента|CSP]] или строгой фильтрации), вы все равно можете использовать простую HTML-инъекцию для кражи кодов авторизации. Если вы можете указать параметру `redirect_uri`страницу, на которой вы можете внедрить свой собственный HTML-контент, вы можете передать код через `Referer`заголовок. Например, рассмотрим следующий `img`элемент: `<img src="evil-user.net">`. При попытке получить это изображение некоторые браузеры (например, Firefox) отправят полный URL-адрес в `Referer`заголовке запроса, включая строку запроса.


### Неправильная проверка области действия

В любом потоке OAuth пользователь должен одобрить запрошенный доступ на основе области, определенной в запросе авторизации. Полученный токен позволяет клиентскому приложению получить доступ только к области, одобренной пользователем. Но в некоторых случаях злоумышленник может «обновить» токен доступа (украденный или полученный с помощью вредоносного клиентского приложения) с помощью дополнительных разрешений из-за некорректной проверки службой OAuth. Процесс выполнения этого зависит от типа гранта.

##### Обновление области действия: поток кода авторизации
При использовании [[Типы грантов OAuth 2.0#Тип предоставления кода авторизации|типа предоставления кода авторизации]] данные пользователя запрашиваются и отправляются через защищенную связь сервер-сервер, которую сторонний злоумышленник обычно не может манипулировать напрямую. Однако все еще может быть возможно достичь того же результата, зарегистрировав свое собственное клиентское приложение в службе OAuth.

Например, предположим, что вредоносное клиентское приложение изначально запросило доступ к адресу электронной почты пользователя, используя `openid email`область действия. После того, как пользователь одобрит этот запрос, вредоносное клиентское приложение получит код авторизации. Поскольку злоумышленник контролирует свое клиентское приложение, он может добавить еще один `scope`параметр в запрос обмена кодом/токеном, содержащий дополнительную `profile`область действия:
```
POST /token Host: oauth-authorization-server.com … client_id=12345&client_secret=SECRET&redirect_uri=https://client-app.com/callback&grant_type=authorization_code&code=a1b2c3d4e5f6g7h8&scope=openid%20 email%20profile
```

Если сервер не проверяет это на соответствие области действия из первоначального запроса авторизации, он иногда генерирует токен доступа, используя новую область действия, и отправляет его клиентскому приложению злоумышленника:
```
{ 
	"access_token": "z0y9x8w7v6u5", 
	"token_type": "Bearer", 
	"expires_in": 3600, 
	"scope": "openid email profile", … 
}
```
Затем злоумышленник может использовать свое приложение для совершения необходимых вызовов API для доступа к данным профиля пользователя.

##### Обновление области действия: неявный поток
Для [[Типы грантов OAuth 2.0#Implicit Grant (неявный грант)|типа неявного предоставления]] токен доступа отправляется через браузер, что означает, что злоумышленник может украсть токены, связанные с невинными клиентскими приложениями, и использовать их напрямую. После кражи токена доступа он может отправить обычный браузерный запрос на `/userinfo`конечную точку службы OAuth, вручную добавив новый `scope`параметр в процесс.

В идеале служба OAuth должна проверять это `scope`значение на соответствие тому, которое использовалось при генерации токена, но это не всегда так. Пока измененные разрешения не превышают уровень доступа, ранее предоставленный этому клиентскому приложению, злоумышленник может потенциально получить доступ к дополнительным данным, не требуя дополнительного одобрения от пользователя.

### Непроверенная регистрация пользователя

При аутентификации пользователей через OAuth клиентское приложение делает неявное предположение, что информация, хранящаяся поставщиком OAuth, верна. Это может быть опасным предположением.

Некоторые веб-сайты, предоставляющие услугу OAuth, позволяют пользователям регистрировать учетную запись без проверки всех своих данных, включая адрес электронной почты в некоторых случаях. Злоумышленник может воспользоваться этим, зарегистрировав учетную запись у провайдера OAuth, используя те же данные, что и у целевого пользователя, например, известный адрес электронной почты. Клиентские приложения затем могут позволить злоумышленнику войти в систему как жертва через эту мошенническую учетную запись у провайдера OAuth.

## Расширение OAuth с помощью OpenID Connect

При использовании для аутентификации OAuth часто расширяется слоем [[OpenID|OpenID Connect]], который предоставляет некоторые дополнительные функции, связанные с идентификацией и аутентификацией пользователей.

## Предотвращение уязвимостей аутентификации OAuth

Для разработчиков предоставляются [[Защита по OAuth|рекомендации]] о том, как избежать внедрения этих уязвимостей в ваши собственные веб-сайты и приложения.