# Сокрытие атак с использованием кодировок

Веб-сайты, которые тестируется в реальности, часто уже были проверены другими пользователями и к ним был применен ряд исправлений. Чтобы продвинуться дальше, нужно адаптировать методы для преодоления этих дополнительных препятствий, обнаруживая уязвимости, которые могли пропустить другие тестировщики.

Как можно скрыть вредоносные полезные нагрузки, чтобы обойти входные фильтры и другие несовершенные средства защиты

## Контекстно-зависимое декодирование

При построении атаки следует подумать о том, куда именно внедряется полезная нагрузка. Если мы можем сделать вывод о том, как наш ввод декодируется на основе этого контекста, то потенциально можно определить альтернативные способы представления той же полезной нагрузки.

## Расшифровка расхождений

Атаки с внедрением часто включают внедрение полезных нагрузок, которые используют узнаваемые шаблоны, такие как теги HTML, функции JavaScript или операторы SQL. Поскольку входные данные для этих полезных нагрузок почти никогда не содержат предоставленный пользователем код или разметку, веб-сайты часто внедряют защиту, которая блокирует запросы, содержащие эти подозрительные шаблоны.

Однако такие фильтры ввода также должны декодировать ввод, чтобы проверить, безопасен он или нет. **С точки зрения безопасности, крайне важно, чтобы декодирование, выполняемое при проверке ввода, было таким же, как декодирование, выполняемое внутренним сервером или браузером, когда он в конечном итоге использует данные.** ==Любое несоответствие может позволить злоумышленнику пронести вредоносные полезные данные мимо фильтра, применив различные кодировки,== которые будут автоматически удалены позже.

## Обфускация посредством кодирования URL

В URL-адресах ряд зарезервированных символов имеет особое значение.

Любой ввод на основе URL автоматически декодируется на стороне сервера, прежде чем он будет назначен соответствующим переменным. Это означает, что для большинства серверов последовательности вроде `%22`, `%3C`, и `%3E` в параметре запроса являются синонимами символов `"`, `<`, и `>`соответственно. Другими словами, мы можем вводить данные, закодированные в URL, через URL, и они, как правило, будут по-прежнему правильно интерпретироваться внутренним приложением.

Иногда можно обнаружить, что WAF и т. п. не могут правильно декодировать URL-адрес нашего ввода при его проверке. В этом случае можно переправить полезные данные в бэкэнд-приложение, просто кодируя любые символы или слова, которые занесены в черный список. Например, при атаке с использованием SQL-инъекции можно кодировать ключевые слова, с `SELECT` на `%53%45%4C%45%43%54`и т. д.

## Обфускация с помощью двойного кодирования URL

Некоторые серверы выполняют два раунда декодирования URL для любых URL, которые они получают. Это не обязательно является проблемой само по себе, при условии, что любые механизмы безопасности также дважды декодируют ввод при его проверке. В противном случае это несоответствие позволяет злоумышленнику тайно передать вредоносный ввод на бэкэнд, просто кодируя его дважды.

Допустим, внедряется стандартный XSS PoC, например `<img src=x onerror=alert(1)>`, через параметр запроса. В этом случае URL может выглядеть примерно так:
```
[...]/?search=%3Cimg%20src%3Dx%20onerror%3Dalert(1)%3E
```

При проверке запроса, если WAF выполняет стандартное декодирование URL, он легко идентифицирует эту хорошо известную полезную нагрузку. Запрос блокируется от попадания на бэкэнд. Но что, если мы дважды закодируем инъекцию? На практике это означает, что `%`сами символы затем заменяются на `%25`:
```
[...]/?search=%253Cimg%2520src%253Dx%2520onerror%253Dalert(1)%253E
```

Поскольку WAF декодирует это только один раз, он может не определить, что запрос опасен. Если бэкэнд-сервер впоследствии дважды декодирует этот ввод, полезная нагрузка будет успешно внедрена.

## Обфускация посредством HTML-кодирования

HTML-кодирование — это метод, при котором специальные символы заменяются на их кодированные эквиваленты, чтобы браузер мог корректно интерпретировать их как текст, а не как часть разметки. Это полезно для защиты от XSS (Cross-Site Scripting), но также может быть использовано злоумышленниками для обхода фильтров и внедрения вредоносного кода.

### Как работает HTML-кодирование?

В HTML некоторые символы имеют специальное значение. Например:
- `<` и `>` используются для тегов.
- `&` используется для начала HTML-сущностей.
- `"` и `'` используются для атрибутов.

Чтобы отобразить эти символы как текст, их нужно заменить на соответствующие HTML-сущности:
- `<` - `&lt;`
- `>` - `&gt;`
- `&` - `&amp;`
- `"` - `&quot;`
- `'` - `&#39;`

### **Пример вредоносной нагрузки**

Злоумышленники используют HTML-кодирование, чтобы скрыть вредоносный код от фильтров и систем защиты. Например:
```
<img src=x onerror="alert(1)">
```

Если фильтры ищут строку `alert(1)`, её можно закодировать:
```
<img src=x onerror="&#x61;lert(1)">
```
- `&#x61;` - `a`

### Начальные нули
При использовании десятичной или шестнадцатеричной кодировки HTML может опционально включать произвольное количество начальных нулей в кодовые точки. Некоторые WAF и другие входные фильтры не могут адекватно это учесть.

Если полезные данные все равно блокируются после кодирования в HTML, то можно попробовать обойти фильтр, просто добавив к кодовым точкам несколько нулей:
```
<a href="javascript&#00000000000058;alert(1)">Click me</a>
```
- `&#00000000000058;` - `:` (двоеточие)

## Обфускация посредством XML-кодирования

XML тесно связан с HTML и также поддерживает кодировку символов с использованием тех же числовых escape-последовательностей. Это позволяет включать специальные символы в текстовое содержимое элементов, не нарушая синтаксис, что может быть полезно при тестировании на XSS через ввод на основе XML, например.

Даже если нам не нужно кодировать специальные символы, чтобы избежать синтаксических ошибок, мы можем потенциально воспользоваться этим поведением, чтобы скрыть полезные данные так же, как это делается с кодировкой HTML. Разница в том, что полезные данные декодируются самим сервером, а не клиентским браузером. Это полезно для обхода WAF и других фильтров, которые могут блокировать наши запросы, если они обнаруживают определенные ключевые слова, связанные с атаками SQL-инъекций.
```
<stockCheck> 
	<productId> 123 </productId> 
	<storeId> 999 &#x53;ELECT * FROM information_schema.tables </storeId> </stockCheck>
```
- `&#x53` - S

## Обфускация посредством экранирования Unicode

Последовательности Unicode escape состоят из префикса, `\u`за которым следует четырехзначный шестнадцатеричный код символа. Например, `\u003a`представляет двоеточие `:`. ES6 также поддерживает новую форму экранирования Unicode с использованием фигурных скобок: `\u{3a}`.

При разборе строк большинство языков программирования декодируют эти экранирования Unicode. Это включает в себя движок JavaScript, используемый браузерами. При внедрении в контекст строки мы можем обфусцировать клиентские полезные данные с помощью Unicode, как делали с экранированиями HTML в примере выше.

Например, эксплуатировать DOM XSS, где ввод передается в приемник `eval()`в виде строки. Если первые попытки блокируются, нужно попробовать экранировать один из символов следующим образом:
```
eval("\u0061lert(1)")
```
- `\u0061 `- a

Поскольку данные останутся закодированными на стороне сервера, они могут остаться незамеченными, пока браузер не раскодирует их снова.

Также стоит отметить, что экранирование Unicode в стиле ES6 также допускает необязательные начальные нули, поэтому некоторые WAF можно легко обмануть, используя ту же технику, которую мы использовали для кодировок HTML. Например:
```
<a href="javascript:\u{00000000061}alert(1)">Click me</a>
```


## Обфускация посредством экранирования шестнадцатеричных символов

Другим вариантом при внедрении в контекст строки является использование шестнадцатеричных экранированных символов, которые представляют символы с использованием их шестнадцатеричной кодовой точки с префиксом `\x`. Например, строчная буква `a`представлена ​​как `\x61`.

Как и экранированные символы Unicode, они будут декодироваться на стороне клиента, если входные данные оцениваются как строка:
```
eval("\x61lert")
```

Иногда вы также можно запутать SQL-выражения аналогичным образом, используя префикс `0x`. Например, `0x53454c454354`может быть декодировано для формирования `SELECT`ключевого слова.

## Обфускация посредством восьмеричного экранирования

Восьмеричное экранирование работает примерно так же, как и шестнадцатеричное, за исключением того, что ссылки на символы используют систему счисления с основанием 8, а не 16. Они имеют префикс в виде отдельной обратной косой черты, что означает, что строчная буква `a`представлена ​​как `\141`.
```
eval("\141lert(1)")
```

## Запутывание с помощью множественных кодировок

Важно отметить, что так же можно комбинировать кодировки, чтобы скрыть свои полезные данные за несколькими слоями обфускации.
```
<a href="javascript:&bsol;u0061lert(1)">Click me</a>
```
Браузеры сначала декодируют HTML, `&bsol;,`что приводит к обратному слешу. Это приводит к превращению экранирование Unicode `\u0061`:
`<a href="javascript:\u0061lert(1)">Click me</a>`
Затем он декодируется далее для формирования функционирующей полезной нагрузки XSS:
`<a href="javascript:alert(1)">Click me</a>`

Очевидно, что **для успешного внедрения полезной нагрузки таким способом необходимо четко понимать, какое декодирование выполняется на входных данных и в каком порядке.**

## Обфускация с помощью функции SQL CHAR()

Это и не является строго формой кодирования, но в некоторых случаях можно скрыть свои атаки SQL-инъекций с помощью `CHAR()`функции. Она принимает одну десятичную или шестнадцатеричную кодовую точку и возвращает соответствующий символ. Шестнадцатеричные коды должны иметь префикс `0x`. Например, и `CHAR(83)`и `CHAR(0x53)`возвращают заглавную букву `S`.

Объединяя возвращаемые значения, мы можем использовать этот подход для сокрытия заблокированных ключевых слов. Например, даже если `SELECT`находится в черном списке, следующая инъекция изначально кажется безвредной:
```
CHAR(83)+CHAR(69)+CHAR(76)+CHAR(69)+CHAR(67)+CHAR(84)
```

Однако когда приложение обрабатывает это как SQL, оно динамически создает `SELECT`ключевое слово и выполняет внедренный запрос.

# Использование Burp Scanner во время ручного тестирования

Тестирование определенных типов уязвимостей может быть довольно утомительным, особенно тех, которые включают в себя попытку многочисленных методов инъекций в каждом контролируемом входе. Делать это вручную часто непрактично из-за реальных временных ограничений, что может привести к пропуску критических уязвимостей.

Существует ряд способов оптимизировать рабочий процесс, используя Burp Scanner для дополнения собственных знаний и интуиции. Это не только снижает вероятность упустить что-то из виду, но и экономит драгоценное время, помогая быстро определять потенциальные векторы атак. Это означает, что мы можем сосредоточить свое время и усилия на вещах, которые нельзя легко автоматизировать, например, на разработке того, как использовать уязвимое поведение или связать его с другими результатами.

