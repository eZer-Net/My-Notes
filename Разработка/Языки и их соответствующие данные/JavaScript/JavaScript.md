JavaScript (JS) — это единственный динамический язык для клиентских сценариев в браузерах, который был изначально разработан только для этих целей.

бэкенд также пишется на JavaScript, чтобы не тратить время на переключение контекста.

JavaScript уникален, потому что его разработка связана с развитием браузеров и связанного с ними программного интерфейса DOM. Соответственно, у него есть особенности, о которых стоит узнать.

### Переменные и их область видимости

Определить переменную можно четырьмя способами:
```

// глобальная область видимости
age = 25;

// видимость внутри функции
var age = 25;

// блочная область видимости
let age = 25;

// блочная область видимости без возможности переназначения
const age = 25;

```

Все переменные без идентификатора также будут иметь указатель, добавленный к объекту window браузера:
```

// определение глобальной переменной типа integer
age = 25;

// прямой вызов (возвращает 25)
console.log(age);

// вызов через указатель на объект window (возвращает 25)
console.log(window.age);

```

var age = 25 - Переменная, определенная с ключевым словом var, привязана к ближайшей функции или, если блок функции не задан, оказывается глобальной. Возможно, некоторая путаница, связанная с такими переменными, в итоге привела к добавлению в язык ключевого слова let.
```
const func = function() {
	if (true) {
		// переменная age определяется внутри блока if
		var age = 25;
	}
/*
* вывод значения age даст 25
*
* это происходит, потому что ключевое слово var связано с
* ближайшей функцией, а не с ближайшим блоком.
*/
console.log(age);
};

```
Здесь переменная определяется ключевым словом var и значением 25. В большинстве других языков при попытке вывести ее значение в консоль оно окажется неопределенным. Ключевое слово var ограничивает область видимости функцией, а не блоком. Это может привести к путанице при отладке.

let age = 25 - В версии ECMAScript 6 (спецификации для JavaScript) появились два новых ключевых слова — let и const, определяющие объект так же, как и в других современных языках.

let создает переменную с блочной областью видимости:
```
const func = function() {
	if (true) {
		// переменная age определяется внутри блока if
		let age = 25;
	}
/*
* На этот раз команда console.log(age) вернет `undefined`.
*
* Потому что, в отличие от `var`, `let` привязывается к ближайшему блоку.
* Считается, что связывание области видимости с ближайшим
* блоком, а не с функцией увеличивает читабельность
* и уменьшает количество ошибок, связанных с областью видимости.
*/
console.log(age);
};
```

const age = 25 - Ключевое слово const, как и let, определяет переменную в блочной видимости **без права изменения**.
```
const func = function() {
	const age = 25;
	/*
	* Это даст: TypeError: ошибку присвоения переменной `age`
	*
	* Как и `let`, `const` связывает область видимости с блоком.
	* Основное отличие состоит в невозможности поменять значение
	* после создания экземпляра переменной.
	*
	* Свойства объекта, созданного с ключевым словом const,
	* можно менять. Это сохраняет неизменным указатель на переменную
	* `age` в памяти, позволяя менять ее значение или свойства.
	*/
	age = 35;
};
```

### Функции

В JavaScript функции также являются объектами. Это означает, что они могут быть назначены и переназначены с помощью тех же переменных и ключевых слов.

Это все примеры функций:
```
// анонимная функция
function () {}; 

// именованная функция с глобальной областью видимости
a = function() {};

// именованная функция с видимостью внутри функции
var a = function() { };

// именованная функция с блочной областью видимости
let a = function () {};

// именованная функция с блочной областью видимости без переназначения
const a = function () {};

// анонимная функция, наследующая родительский контекст
() => {};

// мгновенно выполняемое функциональное выражение (IIFE)
(function() { })();

```
Первая функция — анонимная. Ее нельзя вызвать напрямую, потому что у нее
отсутствует идентификатор

Четыре обычные функции, область видимости которых задана с помощью ключевых слов, как при переменной age.

Стрелочная — разделяет context со своим родителем 

Последняя функция IIFE. Эта аббревиатура расшифровывается как immediately invoked function expression, то есть немедленно выполняемые функциональные выражения. Такие функции запускаются сразу после загрузки и выполняются внутри собственного пространства имен. Они применяются для инкапсуляции блоков кода из сторонних источников.

==Для преобразования строк в base64 и обратно существуют функции btoa(str) и atob(base64)== . Пропустив строку в кодировке base64 через функцию atob, мы увидим отправленные по сети имя пользователя и пароль:
`atob('am9lOjEyMzQ=');`

### Контекст

Каждая функция в JS имеет набор свойств и прикрепленных к ней данных. Эта информация называется контекстом функции. Контекст можно менять во время выполнения кода. Для ссылки на объекты, хранящиеся в контексте функции, используется ключевое слово this:
```
const func = function() {
	this.age = 25;
	// возвращает 25
	console.log(this.age);
};
// возвращает undefined
console.log(this.age);

```

 Из-за трудности отладки контекста возникает множество досадных ошибок. Особенно часто это случается, когда контекст объекта необходимо передать другой функции. В языке JavaScript есть несколько вариантов решения этой проблемы, призванных помочь разработчикам в распределении контекста между функциями:
```
// создаем клон функции getAge() с контекстом от ageData
// и вызываем его с параметром 'joe'
const getBoundAge = getAge.bind(ageData)('joe');

// вызов функции getAge() с контекстом ageData и параметром joe
const boundAge = getAge.call(ageData, 'joe');

// вызов функции getAge() с контекстом ageData и параметром joe
const boundAge = getAge.apply(ageData, ['joe']);

```

Три функции, bind , call и apply, позволяют перемещать контекст от одной функции к другой. Разница между call и apply состоит в том, что первая принимает аргументы в виде списка, а вторая — в виде массива. Их можно легко менять местами.

Стрелочная функция — еще одно новое дополнение, помогающее управлять контекстом. Она наследует контекст своего родителя, позволяя передавать его от родительской функции к дочерней без явного вызова функций bind , call и apply:
```
// глобальный контекст
this.garlic = false;

// рецепт супа (garlic — чеснок)
const soup = { garlic: true };

// стандартная функция, присоединенная к объекту soup
soup.hasGarlic1 = function() { console.log(this.garlic); } // true

// стрелочная функция, присоединенная к глобальному контексту
soup.hasGarlic2 = () => { console.log(this.garlic); } // false

```

### Прототипное наследование

В JavaScript применяется очень гибкая прототипная система наследования. Но, разработчики зачастую предпочитают преобразовывать ее в систему на основе классов.

```
/*
* Псевдокласс vehicle (автомобиль), написанный на языке JavaScript.
*
* Это намеренно упрощенный пример, демонстрирующий
* основы прототипного наследования.
*/
const Vehicle = function(make, model) {
	this.make = make;
	this.model = model;
	this.print = function() {
		return `${this.make}: ${this.model}`;
	};
};
const prius = new Vehicle('Toyota', 'Prius');
console.log(prius.print());

```

Новые объекты в JavaScript появляются вместе с объектом proto, указывающим на прототип, конструктор которого вызвался во время создания объекта.
Это позволяет сравнивать объекты вот таким способом:
```
const prius = new Vehicle('Toyota', 'Prius');
const charger = new Vehicle('Dodge', 'Charger');

/*
* Легко заметить, что объекты "Prius" и "Charger" были созданы
* на базе объекта "Vehicle".
*/
prius.__proto__ === charger.__proto__;

```

### Асинхронное выполнение кода

Асинхронность относится к тем концепциям, которые «трудно понять, легко запомнить» )

Браузерам на регулярной основе приходится обмениваться данными с серверами, причем время между запросом и получением ответа сильно варьируется, потому что зависит от таких факторов, как размер полезной нагрузки, время задержки и время обработки данных на сервере. Для контроля этой вариативности часто применяется асинхронное выполнение кода.
```
// --- Попытка #1 ---
async.log('a');
async.log('b');
async.log('c');
// a
// b
// c

// --- Попытка #2 ---
async.log('a');
async.log('b');
async.log('c');
// a
// c
// b

```

**В сетевом программировании выполнение запросов занимает разное время. Более того, ответа можно вообще не дождаться. В веб-приложениях, написанных на JavaScript, такие ситуации часто решают с помощью асинхронного выполнения запросов.** 


В старых версиях JavaScript это обычно делалось с помощью обратных вызовов (callbacks):
```
const config = {
	privacy: public,
	acceptRequests: true
};

/*
* Сначала запрашиваем с сервера объект user.
* После выполнения запроса запрашиваем профиль пользователя.
* После выполнения запроса задаем конфигурацию профиля.
* После выполнения запроса выводим на консоль "Получилось!".
*/
getUser(function(user) {
	getUserProfile(user, function(profile) {
		setUserProfileConfig(profile, config, function(result) {
			console.log('Получилось!');
		});
	});
});

```

Обратные вызовы намного быстрее и эффективнее синхронной модели, но их
очень сложно читать и отлаживать.


**Более поздняя философия программирования предлагала создать объект многократного использования**, который **после завершения текущей функции будет вызывать следующую**. Речь идет о так называемых ==обещаниях, или промисах (promises)==, которые сегодня используются во многих ЯП:

Промис (Promise) — это объект в JavaScript, который представляет собой отложенное и потенциально асинхронное вычисление. Промисы позволяют обрабатывать результаты асинхронных операций более удобным и понятным образом, чем традиционные подходы, такие как колбэки.
	Основные характеристики промисов:
		1. Состояния:
		   • Ожидание (Pending): начальное состояние, промис еще не завершен.
		   • Исполнен (Fulfilled): операция завершена успешно, и промис имеет значение.
		   • Отклонен (Rejected): операция завершена с ошибкой, и промис имеет причину ошибки.
		2. Методы:
		   • then(onFulfilled, onRejected): метод для обработки успешного результата или ошибки. Возвращает новый промис.
		   • catch(onRejected): метод для обработки ошибок. Это сокращенная форма для then(null, onRejected).
		   • finally(onFinally): метод, который выполняется после завершения промиса (независимо от того, успешен он или нет).
```
const config = {
	privacy: public,
	acceptRequests: true
};

/*
* Сначала запрашиваем с сервера объект user.
* После выполнения запроса запрашиваем профиль пользователя.
* После выполнения запроса задаем конфигурацию профиля.
* В конце происходит обработка ошибок.
*/
const promise = new Promise((resolve, reject) => {
	getUser(function(user) {
		if (user) { return resolve(user); }
return reject();
});

}).then((user) => {
	getUserProfile(user, function(profile) {
		if (profile) { return resolve(profile); }
return reject();
});

}).then((profile) => {
	setUserProfile(profile, config, function(result) {
		if (result) { return resolve(result); }
	return reject();
});

}).catch((err) => {
	console.log('ошибка!');
});

```


Еще один способ написания асинхронного кода — функция async. В отличие от обычных функций, она специально добавлена, чтобы упростить процесс асинхронного программирования.
```
const config = {
	privacy: public,
	acceptRequests: true
};

/*
* Сначала запрашиваем с сервера объект user.
* После выполнения запроса запрашиваем профиль пользователя.
* После выполнения запроса задаем конфигурацию профиля.
*/
const setUserProfile = async function() {
	let user = await getUser();
	let userProfile = await getUserProfile(user);
	let setProfile = await setUserProfile(userProfile, config);
};
setUserProfile();

```

Поставленное перед функцией ключевое слово async превращает ее в промис. Еще одно ключевое слово, await, заставляет интерпретатор остановиться и подождать выполнения промиса. 

### Программный интерфейс DOM браузера

[[Что такое DOM и источники, приёмники|DOM (Document Object Model — объектная модель документа)]]

Структурированное представление данных, используемое браузером для управления состоянием. 
Пример объект window — один из стандартных объектов верхнего уровня, определенных спецификацией DOM.
![[Pasted image 20250104003959.png]]


Как и любой хороший язык, JavaScript опирается на мощную стандартную библиотеку. Эта библиотека известна как DOM. Модель DOM предоставляет стандартные хорошо протестированные и эффективные функциональные возможности, реализованные во всех основных браузерах. Это обеспечивает идентичное или почти идентичное выполнение кода в любом браузере.

Основные объекты в DOM — это window и document. Они оба тщательно определены в спецификации WhatWG.

## AJAX-запросы

AJAX (Asynchronous JavaScript and XML) — это технология, позволяющая веб-страницам асинхронно обмениваться данными с сервером без необходимости перезагрузки страницы. Это позволяет создавать более интерактивные и динамичные веб-приложения.

Основные характеристики AJAX:

1. Асинхронность: AJAX-запросы выполняются в фоновом режиме, что позволяет пользователю продолжать взаимодействовать с веб-страницей, пока данные загружаются.

2. Обмен данными: AJAX позволяет отправлять и получать данные в различных форматах, таких как JSON, XML, HTML или текст.

3. Использование JavaScript: AJAX-запросы обычно реализуются с помощью JavaScript, что позволяет динамически обновлять содержимое страницы.

4. XMLHttpRequest: В основе AJAX лежит объект XMLHttpRequest, который используется для создания и отправки запросов к серверу.

5. Современные альтернативы: С появлением Fetch API и других технологий (например, Axios) AJAX-запросы стали проще и удобнее в использовании.

#### Пример AJAX-запроса с использованием XMLHttpRequest (XHR):
- Описание: Это более старая технология, которая позволяет отправлять HTTP-запросы к серверу и обрабатывать ответы. Она была введена в Internet Explorer 5 и с тех пор поддерживается всеми современными браузерами.

- Синтаксис: Использует объект XMLHttpRequest, который предоставляет методы для отправки запросов, получения ответов и обработки событий.

```
var xhr = new XMLHttpRequest(); // Создаем новый объект XMLHttpRequest
xhr.open("GET", "https://api.example.com/data", true); // Настраиваем запрос
xhr.onreadystatechange = function () { // Устанавливаем обработчик событий
    if (xhr.readyState === 4 && xhr.status === 200) { // Проверяем статус запроса
        var data = JSON.parse(xhr.responseText); // Обрабатываем ответ
        console.log(data); // Выводим данные в консоль
    }
};
xhr.send(); // Отправляем запрос
```


#### Пример AJAX-запроса с использованием Fetch API:
- Описание: Это более современный интерфейс для выполнения HTTP-запросов, который был введен в стандарт JavaScript. Он предлагает более удобный и простой синтаксис, а также использует промисы для обработки асинхронных операций.

- Синтаксис: Использует функцию fetch(), которая возвращает промис. Это упрощает работу с асинхронностью и позволяет использовать async/await.

```
fetch("https://api.example.com/data") // Выполняем GET-запрос
    .then(response => {
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        return response.json(); // Преобразуем ответ в JSON
    })
    .then(data => {
        console.log(data); // Выводим данные в консоль
    })
    .catch(error => {
        console.error('There was a problem with the fetch operation:', error); // Обработка ошибок
    });
```


Применение AJAX:

- Динамическое обновление контента: Например, подгрузка комментариев на странице без ее перезагрузки.

- Автозаполнение форм: При вводе текста в поле поиска можно показывать подсказки на основе данных из базы.

- Загрузка данных по мере необходимости: Например, при прокрутке страницы можно загружать новые элементы списка.